// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Catalog API
 * This API gets and orders catalog items from different cloud sources.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cloud.redhat.com//api/catalog/v1.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AddPortfolioItem
 */
export interface AddPortfolioItem {
    /**
     * This is the ID of the portfolio item object.
     * @type {string}
     * @memberof AddPortfolioItem
     */
    portfolioItemId?: string;
}

/**
 *
 * @export
 * @interface ApprovalRequest
 */
export interface ApprovalRequest {
    /**
     * The unique identifier for this approval request.
     * @type {string}
     * @memberof ApprovalRequest
     */
    id?: string;
    /**
     * The id of the approval submitted to approval-api
     * @type {string}
     * @memberof ApprovalRequest
     */
    approvalRequestRef?: string;
    /**
     * The Order Item which the approval request belongs to
     * @type {string}
     * @memberof ApprovalRequest
     */
    orderItemId?: string;
    /**
     * The reason for the current state.
     * @type {string}
     * @memberof ApprovalRequest
     */
    reason?: string;
    /**
     *
     * @type {Date}
     * @memberof ApprovalRequest
     */
    requestCompletedAt?: Date;
    /**
     * The state of the approval request (approved, denied, undecided, canceled)
     * @type {string}
     * @memberof ApprovalRequest
     */
    state?: ApprovalRequest.StateEnum;
}

/**
 * @export
 * @namespace ApprovalRequest
 */
export namespace ApprovalRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Undecided = 'undecided',
        Approved = 'approved',
        Denied = 'denied',
        Canceled = 'canceled'
    }
}

/**
 *
 * @export
 * @interface ApprovalRequestsCollection
 */
export interface ApprovalRequestsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ApprovalRequestsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ApprovalRequestsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ApprovalRequest>}
     * @memberof ApprovalRequestsCollection
     */
    data?: Array<ApprovalRequest>;
}

/**
 *
 * @export
 * @interface CollectionLinks
 */
export interface CollectionLinks {
    /**
     * The link to fetch the first group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    first?: string;
    /**
     * The link to fetch the last group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    last?: string;
    /**
     * The link to fetch the previous group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    prev?: string;
    /**
     * The link to fetch the next group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    next?: string;
}

/**
 *
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     * Total number of items in the result set, of which only a subset is returned, defined by the QueryLimit parameter.
     * @type {number}
     * @memberof CollectionMetadata
     */
    count?: number;
}

/**
 *
 * @export
 * @interface CopyPortfolioItem
 */
export interface CopyPortfolioItem {
    /**
     * The portfolio to place the new copy of the Portfolio Item in
     * @type {string}
     * @memberof CopyPortfolioItem
     */
    portfolioId?: string;
    /**
     * The name of the copied portfolio item
     * @type {string}
     * @memberof CopyPortfolioItem
     */
    portfolioItemName?: string;
}

/**
 *
 * @export
 * @interface CreateIcon
 */
export interface CreateIcon {
    /**
     * The binary image contents
     * @type {any}
     * @memberof CreateIcon
     */
    content?: any;
    /**
     * The Portfolio this Icon belongs to
     * @type {string}
     * @memberof CreateIcon
     */
    portfolioId?: string;
    /**
     * The Portfolio Item this Icon belongs to
     * @type {string}
     * @memberof CreateIcon
     */
    portfolioItemId?: string;
}

/**
 *
 * @export
 * @interface CreatePortfolioItem
 */
export interface CreatePortfolioItem {
    /**
     * The service offering ref should be retrieved from a call to the Topology Service.
     * @type {string}
     * @memberof CreatePortfolioItem
     */
    serviceOfferingRef?: string;
}

/**
 *
 * @export
 * @interface DataDrivenFormSchema
 */
export interface DataDrivenFormSchema {
    /**
     *
     * @type {any}
     * @memberof DataDrivenFormSchema
     */
    schema?: any;
}

/**
 *
 * @export
 * @interface GraphQLRequest
 */
export interface GraphQLRequest {
    /**
     * The GraphQL query
     * @type {string}
     * @memberof GraphQLRequest
     */
    query: string;
    /**
     * If the Query contains several named operations, the operationName controls which one should be executed
     * @type {string}
     * @memberof GraphQLRequest
     */
    operationName?: string;
    /**
     * Optional Query variables
     * @type {any}
     * @memberof GraphQLRequest
     */
    variables?: any | null;
}

/**
 *
 * @export
 * @interface GraphQLResponse
 */
export interface GraphQLResponse {
    /**
     * Results from the GraphQL query
     * @type {any}
     * @memberof GraphQLResponse
     */
    data?: any;
    /**
     * Errors resulting from the GraphQL query
     * @type {Array<any>}
     * @memberof GraphQLResponse
     */
    errors?: Array<any>;
}

/**
 *
 * @export
 * @interface Icon
 */
export interface Icon {
    /**
     * The unique identifier for this Service Offering Icon
     * @type {string}
     * @memberof Icon
     */
    id?: string;
    /**
     * The Image reference containing the binary image data for this icon
     * @type {string}
     * @memberof Icon
     */
    imageId?: string;
    /**
     * Stores the Source Ref for this icon
     * @type {string}
     * @memberof Icon
     */
    sourceRef?: string;
    /**
     * The source ID for this icon
     * @type {string}
     * @memberof Icon
     */
    sourceId?: string;
    /**
     * The portfolio this icon belongs to.
     * @type {string}
     * @memberof Icon
     */
    portfolioId?: string;
    /**
     * The portfolio_item this icon belongs to.
     * @type {string}
     * @memberof Icon
     */
    portfolioItemId?: string;
}

/**
 *
 * @export
 * @interface ImportServicePlan
 */
export interface ImportServicePlan {
    /**
     * The Portfolio Item to import the service plans for.
     * @type {string}
     * @memberof ImportServicePlan
     */
    portfolioItemId?: string;
}

/**
 *
 * @export
 * @interface Order
 */
export interface Order {
    /**
     *
     * @type {string}
     * @memberof Order
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    userId?: string;
    /**
     * Current State of the order.
     * @type {string}
     * @memberof Order
     */
    state?: Order.StateEnum;
    /**
     *
     * @type {Date}
     * @memberof Order
     */
    createdAt?: Date;
    /**
     * The time at which the order request was sent to the Topology Service
     * @type {Date}
     * @memberof Order
     */
    orderRequestSentAt?: Date | null;
    /**
     *
     * @type {Date}
     * @memberof Order
     */
    completedAt?: Date;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    owner?: string;
}

/**
 * @export
 * @namespace Order
 */
export namespace Order {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Created = 'Created',
        ApprovalPending = 'Approval Pending',
        Ordered = 'Ordered',
        Failed = 'Failed',
        Completed = 'Completed',
        Canceled = 'Canceled'
    }
}

/**
 *
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    id?: string;
    /**
     *
     * @type {number}
     * @memberof OrderItem
     */
    count: number;
    /**
     *
     * @type {any}
     * @memberof OrderItem
     */
    serviceParameters: any;
    /**
     * The provider specific parameters needed to provision this service. This might include namespaces, special keys.
     * @type {any}
     * @memberof OrderItem
     */
    providerControlParameters: any;
    /**
     * Stores the service plan ref from the Topology Service.
     * @type {string}
     * @memberof OrderItem
     */
    servicePlanRef: string;
    /**
     * Stores the Portfolio Item ID.
     * @type {string}
     * @memberof OrderItem
     */
    portfolioItemId: string;
    /**
     * Current state of this order item.
     * @type {string}
     * @memberof OrderItem
     */
    state?: OrderItem.StateEnum;
    /**
     * The Order that the OrderItem belongs to.
     * @type {string}
     * @memberof OrderItem
     */
    orderId?: string;
    /**
     *
     * @type {Date}
     * @memberof OrderItem
     */
    createdAt?: Date;
    /**
     * The time at which the order request was sent to the Topology Service
     * @type {Date}
     * @memberof OrderItem
     */
    orderRequestSentAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof OrderItem
     */
    completedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof OrderItem
     */
    updatedAt?: Date;
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    owner?: string;
    /**
     * The external url of the service instance used with relation to this order item
     * @type {string}
     * @memberof OrderItem
     */
    externalUrl?: string;
    /**
     * The insights request id can be used to collect log data for this order item as its processed by the system
     * @type {string}
     * @memberof OrderItem
     */
    insightsRequestId?: string;
}

/**
 * @export
 * @namespace OrderItem
 */
export namespace OrderItem {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Created = 'Created',
        ApprovalPending = 'Approval Pending',
        Ordered = 'Ordered',
        Failed = 'Failed',
        Completed = 'Completed',
        Approved = 'Approved',
        Denied = 'Denied'
    }
}

/**
 *
 * @export
 * @interface OrderItemsCollection
 */
export interface OrderItemsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof OrderItemsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof OrderItemsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<OrderItem>}
     * @memberof OrderItemsCollection
     */
    data?: Array<OrderItem>;
}

/**
 *
 * @export
 * @interface OrdersCollection
 */
export interface OrdersCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof OrdersCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof OrdersCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Order>}
     * @memberof OrdersCollection
     */
    data?: Array<Order>;
}

/**
 *
 * @export
 * @interface Portfolio
 */
export interface Portfolio {
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    description?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof Portfolio
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    imageUrl?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    owner?: string;
    /**
     * The Portfolio Icon ID
     * @type {string}
     * @memberof Portfolio
     */
    iconId?: string;
    /**
     *
     * @type {Date}
     * @memberof Portfolio
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Portfolio
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface PortfolioItem
 */
export interface PortfolioItem {
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    id?: string;
    /**
     *
     * @type {boolean}
     * @memberof PortfolioItem
     */
    favorite?: boolean;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    description?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof PortfolioItem
     */
    orphan?: boolean;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    longDescription?: string | null;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    distributor?: string | null;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    documentationUrl?: string | null;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    supportUrl?: string | null;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    owner?: string;
    /**
     * The source reference this product was created from
     * @type {string}
     * @memberof PortfolioItem
     */
    serviceOfferingSourceRef?: string;
    /**
     * The service offering type stored by the Topology Service
     * @type {string}
     * @memberof PortfolioItem
     */
    serviceOfferingType?: string;
    /**
     * ID of a parent portfolio
     * @type {string}
     * @memberof PortfolioItem
     */
    portfolioId?: string;
    /**
     * The Portfolio Item Icon ID
     * @type {string}
     * @memberof PortfolioItem
     */
    iconId?: string;
    /**
     *
     * @type {Date}
     * @memberof PortfolioItem
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof PortfolioItem
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface PortfolioItemNextName
 */
export interface PortfolioItemNextName {
    /**
     *
     * @type {string}
     * @memberof PortfolioItemNextName
     */
    nextName?: string;
}

/**
 *
 * @export
 * @interface PortfolioItemsCollection
 */
export interface PortfolioItemsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof PortfolioItemsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof PortfolioItemsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<PortfolioItem>}
     * @memberof PortfolioItemsCollection
     */
    data?: Array<PortfolioItem>;
}

/**
 *
 * @export
 * @interface PortfoliosCollection
 */
export interface PortfoliosCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof PortfoliosCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof PortfoliosCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Portfolio>}
     * @memberof PortfoliosCollection
     */
    data?: Array<Portfolio>;
}

/**
 *
 * @export
 * @interface ProgressMessage
 */
export interface ProgressMessage {
    /**
     *
     * @type {Date}
     * @memberof ProgressMessage
     */
    receivedAt?: Date;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    level?: ProgressMessage.LevelEnum;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    orderItemId?: string;
}

/**
 * @export
 * @namespace ProgressMessage
 */
export namespace ProgressMessage {
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Info = 'info',
        Error = 'error',
        Warning = 'warning',
        Debug = 'debug'
    }
}

/**
 *
 * @export
 * @interface ProgressMessagesCollection
 */
export interface ProgressMessagesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ProgressMessagesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ProgressMessagesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ProgressMessage>}
     * @memberof ProgressMessagesCollection
     */
    data?: Array<ProgressMessage>;
}

/**
 *
 * @export
 * @interface RestoreKey
 */
export interface RestoreKey {
    /**
     *
     * @type {string}
     * @memberof RestoreKey
     */
    restoreKey?: string;
}

/**
 *
 * @export
 * @interface ServicePlan
 */
export interface ServicePlan {
    /**
     * The name of the service plan.
     * @type {string}
     * @memberof ServicePlan
     */
    name?: string;
    /**
     * The service plan description.
     * @type {string}
     * @memberof ServicePlan
     */
    description?: string;
    /**
     * The base schema imported from Topology
     * @type {any}
     * @memberof ServicePlan
     */
    base?: any;
    /**
     * The modified schema for Catalog
     * @type {any}
     * @memberof ServicePlan
     */
    modified?: any;
    /**
     * The reference ID of the Portfolio Item
     * @type {string}
     * @memberof ServicePlan
     */
    portfolioItemId?: string;
    /**
     * The unique identifier for this service plan.
     * @type {string}
     * @memberof ServicePlan
     */
    id?: string;
}

/**
 *
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    value?: string;
}

/**
 *
 * @export
 * @interface ShareInfo
 */
export interface ShareInfo {
    /**
     * The Group UUID
     * @type {string}
     * @memberof ShareInfo
     */
    groupUuid?: string;
    /**
     * The Group Name
     * @type {string}
     * @memberof ShareInfo
     */
    groupName?: string;
    /**
     * One or more permissions currently applied to this group.
     * @type {Array<string>}
     * @memberof ShareInfo
     */
    permissions?: Array<ShareInfo.PermissionsEnum>;
}

/**
 * @export
 * @namespace ShareInfo
 */
export namespace ShareInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum PermissionsEnum {
        Read = 'catalog:portfolios:read',
        Update = 'catalog:portfolios:update',
        Delete = 'catalog:portfolios:delete',
        Order = 'catalog:portfolios:order'
    }
}

/**
 *
 * @export
 * @interface SharePolicy
 */
export interface SharePolicy {
    /**
     * The permissions to apply for this share. Each permission comprises of 3 parts catalog:portfolios:verb separated by :. The valid verbs are read, update, delete and order
     * @type {Array<string>}
     * @memberof SharePolicy
     */
    permissions: Array<SharePolicy.PermissionsEnum>;
    /**
     * An array of group UUID's retrieved from the RBAC Service with whom the resource has to be shared.
     * @type {Array<string>}
     * @memberof SharePolicy
     */
    groupUuids: Array<string>;
}

/**
 * @export
 * @namespace SharePolicy
 */
export namespace SharePolicy {
    /**
     * @export
     * @enum {string}
     */
    export enum PermissionsEnum {
        Read = 'catalog:portfolios:read',
        Update = 'catalog:portfolios:update',
        Delete = 'catalog:portfolios:delete',
        Order = 'catalog:portfolios:order'
    }
}

/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    id?: string;
    /**
     *
     * @type {Date}
     * @memberof Tag
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    namespace?: string;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    value?: string;
}

/**
 *
 * @export
 * @interface TagItem
 */
export interface TagItem {
    /**
     *
     * @type {string}
     * @memberof TagItem
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof TagItem
     */
    namespace?: string;
    /**
     *
     * @type {string}
     * @memberof TagItem
     */
    value?: string;
}

/**
 *
 * @export
 * @interface TagsCollection
 */
export interface TagsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TagsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TagsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Tag>}
     * @memberof TagsCollection
     */
    data?: Array<Tag>;
}

/**
 *
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * The Request account number
     * @type {string}
     * @memberof Tenant
     */
    externalTenant?: string;
    /**
     * The internal tenant id
     * @type {string}
     * @memberof Tenant
     */
    id?: string;
}

/**
 * The tenant settings and schema
 * @export
 * @interface TenantSettings
 */
export interface TenantSettings {
    /**
     * The current settings for this tenant
     * @type {any}
     * @memberof TenantSettings
     */
    current?: any;
    /**
     * JSON Schema for the Tenant Settings
     * @type {any}
     * @memberof TenantSettings
     */
    schema?: any;
}

/**
 *
 * @export
 * @interface TenantsCollection
 */
export interface TenantsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TenantsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TenantsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Tenant>}
     * @memberof TenantsCollection
     */
    data?: Array<Tenant>;
}

/**
 *
 * @export
 * @interface UnsharePolicy
 */
export interface UnsharePolicy {
    /**
     * The permissions to remove for this resource.
     * @type {Array<string>}
     * @memberof UnsharePolicy
     */
    permissions: Array<UnsharePolicy.PermissionsEnum>;
    /**
     * An array of group UUID's retrieved from the RBAC Service from which the permissions have to be removed. If group uuids are not specified we will unshare it from all groups.
     * @type {Array<string>}
     * @memberof UnsharePolicy
     */
    groupUuids?: Array<string>;
}

/**
 * @export
 * @namespace UnsharePolicy
 */
export namespace UnsharePolicy {
    /**
     * @export
     * @enum {string}
     */
    export enum PermissionsEnum {
        Read = 'catalog:portfolios:read',
        Update = 'catalog:portfolios:update',
        Delete = 'catalog:portfolios:delete',
        Order = 'catalog:portfolios:order'
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options: any = {}): RequestArgs {
            const localVarPath = `/openapi.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(graphQLRequest: GraphQLRequest, options: any = {}): RequestArgs {
            // verify required parameter 'graphQLRequest' is not null or undefined
            if (graphQLRequest === null || graphQLRequest === undefined) {
                throw new RequiredError('graphQLRequest','Required parameter graphQLRequest was null or undefined when calling postGraphQL.');
            }
            const localVarPath = `/graphql`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GraphQLRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(graphQLRequest || {}) : (graphQLRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getDocumentation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(graphQLRequest: GraphQLRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphQLResponse> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).postGraphQL(graphQLRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any) {
            return DefaultApiFp(configuration).getDocumentation(options)(axios, basePath);
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(graphQLRequest: GraphQLRequest, options?: any) {
            return DefaultApiFp(configuration).postGraphQL(graphQLRequest, options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @summary Return this API document in JSON format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentation(options?: any) {
        return DefaultApiFp(this.configuration).getDocumentation(options)(this.axios, this.basePath);
    }

    /**
     * Performs a GraphQL Query
     * @summary Perform a GraphQL Query
     * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGraphQL(graphQLRequest: GraphQLRequest, options?: any) {
        return DefaultApiFp(this.configuration).postGraphQL(graphQLRequest, options)(this.axios, this.basePath);
    }

}

/**
 * IconApi - axios parameter creator
 * @export
 */
export const IconApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an Icon from the specified parameters
         * @summary Create an Icon
         * @param {any} [content] The binary image contents
         * @param {string} [portfolioId] The Portfolio this Icon belongs to
         * @param {string} [portfolioItemId] The Portfolio Item this Icon belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIcon(content?: any, portfolioId?: string, portfolioItemId?: string, options: any = {}): RequestArgs {
            const localVarPath = `/icons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (content !== undefined) {
                localVarFormParams.set('content', content as any);
            }

            if (portfolioId !== undefined) {
                localVarFormParams.set('portfolio_id', portfolioId as any);
            }

            if (portfolioItemId !== undefined) {
                localVarFormParams.set('portfolio_item_id', portfolioItemId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the icon based on the icon ID passed
         * @summary Delete an existing Icon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIcon(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyIcon.');
            }
            const localVarPath = `/icons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch an Icon by ID
         * @summary Fetch an Icon by ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getIcon.');
            }
            const localVarPath = `/icons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the specified portfolio item's icon image.
         * @summary Fetches the specified icon's image
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showIconData(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showIconData.');
            }
            const localVarPath = `/icons/{id}/icon_data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits Icon specified by the given ID.
         * @summary Edit an existing Icon
         * @param {string} id ID of the resource
         * @param {Icon} icon Parameters needed to update an Icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIcon(id: string, icon: Icon, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateIcon.');
            }
            // verify required parameter 'icon' is not null or undefined
            if (icon === null || icon === undefined) {
                throw new RequiredError('icon','Required parameter icon was null or undefined when calling updateIcon.');
            }
            const localVarPath = `/icons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Icon" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(icon || {}) : (icon || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IconApi - functional programming interface
 * @export
 */
export const IconApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates an Icon from the specified parameters
         * @summary Create an Icon
         * @param {any} [content] The binary image contents
         * @param {string} [portfolioId] The Portfolio this Icon belongs to
         * @param {string} [portfolioItemId] The Portfolio Item this Icon belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIcon(content?: any, portfolioId?: string, portfolioItemId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Icon> {
            const localVarAxiosArgs = IconApiAxiosParamCreator(configuration).createIcon(content, portfolioId, portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the icon based on the icon ID passed
         * @summary Delete an existing Icon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIcon(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = IconApiAxiosParamCreator(configuration).destroyIcon(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch an Icon by ID
         * @summary Fetch an Icon by ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Icon> {
            const localVarAxiosArgs = IconApiAxiosParamCreator(configuration).getIcon(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the specified portfolio item's icon image.
         * @summary Fetches the specified icon's image
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showIconData(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = IconApiAxiosParamCreator(configuration).showIconData(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Edits Icon specified by the given ID.
         * @summary Edit an existing Icon
         * @param {string} id ID of the resource
         * @param {Icon} icon Parameters needed to update an Icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIcon(id: string, icon: Icon, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Icon> {
            const localVarAxiosArgs = IconApiAxiosParamCreator(configuration).updateIcon(id, icon, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IconApi - factory interface
 * @export
 */
export const IconApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates an Icon from the specified parameters
         * @summary Create an Icon
         * @param {any} [content] The binary image contents
         * @param {string} [portfolioId] The Portfolio this Icon belongs to
         * @param {string} [portfolioItemId] The Portfolio Item this Icon belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIcon(content?: any, portfolioId?: string, portfolioItemId?: string, options?: any) {
            return IconApiFp(configuration).createIcon(content, portfolioId, portfolioItemId, options)(axios, basePath);
        },
        /**
         * Deletes the icon based on the icon ID passed
         * @summary Delete an existing Icon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIcon(id: string, options?: any) {
            return IconApiFp(configuration).destroyIcon(id, options)(axios, basePath);
        },
        /**
         * Fetch an Icon by ID
         * @summary Fetch an Icon by ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon(id: string, options?: any) {
            return IconApiFp(configuration).getIcon(id, options)(axios, basePath);
        },
        /**
         * Fetch the specified portfolio item's icon image.
         * @summary Fetches the specified icon's image
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showIconData(id: string, options?: any) {
            return IconApiFp(configuration).showIconData(id, options)(axios, basePath);
        },
        /**
         * Edits Icon specified by the given ID.
         * @summary Edit an existing Icon
         * @param {string} id ID of the resource
         * @param {Icon} icon Parameters needed to update an Icon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIcon(id: string, icon: Icon, options?: any) {
            return IconApiFp(configuration).updateIcon(id, icon, options)(axios, basePath);
        },
    };
};

/**
 * IconApi - object-oriented interface
 * @export
 * @class IconApi
 * @extends {BaseAPI}
 */
export class IconApi extends BaseAPI {
    /**
     * Creates an Icon from the specified parameters
     * @summary Create an Icon
     * @param {any} [content] The binary image contents
     * @param {string} [portfolioId] The Portfolio this Icon belongs to
     * @param {string} [portfolioItemId] The Portfolio Item this Icon belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IconApi
     */
    public createIcon(content?: any, portfolioId?: string, portfolioItemId?: string, options?: any) {
        return IconApiFp(this.configuration).createIcon(content, portfolioId, portfolioItemId, options)(this.axios, this.basePath);
    }

    /**
     * Deletes the icon based on the icon ID passed
     * @summary Delete an existing Icon
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IconApi
     */
    public destroyIcon(id: string, options?: any) {
        return IconApiFp(this.configuration).destroyIcon(id, options)(this.axios, this.basePath);
    }

    /**
     * Fetch an Icon by ID
     * @summary Fetch an Icon by ID
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IconApi
     */
    public getIcon(id: string, options?: any) {
        return IconApiFp(this.configuration).getIcon(id, options)(this.axios, this.basePath);
    }

    /**
     * Fetch the specified portfolio item's icon image.
     * @summary Fetches the specified icon's image
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IconApi
     */
    public showIconData(id: string, options?: any) {
        return IconApiFp(this.configuration).showIconData(id, options)(this.axios, this.basePath);
    }

    /**
     * Edits Icon specified by the given ID.
     * @summary Edit an existing Icon
     * @param {string} id ID of the resource
     * @param {Icon} icon Parameters needed to update an Icon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IconApi
     */
    public updateIcon(id: string, icon: Icon, options?: any) {
        return IconApiFp(this.configuration).updateIcon(id, icon, options)(this.axios, this.basePath);
    }

}

/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToOrder(orderId: string, orderItem: OrderItem, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling addToOrder.');
            }
            // verify required parameter 'orderItem' is not null or undefined
            if (orderItem === null || orderItem === undefined) {
                throw new RequiredError('orderItem','Required parameter orderItem was null or undefined when calling addToOrder.');
            }
            const localVarPath = `/orders/{order_id}/order_items`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderItem || {}) : (orderItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an updated order.
         * @summary Cancels a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling cancelOrder.');
            }
            const localVarPath = `/orders/{order_id}/cancel`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(options: any = {}): RequestArgs {
            const localVarPath = `/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the Order based on order ID passed
         * @summary Delete an existing Order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrder(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyOrder.');
            }
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItemsFromOrder(orderId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling listOrderItemsFromOrder.');
            }
            const localVarPath = `/orders/{order_id}/order_items`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores the order specified by the order ID.
         * @summary Restore specific Order
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrder(id: string, restoreKey: RestoreKey, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restoreOrder.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling restoreOrder.');
            }
            const localVarPath = `/orders/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestoreKey" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey || {}) : (restoreKey || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItemFromOrder(orderId: string, id: string, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling showOrderItemFromOrder.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrderItemFromOrder.');
            }
            const localVarPath = `/orders/{order_id}/order_items/{id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOrder(orderId: string, options: any = {}): RequestArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling submitOrder.');
            }
            const localVarPath = `/orders/{order_id}/submit_order`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToOrder(orderId: string, orderItem: OrderItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).addToOrder(orderId, orderItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an updated order.
         * @summary Cancels a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).cancelOrder(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).createOrder(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the Order based on order ID passed
         * @summary Delete an existing Order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrder(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).destroyOrder(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItemsFromOrder(orderId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemsCollection> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).listOrderItemsFromOrder(orderId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrdersCollection> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).listOrders(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Restores the order specified by the order ID.
         * @summary Restore specific Order
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrder(id: string, restoreKey: RestoreKey, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).restoreOrder(id, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItemFromOrder(orderId: string, id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).showOrderItemFromOrder(orderId, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOrder(orderId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).submitOrder(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToOrder(orderId: string, orderItem: OrderItem, options?: any) {
            return OrderApiFp(configuration).addToOrder(orderId, orderItem, options)(axios, basePath);
        },
        /**
         * Returns an updated order.
         * @summary Cancels a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options?: any) {
            return OrderApiFp(configuration).cancelOrder(orderId, options)(axios, basePath);
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(options?: any) {
            return OrderApiFp(configuration).createOrder(options)(axios, basePath);
        },
        /**
         * Deletes the Order based on order ID passed
         * @summary Delete an existing Order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrder(id: string, options?: any) {
            return OrderApiFp(configuration).destroyOrder(id, options)(axios, basePath);
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItemsFromOrder(orderId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderApiFp(configuration).listOrderItemsFromOrder(orderId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderApiFp(configuration).listOrders(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Restores the order specified by the order ID.
         * @summary Restore specific Order
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrder(id: string, restoreKey: RestoreKey, options?: any) {
            return OrderApiFp(configuration).restoreOrder(id, restoreKey, options)(axios, basePath);
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItemFromOrder(orderId: string, id: string, options?: any) {
            return OrderApiFp(configuration).showOrderItemFromOrder(orderId, id, options)(axios, basePath);
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOrder(orderId: string, options?: any) {
            return OrderApiFp(configuration).submitOrder(orderId, options)(axios, basePath);
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * Adds an order item to an order in pending state
     * @summary Add an order item to an order in pending state
     * @param {string} orderId The Order ID
     * @param {OrderItem} orderItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public addToOrder(orderId: string, orderItem: OrderItem, options?: any) {
        return OrderApiFp(this.configuration).addToOrder(orderId, orderItem, options)(this.axios, this.basePath);
    }

    /**
     * Returns an updated order.
     * @summary Cancels a given order
     * @param {string} orderId The Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).cancelOrder(orderId, options)(this.axios, this.basePath);
    }

    /**
     * Creates a new order.
     * @summary Create a new order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrder(options?: any) {
        return OrderApiFp(this.configuration).createOrder(options)(this.axios, this.basePath);
    }

    /**
     * Deletes the Order based on order ID passed
     * @summary Delete an existing Order
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public destroyOrder(id: string, options?: any) {
        return OrderApiFp(this.configuration).destroyOrder(id, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of items associated with an order.
     * @summary Gets a list of items in a given order
     * @param {string} orderId The Order ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrderItemsFromOrder(orderId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderApiFp(this.configuration).listOrderItemsFromOrder(orderId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of orders associated with the logged in user.
     * @summary Get a list of orders
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrders(limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderApiFp(this.configuration).listOrders(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Restores the order specified by the order ID.
     * @summary Restore specific Order
     * @param {string} id ID of the resource
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public restoreOrder(id: string, restoreKey: RestoreKey, options?: any) {
        return OrderApiFp(this.configuration).restoreOrder(id, restoreKey, options)(this.axios, this.basePath);
    }

    /**
     * Gets an order item associated with an order.
     * @summary Gets an individual order item from a given order
     * @param {string} orderId The Order ID
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public showOrderItemFromOrder(orderId: string, id: string, options?: any) {
        return OrderApiFp(this.configuration).showOrderItemFromOrder(orderId, id, options)(this.axios, this.basePath);
    }

    /**
     * Returns an updated order.
     * @summary Submit a given order
     * @param {string} orderId The Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public submitOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).submitOrder(orderId, options)(this.axios, this.basePath);
    }

}

/**
 * OrderItemApi - axios parameter creator
 * @export
 */
export const OrderItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the order item  based on order item ID passed
         * @summary Delete an existing OrderItem
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrderItem(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyOrderItem.');
            }
            const localVarPath = `/order_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'orderItemId' is not null or undefined
            if (orderItemId === null || orderItemId === undefined) {
                throw new RequiredError('orderItemId','Required parameter orderItemId was null or undefined when calling listApprovalRequests.');
            }
            const localVarPath = `/order_items/{order_item_id}/approval_requests`
                .replace(`{${"order_item_id"}}`, encodeURIComponent(String(orderItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/order_items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'orderItemId' is not null or undefined
            if (orderItemId === null || orderItemId === undefined) {
                throw new RequiredError('orderItemId','Required parameter orderItemId was null or undefined when calling listProgressMessages.');
            }
            const localVarPath = `/order_items/{order_item_id}/progress_messages`
                .replace(`{${"order_item_id"}}`, encodeURIComponent(String(orderItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores the order item specified by the order item ID.
         * @summary Restore specific Order item
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrderItem(id: string, restoreKey: RestoreKey, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restoreOrderItem.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling restoreOrderItem.');
            }
            const localVarPath = `/order_items/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestoreKey" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey || {}) : (restoreKey || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific order item based on the order item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrderItem.');
            }
            const localVarPath = `/order_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderItemApi - functional programming interface
 * @export
 */
export const OrderItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes the order item  based on order item ID passed
         * @summary Delete an existing OrderItem
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrderItem(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).destroyOrderItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalRequestsCollection> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).listApprovalRequests(orderItemId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemsCollection> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).listOrderItems(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgressMessagesCollection> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).listProgressMessages(orderItemId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Restores the order item specified by the order item ID.
         * @summary Restore specific Order item
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrderItem(id: string, restoreKey: RestoreKey, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).restoreOrderItem(id, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a specific order item based on the order item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem> {
            const localVarAxiosArgs = OrderItemApiAxiosParamCreator(configuration).showOrderItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrderItemApi - factory interface
 * @export
 */
export const OrderItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes the order item  based on order item ID passed
         * @summary Delete an existing OrderItem
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrderItem(id: string, options?: any) {
            return OrderItemApiFp(configuration).destroyOrderItem(id, options)(axios, basePath);
        },
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderItemApiFp(configuration).listApprovalRequests(orderItemId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderItemApiFp(configuration).listOrderItems(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return OrderItemApiFp(configuration).listProgressMessages(orderItemId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Restores the order item specified by the order item ID.
         * @summary Restore specific Order item
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrderItem(id: string, restoreKey: RestoreKey, options?: any) {
            return OrderItemApiFp(configuration).restoreOrderItem(id, restoreKey, options)(axios, basePath);
        },
        /**
         * Gets a specific order item based on the order item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(id: string, options?: any) {
            return OrderItemApiFp(configuration).showOrderItem(id, options)(axios, basePath);
        },
    };
};

/**
 * OrderItemApi - object-oriented interface
 * @export
 * @class OrderItemApi
 * @extends {BaseAPI}
 */
export class OrderItemApi extends BaseAPI {
    /**
     * Deletes the order item  based on order item ID passed
     * @summary Delete an existing OrderItem
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public destroyOrderItem(id: string, options?: any) {
        return OrderItemApiFp(this.configuration).destroyOrderItem(id, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
     * @summary Gets a list of approval requests for an item
     * @param {string} orderItemId The Order Item ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderItemApiFp(this.configuration).listApprovalRequests(orderItemId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of order items.
     * @summary List Order Items
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listOrderItems(limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderItemApiFp(this.configuration).listOrderItems(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
     * @summary Gets a list of progress messages in an item
     * @param {string} orderItemId The Order Item ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return OrderItemApiFp(this.configuration).listProgressMessages(orderItemId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Restores the order item specified by the order item ID.
     * @summary Restore specific Order item
     * @param {string} id ID of the resource
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public restoreOrderItem(id: string, restoreKey: RestoreKey, options?: any) {
        return OrderItemApiFp(this.configuration).restoreOrderItem(id, restoreKey, options)(this.axios, this.basePath);
    }

    /**
     * Gets a specific order item based on the order item ID passed
     * @summary Gets a specific order item
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public showOrderItem(id: string, options?: any) {
        return OrderItemApiFp(this.configuration).showOrderItem(id, options)(this.axios, this.basePath);
    }

}

/**
 * PortfolioApi - axios parameter creator
 * @export
 */
export const PortfolioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {TagItem} tagItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemTag(id: string, tagItem: TagItem, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPortfolioItemTag.');
            }
            // verify required parameter 'tagItem' is not null or undefined
            if (tagItem === null || tagItem === undefined) {
                throw new RequiredError('tagItem','Required parameter tagItem was null or undefined when calling addPortfolioItemTag.');
            }
            const localVarPath = `/portfolio_items/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TagItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tagItem || {}) : (tagItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new portfolio item to an existing portfolio.
         * @summary Add a portfolio item to a portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {AddPortfolioItem} addPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemToPortfolio(portfolioId: string, addPortfolioItem: AddPortfolioItem, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling addPortfolioItemToPortfolio.');
            }
            // verify required parameter 'addPortfolioItem' is not null or undefined
            if (addPortfolioItem === null || addPortfolioItem === undefined) {
                throw new RequiredError('addPortfolioItem','Required parameter addPortfolioItem was null or undefined when calling addPortfolioItemToPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/portfolio_items`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddPortfolioItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addPortfolioItem || {}) : (addPortfolioItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {TagItem} tagItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioTag(id: string, tagItem: TagItem, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPortfolioTag.');
            }
            // verify required parameter 'tagItem' is not null or undefined
            if (tagItem === null || tagItem === undefined) {
                throw new RequiredError('tagItem','Required parameter tagItem was null or undefined when calling addPortfolioTag.');
            }
            const localVarPath = `/portfolios/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TagItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tagItem || {}) : (tagItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(portfolio: Portfolio, options: any = {}): RequestArgs {
            // verify required parameter 'portfolio' is not null or undefined
            if (portfolio === null || portfolio === undefined) {
                throw new RequiredError('portfolio','Required parameter portfolio was null or undefined when calling createPortfolio.');
            }
            const localVarPath = `/portfolios`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Portfolio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolio || {}) : (portfolio || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolio(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyPortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling fetchPortfolioItemsWithPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/portfolio_items`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listPortfolioTags.');
            }
            const localVarPath = `/portfolios/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolios(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/portfolios`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolio(portfolioId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling postCopyPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/copy`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareInfo(portfolioId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling shareInfo.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/share_info`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling sharePortfolio.');
            }
            // verify required parameter 'sharePolicy' is not null or undefined
            if (sharePolicy === null || sharePolicy === undefined) {
                throw new RequiredError('sharePolicy','Required parameter sharePolicy was null or undefined when calling sharePortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/share`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SharePolicy" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sharePolicy || {}) : (sharePolicy || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolio(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showPortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the specified portfolio's icon image.
         * @summary Fetches the specified portfolio's icon image
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioIcon(portfolioId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling showPortfolioIcon.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/icon`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolio(id: string, restoreKey: RestoreKey, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unDeletePortfolio.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling unDeletePortfolio.');
            }
            const localVarPath = `/portfolios/{id}/undelete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestoreKey" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey || {}) : (restoreKey || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling unsharePortfolio.');
            }
            // verify required parameter 'unsharePolicy' is not null or undefined
            if (unsharePolicy === null || unsharePolicy === undefined) {
                throw new RequiredError('unsharePolicy','Required parameter unsharePolicy was null or undefined when calling unsharePortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/unshare`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UnsharePolicy" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(unsharePolicy || {}) : (unsharePolicy || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, portfolio: Portfolio, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolio.');
            }
            // verify required parameter 'portfolio' is not null or undefined
            if (portfolio === null || portfolio === undefined) {
                throw new RequiredError('portfolio','Required parameter portfolio was null or undefined when calling updatePortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Portfolio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolio || {}) : (portfolio || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioApi - functional programming interface
 * @export
 */
export const PortfolioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {TagItem} tagItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemTag(id: string, tagItem: TagItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).addPortfolioItemTag(id, tagItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a new portfolio item to an existing portfolio.
         * @summary Add a portfolio item to a portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {AddPortfolioItem} addPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemToPortfolio(portfolioId: string, addPortfolioItem: AddPortfolioItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).addPortfolioItemToPortfolio(portfolioId, addPortfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {TagItem} tagItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioTag(id: string, tagItem: TagItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).addPortfolioTag(id, tagItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(portfolio: Portfolio, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).createPortfolio(portfolio, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolio(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).destroyPortfolio(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemsCollection> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).listPortfolioTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolios(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfoliosCollection> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).listPortfolios(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolio(portfolioId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).postCopyPortfolio(portfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareInfo(portfolioId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShareInfo>> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).shareInfo(portfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).sharePortfolio(portfolioId, sharePolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolio(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).showPortfolio(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the specified portfolio's icon image.
         * @summary Fetches the specified portfolio's icon image
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioIcon(portfolioId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).showPortfolioIcon(portfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).unDeletePortfolio(id, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).unsharePortfolio(portfolioId, unsharePolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, portfolio: Portfolio, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio> {
            const localVarAxiosArgs = PortfolioApiAxiosParamCreator(configuration).updatePortfolio(id, portfolio, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PortfolioApi - factory interface
 * @export
 */
export const PortfolioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {TagItem} tagItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemTag(id: string, tagItem: TagItem, options?: any) {
            return PortfolioApiFp(configuration).addPortfolioItemTag(id, tagItem, options)(axios, basePath);
        },
        /**
         * Adds a new portfolio item to an existing portfolio.
         * @summary Add a portfolio item to a portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {AddPortfolioItem} addPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemToPortfolio(portfolioId: string, addPortfolioItem: AddPortfolioItem, options?: any) {
            return PortfolioApiFp(configuration).addPortfolioItemToPortfolio(portfolioId, addPortfolioItem, options)(axios, basePath);
        },
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {TagItem} tagItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioTag(id: string, tagItem: TagItem, options?: any) {
            return PortfolioApiFp(configuration).addPortfolioTag(id, tagItem, options)(axios, basePath);
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(portfolio: Portfolio, options?: any) {
            return PortfolioApiFp(configuration).createPortfolio(portfolio, options)(axios, basePath);
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolio(id: string, options?: any) {
            return PortfolioApiFp(configuration).destroyPortfolio(id, options)(axios, basePath);
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return PortfolioApiFp(configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return PortfolioApiFp(configuration).listPortfolioTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolios(limit?: number, offset?: number, filter?: any, options?: any) {
            return PortfolioApiFp(configuration).listPortfolios(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolio(portfolioId: string, options?: any) {
            return PortfolioApiFp(configuration).postCopyPortfolio(portfolioId, options)(axios, basePath);
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareInfo(portfolioId: string, options?: any) {
            return PortfolioApiFp(configuration).shareInfo(portfolioId, options)(axios, basePath);
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any) {
            return PortfolioApiFp(configuration).sharePortfolio(portfolioId, sharePolicy, options)(axios, basePath);
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolio(id: string, options?: any) {
            return PortfolioApiFp(configuration).showPortfolio(id, options)(axios, basePath);
        },
        /**
         * Fetch the specified portfolio's icon image.
         * @summary Fetches the specified portfolio's icon image
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioIcon(portfolioId: string, options?: any) {
            return PortfolioApiFp(configuration).showPortfolioIcon(portfolioId, options)(axios, basePath);
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any) {
            return PortfolioApiFp(configuration).unDeletePortfolio(id, restoreKey, options)(axios, basePath);
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any) {
            return PortfolioApiFp(configuration).unsharePortfolio(portfolioId, unsharePolicy, options)(axios, basePath);
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, portfolio: Portfolio, options?: any) {
            return PortfolioApiFp(configuration).updatePortfolio(id, portfolio, options)(axios, basePath);
        },
    };
};

/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
    /**
     * Adds a single tag to Portfolio object
     * @summary Add Tag for Portfolio
     * @param {string} id ID of the resource
     * @param {TagItem} tagItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public addPortfolioItemTag(id: string, tagItem: TagItem, options?: any) {
        return PortfolioApiFp(this.configuration).addPortfolioItemTag(id, tagItem, options)(this.axios, this.basePath);
    }

    /**
     * Adds a new portfolio item to an existing portfolio.
     * @summary Add a portfolio item to a portfolio
     * @param {string} portfolioId The Portfolio ID
     * @param {AddPortfolioItem} addPortfolioItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public addPortfolioItemToPortfolio(portfolioId: string, addPortfolioItem: AddPortfolioItem, options?: any) {
        return PortfolioApiFp(this.configuration).addPortfolioItemToPortfolio(portfolioId, addPortfolioItem, options)(this.axios, this.basePath);
    }

    /**
     * Adds a single tag to Portfolio object
     * @summary Add Tag for Portfolio
     * @param {string} id ID of the resource
     * @param {TagItem} tagItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public addPortfolioTag(id: string, tagItem: TagItem, options?: any) {
        return PortfolioApiFp(this.configuration).addPortfolioTag(id, tagItem, options)(this.axios, this.basePath);
    }

    /**
     * Adds a portfolio.
     * @summary Add a new portfolio
     * @param {Portfolio} portfolio Parameters needed to add a Portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public createPortfolio(portfolio: Portfolio, options?: any) {
        return PortfolioApiFp(this.configuration).createPortfolio(portfolio, options)(this.axios, this.basePath);
    }

    /**
     * Deletes the portfolio specified by the ID.
     * @summary Delete an existing portfolio
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public destroyPortfolio(id: string, options?: any) {
        return PortfolioApiFp(this.configuration).destroyPortfolio(id, options)(this.axios, this.basePath);
    }

    /**
     * Gets all portfilio items in the portfolio specified by the given ID.
     * @summary Get all portfolio items from a specific portfolio
     * @param {string} portfolioId The Portfolio ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return PortfolioApiFp(this.configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for Portfolio
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public listPortfolioTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return PortfolioApiFp(this.configuration).listPortfolioTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of portfolios.
     * @summary List portfolios
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public listPortfolios(limit?: number, offset?: number, filter?: any, options?: any) {
        return PortfolioApiFp(this.configuration).listPortfolios(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Make a copy of the Portfolio.
     * @summary Make a copy of the Portfolio
     * @param {string} portfolioId The Portfolio ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public postCopyPortfolio(portfolioId: string, options?: any) {
        return PortfolioApiFp(this.configuration).postCopyPortfolio(portfolioId, options)(this.axios, this.basePath);
    }

    /**
     * Fetch share information about a portfolio
     * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
     * @param {string} portfolioId The Portfolio ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public shareInfo(portfolioId: string, options?: any) {
        return PortfolioApiFp(this.configuration).shareInfo(portfolioId, options)(this.axios, this.basePath);
    }

    /**
     * Share a Portfolio with one or more groups with specific permissions
     * @summary Share a portfolio with one or more groups with specific permission
     * @param {string} portfolioId The Portfolio ID
     * @param {SharePolicy} sharePolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any) {
        return PortfolioApiFp(this.configuration).sharePortfolio(portfolioId, sharePolicy, options)(this.axios, this.basePath);
    }

    /**
     * Gets the portfolio specified by the portfolio ID.
     * @summary Get a specific portfolio
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public showPortfolio(id: string, options?: any) {
        return PortfolioApiFp(this.configuration).showPortfolio(id, options)(this.axios, this.basePath);
    }

    /**
     * Fetch the specified portfolio's icon image.
     * @summary Fetches the specified portfolio's icon image
     * @param {string} portfolioId The Portfolio ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public showPortfolioIcon(portfolioId: string, options?: any) {
        return PortfolioApiFp(this.configuration).showPortfolioIcon(portfolioId, options)(this.axios, this.basePath);
    }

    /**
     * Undeletes the portfolio specified by the portfolio ID.
     * @summary Undelete specific portfolio
     * @param {string} id ID of the resource
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any) {
        return PortfolioApiFp(this.configuration).unDeletePortfolio(id, restoreKey, options)(this.axios, this.basePath);
    }

    /**
     * Unshare a Portfolio with one or more groups with specific permissions
     * @summary Unshare a portfolio from one or more groups with specific permission
     * @param {string} portfolioId The Portfolio ID
     * @param {UnsharePolicy} unsharePolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any) {
        return PortfolioApiFp(this.configuration).unsharePortfolio(portfolioId, unsharePolicy, options)(this.axios, this.basePath);
    }

    /**
     * Returns the edited portfolio.
     * @summary Edit an existing portfolio
     * @param {string} id ID of the resource
     * @param {Portfolio} portfolio Parameters needed to update a Portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public updatePortfolio(id: string, portfolio: Portfolio, options?: any) {
        return PortfolioApiFp(this.configuration).updatePortfolio(id, portfolio, options)(this.axios, this.basePath);
    }

}

/**
 * PortfolioItemApi - axios parameter creator
 * @export
 */
export const PortfolioItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options: any = {}): RequestArgs {
            // verify required parameter 'createPortfolioItem' is not null or undefined
            if (createPortfolioItem === null || createPortfolioItem === undefined) {
                throw new RequiredError('createPortfolioItem','Required parameter createPortfolioItem was null or undefined when calling createPortfolioItem.');
            }
            const localVarPath = `/portfolio_items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePortfolioItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createPortfolioItem || {}) : (createPortfolioItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolioItem(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the next name for a the Portfolio Item prior to a copy operation
         * @summary Get the next name for a the Portfolio Item prior to a copy operation
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {string} [destinationPortfolioId] The destination portfolio to compare names against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioItemNextName(portfolioItemId: string, destinationPortfolioId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling getPortfolioItemNextName.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/next_name`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (destinationPortfolioId !== undefined) {
                localVarQueryParameter['destination_portfolio_id'] = destinationPortfolioId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio Items
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItemTags(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listPortfolioItemTags.');
            }
            const localVarPath = `/portfolio_items/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItems(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/portfolio_items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the provider control parameters for a portfolio item.
         * @summary Gets the provider control parameters for this portfolio item; requires control paramaters provided when provisioning the portfolio item.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviderControlParameters(portfolioItemId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling listProviderControlParameters.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/provider_control_parameters`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the topology service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(portfolioItemId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling listServicePlans.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/service_plans`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling postCopyPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/copy`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CopyPortfolioItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(copyPortfolioItem || {}) : (copyPortfolioItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItem(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the specified portfolio item's icon image.
         * @summary Fetches the specified portfolio item's icon image
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItemIcon(portfolioItemId: string, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling showPortfolioItemIcon.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/icon`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolioItem(portfolioItemId: string, restoreKey: RestoreKey, options: any = {}): RequestArgs {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling unDeletePortfolioItem.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling unDeletePortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/undelete`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestoreKey" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey || {}) : (restoreKey || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioItem.');
            }
            // verify required parameter 'portfolioItem' is not null or undefined
            if (portfolioItem === null || portfolioItem === undefined) {
                throw new RequiredError('portfolioItem','Required parameter portfolioItem was null or undefined when calling updatePortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PortfolioItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolioItem || {}) : (portfolioItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioItemApi - functional programming interface
 * @export
 */
export const PortfolioItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).createPortfolioItem(createPortfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolioItem(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).destroyPortfolioItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the next name for a the Portfolio Item prior to a copy operation
         * @summary Get the next name for a the Portfolio Item prior to a copy operation
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {string} [destinationPortfolioId] The destination portfolio to compare names against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioItemNextName(portfolioItemId: string, destinationPortfolioId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemNextName> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).getPortfolioItemNextName(portfolioItemId, destinationPortfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio Items
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItemTags(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).listPortfolioItemTags(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItems(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemsCollection> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).listPortfolioItems(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the provider control parameters for a portfolio item.
         * @summary Gets the provider control parameters for this portfolio item; requires control paramaters provided when provisioning the portfolio item.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviderControlParameters(portfolioItemId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).listProviderControlParameters(portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the topology service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(portfolioItemId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServicePlan>> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).listServicePlans(portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItem(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).showPortfolioItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the specified portfolio item's icon image.
         * @summary Fetches the specified portfolio item's icon image
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItemIcon(portfolioItemId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).showPortfolioItemIcon(portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolioItem(portfolioItemId: string, restoreKey: RestoreKey, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).unDeletePortfolioItem(portfolioItemId, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem> {
            const localVarAxiosArgs = PortfolioItemApiAxiosParamCreator(configuration).updatePortfolioItem(id, portfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PortfolioItemApi - factory interface
 * @export
 */
export const PortfolioItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any) {
            return PortfolioItemApiFp(configuration).createPortfolioItem(createPortfolioItem, options)(axios, basePath);
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolioItem(id: string, options?: any) {
            return PortfolioItemApiFp(configuration).destroyPortfolioItem(id, options)(axios, basePath);
        },
        /**
         * Get the next name for a the Portfolio Item prior to a copy operation
         * @summary Get the next name for a the Portfolio Item prior to a copy operation
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {string} [destinationPortfolioId] The destination portfolio to compare names against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioItemNextName(portfolioItemId: string, destinationPortfolioId?: string, options?: any) {
            return PortfolioItemApiFp(configuration).getPortfolioItemNextName(portfolioItemId, destinationPortfolioId, options)(axios, basePath);
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio Items
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItemTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return PortfolioItemApiFp(configuration).listPortfolioItemTags(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItems(limit?: number, offset?: number, filter?: any, options?: any) {
            return PortfolioItemApiFp(configuration).listPortfolioItems(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Gets the provider control parameters for a portfolio item.
         * @summary Gets the provider control parameters for this portfolio item; requires control paramaters provided when provisioning the portfolio item.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviderControlParameters(portfolioItemId: string, options?: any) {
            return PortfolioItemApiFp(configuration).listProviderControlParameters(portfolioItemId, options)(axios, basePath);
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the topology service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(portfolioItemId: string, options?: any) {
            return PortfolioItemApiFp(configuration).listServicePlans(portfolioItemId, options)(axios, basePath);
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any) {
            return PortfolioItemApiFp(configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options)(axios, basePath);
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItem(id: string, options?: any) {
            return PortfolioItemApiFp(configuration).showPortfolioItem(id, options)(axios, basePath);
        },
        /**
         * Fetch the specified portfolio item's icon image.
         * @summary Fetches the specified portfolio item's icon image
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItemIcon(portfolioItemId: string, options?: any) {
            return PortfolioItemApiFp(configuration).showPortfolioItemIcon(portfolioItemId, options)(axios, basePath);
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolioItem(portfolioItemId: string, restoreKey: RestoreKey, options?: any) {
            return PortfolioItemApiFp(configuration).unDeletePortfolioItem(portfolioItemId, restoreKey, options)(axios, basePath);
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any) {
            return PortfolioItemApiFp(configuration).updatePortfolioItem(id, portfolioItem, options)(axios, basePath);
        },
    };
};

/**
 * PortfolioItemApi - object-oriented interface
 * @export
 * @class PortfolioItemApi
 * @extends {BaseAPI}
 */
export class PortfolioItemApi extends BaseAPI {
    /**
     * Adds a name and description for a portfolio item and returns the newly created portfolio item.
     * @summary Add a new portfolio item
     * @param {CreatePortfolioItem} createPortfolioItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).createPortfolioItem(createPortfolioItem, options)(this.axios, this.basePath);
    }

    /**
     * Deletes the portfolio item based on portfolio item ID passed
     * @summary Delete an existing portfolio item
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public destroyPortfolioItem(id: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).destroyPortfolioItem(id, options)(this.axios, this.basePath);
    }

    /**
     * Get the next name for a the Portfolio Item prior to a copy operation
     * @summary Get the next name for a the Portfolio Item prior to a copy operation
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {string} [destinationPortfolioId] The destination portfolio to compare names against
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public getPortfolioItemNextName(portfolioItemId: string, destinationPortfolioId?: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).getPortfolioItemNextName(portfolioItemId, destinationPortfolioId, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for Portfolio Items
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listPortfolioItemTags(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return PortfolioItemApiFp(this.configuration).listPortfolioItemTags(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets a list of portfolio items.
     * @summary List all portfolio items
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listPortfolioItems(limit?: number, offset?: number, filter?: any, options?: any) {
        return PortfolioItemApiFp(this.configuration).listPortfolioItems(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Gets the provider control parameters for a portfolio item.
     * @summary Gets the provider control parameters for this portfolio item; requires control paramaters provided when provisioning the portfolio item.
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listProviderControlParameters(portfolioItemId: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).listProviderControlParameters(portfolioItemId, options)(this.axios, this.basePath);
    }

    /**
     * Gets all service plans for a portfolio item.
     * @summary Gets all service plans for a specific portfolio item; requires a connection to the topology service.
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listServicePlans(portfolioItemId: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).listServicePlans(portfolioItemId, options)(this.axios, this.basePath);
    }

    /**
     * Make a copy of the Portfolio Item.
     * @summary Make a copy of the Portfolio Item
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {CopyPortfolioItem} [copyPortfolioItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options)(this.axios, this.basePath);
    }

    /**
     * Gets a specific portfolio item based on the portfolio item ID passed
     * @summary Gets a specific portfolio item
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public showPortfolioItem(id: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).showPortfolioItem(id, options)(this.axios, this.basePath);
    }

    /**
     * Fetch the specified portfolio item's icon image.
     * @summary Fetches the specified portfolio item's icon image
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public showPortfolioItemIcon(portfolioItemId: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).showPortfolioItemIcon(portfolioItemId, options)(this.axios, this.basePath);
    }

    /**
     * If a record has been discarded, this operation will undelete it so it can be requested normally.
     * @summary Undelete a specified Portfolio Item
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public unDeletePortfolioItem(portfolioItemId: string, restoreKey: RestoreKey, options?: any) {
        return PortfolioItemApiFp(this.configuration).unDeletePortfolioItem(portfolioItemId, restoreKey, options)(this.axios, this.basePath);
    }

    /**
     * Edits portfolio item specified by the given ID.
     * @summary Edit an existing portfolio item
     * @param {string} id ID of the resource
     * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).updatePortfolioItem(id, portfolioItem, options)(this.axios, this.basePath);
    }

}

/**
 * ServicePlansApi - axios parameter creator
 * @export
 */
export const ServicePlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the new Service Plan
         * @summary Create Service Plan
         * @param {ImportServicePlan} [importServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePlan(importServicePlan?: ImportServicePlan, options: any = {}): RequestArgs {
            const localVarPath = `/service_plans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ImportServicePlan" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(importServicePlan || {}) : (importServicePlan || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Service Plan Modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchServicePlanModified(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchServicePlanModified.');
            }
            const localVarPath = `/service_plans/{id}/modified`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified Service Plan
         * @summary Show Service Plan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServicePlan.');
            }
            const localVarPath = `/service_plans/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified Service Plan's base schema
         * @summary Show Service Plan Base Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanBase(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServicePlanBase.');
            }
            const localVarPath = `/service_plans/{id}/base`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified Service Plan's modified schema
         * @summary Show Service Plan modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanModified(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServicePlanModified.');
            }
            const localVarPath = `/service_plans/{id}/modified`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicePlansApi - functional programming interface
 * @export
 */
export const ServicePlansApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the new Service Plan
         * @summary Create Service Plan
         * @param {ImportServicePlan} [importServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePlan(importServicePlan?: ImportServicePlan, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServicePlan>> {
            const localVarAxiosArgs = ServicePlansApiAxiosParamCreator(configuration).createServicePlan(importServicePlan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Patch Service Plan Modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchServicePlanModified(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataDrivenFormSchema> {
            const localVarAxiosArgs = ServicePlansApiAxiosParamCreator(configuration).patchServicePlanModified(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified Service Plan
         * @summary Show Service Plan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlan> {
            const localVarAxiosArgs = ServicePlansApiAxiosParamCreator(configuration).showServicePlan(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified Service Plan's base schema
         * @summary Show Service Plan Base Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanBase(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataDrivenFormSchema> {
            const localVarAxiosArgs = ServicePlansApiAxiosParamCreator(configuration).showServicePlanBase(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified Service Plan's modified schema
         * @summary Show Service Plan modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanModified(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataDrivenFormSchema> {
            const localVarAxiosArgs = ServicePlansApiAxiosParamCreator(configuration).showServicePlanModified(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ServicePlansApi - factory interface
 * @export
 */
export const ServicePlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the new Service Plan
         * @summary Create Service Plan
         * @param {ImportServicePlan} [importServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePlan(importServicePlan?: ImportServicePlan, options?: any) {
            return ServicePlansApiFp(configuration).createServicePlan(importServicePlan, options)(axios, basePath);
        },
        /**
         *
         * @summary Patch Service Plan Modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchServicePlanModified(id: string, options?: any) {
            return ServicePlansApiFp(configuration).patchServicePlanModified(id, options)(axios, basePath);
        },
        /**
         * Returns the specified Service Plan
         * @summary Show Service Plan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan(id: string, options?: any) {
            return ServicePlansApiFp(configuration).showServicePlan(id, options)(axios, basePath);
        },
        /**
         * Returns the specified Service Plan's base schema
         * @summary Show Service Plan Base Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanBase(id: string, options?: any) {
            return ServicePlansApiFp(configuration).showServicePlanBase(id, options)(axios, basePath);
        },
        /**
         * Returns the specified Service Plan's modified schema
         * @summary Show Service Plan modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanModified(id: string, options?: any) {
            return ServicePlansApiFp(configuration).showServicePlanModified(id, options)(axios, basePath);
        },
    };
};

/**
 * ServicePlansApi - object-oriented interface
 * @export
 * @class ServicePlansApi
 * @extends {BaseAPI}
 */
export class ServicePlansApi extends BaseAPI {
    /**
     * Returns the new Service Plan
     * @summary Create Service Plan
     * @param {ImportServicePlan} [importServicePlan]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public createServicePlan(importServicePlan?: ImportServicePlan, options?: any) {
        return ServicePlansApiFp(this.configuration).createServicePlan(importServicePlan, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Patch Service Plan Modified Schema
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public patchServicePlanModified(id: string, options?: any) {
        return ServicePlansApiFp(this.configuration).patchServicePlanModified(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the specified Service Plan
     * @summary Show Service Plan
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public showServicePlan(id: string, options?: any) {
        return ServicePlansApiFp(this.configuration).showServicePlan(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the specified Service Plan's base schema
     * @summary Show Service Plan Base Schema
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public showServicePlanBase(id: string, options?: any) {
        return ServicePlansApiFp(this.configuration).showServicePlanBase(id, options)(this.axios, this.basePath);
    }

    /**
     * Returns the specified Service Plan's modified schema
     * @summary Show Service Plan modified Schema
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public showServicePlanModified(id: string, options?: any) {
        return ServicePlansApiFp(this.configuration).showServicePlanModified(id, options)(this.axios, this.basePath);
    }

}

/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Tenant Setting
         * @summary Create Tenant Setting
         * @param {Setting} setting Json encoded key/value pair to create a new setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetting(setting: Setting, options: any = {}): RequestArgs {
            // verify required parameter 'setting' is not null or undefined
            if (setting === null || setting === undefined) {
                throw new RequiredError('setting','Required parameter setting was null or undefined when calling createSetting.');
            }
            const localVarPath = `/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Setting" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(setting || {}) : (setting || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Tenant Setting
         * @summary Delete a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySetting(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling destroySetting.');
            }
            const localVarPath = `/settings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Tenant Settings
         * @summary List Tenant Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSettings(options: any = {}): RequestArgs {
            const localVarPath = `/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific Tenant Setting
         * @summary Get a specific Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSetting(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling showSetting.');
            }
            const localVarPath = `/settings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Tenant Setting
         * @summary Update a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(name: string, options: any = {}): RequestArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateSetting.');
            }
            const localVarPath = `/settings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create Tenant Setting
         * @summary Create Tenant Setting
         * @param {Setting} setting Json encoded key/value pair to create a new setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetting(setting: Setting, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SettingsApiAxiosParamCreator(configuration).createSetting(setting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Tenant Setting
         * @summary Delete a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySetting(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SettingsApiAxiosParamCreator(configuration).destroySetting(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List Tenant Settings
         * @summary List Tenant Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSettings(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantSettings> {
            const localVarAxiosArgs = SettingsApiAxiosParamCreator(configuration).listSettings(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific Tenant Setting
         * @summary Get a specific Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSetting(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SettingsApiAxiosParamCreator(configuration).showSetting(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Tenant Setting
         * @summary Update a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SettingsApiAxiosParamCreator(configuration).updateSetting(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create Tenant Setting
         * @summary Create Tenant Setting
         * @param {Setting} setting Json encoded key/value pair to create a new setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetting(setting: Setting, options?: any) {
            return SettingsApiFp(configuration).createSetting(setting, options)(axios, basePath);
        },
        /**
         * Delete a Tenant Setting
         * @summary Delete a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySetting(name: string, options?: any) {
            return SettingsApiFp(configuration).destroySetting(name, options)(axios, basePath);
        },
        /**
         * List Tenant Settings
         * @summary List Tenant Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSettings(options?: any) {
            return SettingsApiFp(configuration).listSettings(options)(axios, basePath);
        },
        /**
         * Get a specific Tenant Setting
         * @summary Get a specific Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSetting(name: string, options?: any) {
            return SettingsApiFp(configuration).showSetting(name, options)(axios, basePath);
        },
        /**
         * Update a Tenant Setting
         * @summary Update a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(name: string, options?: any) {
            return SettingsApiFp(configuration).updateSetting(name, options)(axios, basePath);
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Create Tenant Setting
     * @summary Create Tenant Setting
     * @param {Setting} setting Json encoded key/value pair to create a new setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createSetting(setting: Setting, options?: any) {
        return SettingsApiFp(this.configuration).createSetting(setting, options)(this.axios, this.basePath);
    }

    /**
     * Delete a Tenant Setting
     * @summary Delete a Tenant Setting
     * @param {string} name name of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public destroySetting(name: string, options?: any) {
        return SettingsApiFp(this.configuration).destroySetting(name, options)(this.axios, this.basePath);
    }

    /**
     * List Tenant Settings
     * @summary List Tenant Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public listSettings(options?: any) {
        return SettingsApiFp(this.configuration).listSettings(options)(this.axios, this.basePath);
    }

    /**
     * Get a specific Tenant Setting
     * @summary Get a specific Tenant Setting
     * @param {string} name name of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public showSetting(name: string, options?: any) {
        return SettingsApiFp(this.configuration).showSetting(name, options)(this.axios, this.basePath);
    }

    /**
     * Update a Tenant Setting
     * @summary Update a Tenant Setting
     * @param {string} name name of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateSetting(name: string, options?: any) {
        return SettingsApiFp(this.configuration).updateSetting(name, options)(this.axios, this.basePath);
    }

}

/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an array of Portfolio Item objects
         * @summary List Portfolio Items for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagPortfolioItems(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagPortfolioItems.');
            }
            const localVarPath = `/tags/{id}/portfolio_items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Portfolio objects
         * @summary List Portfolios for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagPortfolios(id: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagPortfolios.');
            }
            const localVarPath = `/tags/{id}/portfolios`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Tags
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options: any = {}): RequestArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show a specific Tag
         * @summary Show Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTag(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showTag.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns an array of Portfolio Item objects
         * @summary List Portfolio Items for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagPortfolioItems(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemsCollection> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).listTagPortfolioItems(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Portfolio objects
         * @summary List Portfolios for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagPortfolios(id: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfoliosCollection> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).listTagPortfolios(id, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List Tags
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).listTags(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show a specific Tag
         * @summary Show Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTag(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).showTag(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns an array of Portfolio Item objects
         * @summary List Portfolio Items for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagPortfolioItems(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return TagsApiFp(configuration).listTagPortfolioItems(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Returns an array of Portfolio objects
         * @summary List Portfolios for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagPortfolios(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return TagsApiFp(configuration).listTagPortfolios(id, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * List Tags
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options?: any) {
            return TagsApiFp(configuration).listTags(options)(axios, basePath);
        },
        /**
         * Show a specific Tag
         * @summary Show Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTag(id: string, options?: any) {
            return TagsApiFp(configuration).showTag(id, options)(axios, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Returns an array of Portfolio Item objects
     * @summary List Portfolio Items for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTagPortfolioItems(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return TagsApiFp(this.configuration).listTagPortfolioItems(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array of Portfolio objects
     * @summary List Portfolios for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTagPortfolios(id: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return TagsApiFp(this.configuration).listTagPortfolios(id, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * List Tags
     * @summary List Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTags(options?: any) {
        return TagsApiFp(this.configuration).listTags(options)(this.axios, this.basePath);
    }

    /**
     * Show a specific Tag
     * @summary Show Tag
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public showTag(id: string, options?: any) {
        return TagsApiFp(this.configuration).showTag(id, options)(this.axios, this.basePath);
    }

}

/**
 * TenantApi - axios parameter creator
 * @export
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of tenants.
         * @summary List Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTenants(options: any = {}): RequestArgs {
            const localVarPath = `/tenants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the tenant specified by the tenant id.
         * @summary Get a specific Tenant
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTenant(tenantId: string, options: any = {}): RequestArgs {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling showTenant.');
            }
            const localVarPath = `/tenants/{tenant_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a task to seed the Tenant Groups required for an org admin to onboard additional users.
         * @summary Seed Tenant Groups
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantSeed(tenantId: string, options: any = {}): RequestArgs {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling tenantSeed.');
            }
            const localVarPath = `/tenants/{tenant_id}/seed`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 * @export
 */
export const TenantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of tenants.
         * @summary List Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTenants(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantsCollection> {
            const localVarAxiosArgs = TenantApiAxiosParamCreator(configuration).listTenants(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the tenant specified by the tenant id.
         * @summary Get a specific Tenant
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTenant(tenantId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant> {
            const localVarAxiosArgs = TenantApiAxiosParamCreator(configuration).showTenant(tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Run a task to seed the Tenant Groups required for an org admin to onboard additional users.
         * @summary Seed Tenant Groups
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantSeed(tenantId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TenantApiAxiosParamCreator(configuration).tenantSeed(tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TenantApi - factory interface
 * @export
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get a list of tenants.
         * @summary List Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTenants(options?: any) {
            return TenantApiFp(configuration).listTenants(options)(axios, basePath);
        },
        /**
         * Gets the tenant specified by the tenant id.
         * @summary Get a specific Tenant
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTenant(tenantId: string, options?: any) {
            return TenantApiFp(configuration).showTenant(tenantId, options)(axios, basePath);
        },
        /**
         * Run a task to seed the Tenant Groups required for an org admin to onboard additional users.
         * @summary Seed Tenant Groups
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantSeed(tenantId: string, options?: any) {
            return TenantApiFp(configuration).tenantSeed(tenantId, options)(axios, basePath);
        },
    };
};

/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
export class TenantApi extends BaseAPI {
    /**
     * Get a list of tenants.
     * @summary List Tenants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public listTenants(options?: any) {
        return TenantApiFp(this.configuration).listTenants(options)(this.axios, this.basePath);
    }

    /**
     * Gets the tenant specified by the tenant id.
     * @summary Get a specific Tenant
     * @param {string} tenantId ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public showTenant(tenantId: string, options?: any) {
        return TenantApiFp(this.configuration).showTenant(tenantId, options)(this.axios, this.basePath);
    }

    /**
     * Run a task to seed the Tenant Groups required for an org admin to onboard additional users.
     * @summary Seed Tenant Groups
     * @param {string} tenantId ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public tenantSeed(tenantId: string, options?: any) {
        return TenantApiFp(this.configuration).tenantSeed(tenantId, options)(this.axios, this.basePath);
    }

}

