// tslint:disable
/**
 * Catalog API
 * This API gets and orders catalog items from different cloud sources.
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * API Error
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * HTTP status code
     * @type {string}
     * @memberof ApiError
     */
    status?: string;
    /**
     * Error details
     * @type {string}
     * @memberof ApiError
     */
    details?: string;
}
/**
 * API Error collection
 * @export
 * @interface ApiErrorCollection
 */
export interface ApiErrorCollection {
    /**
     * Error list from the API query
     * @type {Array<ApiError>}
     * @memberof ApiErrorCollection
     */
    errors?: Array<ApiError>;
}
/**
 *
 * @export
 * @interface ApprovalRequest
 */
export interface ApprovalRequest {
    /**
     * The unique identifier for this approval request.
     * @type {string}
     * @memberof ApprovalRequest
     */
    id?: string;
    /**
     * The id of the approval submitted to approval-api
     * @type {string}
     * @memberof ApprovalRequest
     */
    approval_request_ref?: string;
    /**
     * The Order Item which the approval request belongs to
     * @type {string}
     * @memberof ApprovalRequest
     */
    order_item_id?: string;
    /**
     * The reason for the current state.
     * @type {string}
     * @memberof ApprovalRequest
     */
    reason?: string;
    /**
     *
     * @type {string}
     * @memberof ApprovalRequest
     */
    request_completed_at?: string;
    /**
     * The state of the approval request (approved, denied, undecided, canceled, error)
     * @type {string}
     * @memberof ApprovalRequest
     */
    state?: ApprovalRequestStateEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ApprovalRequestStateEnum {
    Undecided = 'undecided',
    Approved = 'approved',
    Denied = 'denied',
    Canceled = 'canceled',
    Error = 'error'
}

/**
 *
 * @export
 * @interface ApprovalRequestsCollection
 */
export interface ApprovalRequestsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ApprovalRequestsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ApprovalRequestsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ApprovalRequest>}
     * @memberof ApprovalRequestsCollection
     */
    data?: Array<ApprovalRequest>;
}
/**
 *
 * @export
 * @interface CollectionLinks
 */
export interface CollectionLinks {
    /**
     * The link to fetch the first group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    first?: string;
    /**
     * The link to fetch the last group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    last?: string;
    /**
     * The link to fetch the previous group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    prev?: string;
    /**
     * The link to fetch the next group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    next?: string;
}
/**
 *
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     * Total number of items in the result set, of which only a subset is returned, defined by the QueryLimit parameter.
     * @type {number}
     * @memberof CollectionMetadata
     */
    count?: number;
}
/**
 *
 * @export
 * @interface CopyPortfolioItem
 */
export interface CopyPortfolioItem {
    /**
     * The portfolio to place the new copy of the Portfolio Item in
     * @type {string}
     * @memberof CopyPortfolioItem
     */
    portfolio_id?: string;
    /**
     * The name of the copied portfolio item
     * @type {string}
     * @memberof CopyPortfolioItem
     */
    portfolio_item_name?: string;
}
/**
 *
 * @export
 * @interface CreateIcon
 */
export interface CreateIcon {
    /**
     * The binary image contents, maximum size is 250KB
     * @type {any}
     * @memberof CreateIcon
     */
    content?: any;
    /**
     * The Portfolio this Icon belongs to
     * @type {string}
     * @memberof CreateIcon
     */
    portfolio_id?: string;
    /**
     * The Portfolio Item this Icon belongs to
     * @type {string}
     * @memberof CreateIcon
     */
    portfolio_item_id?: string;
}
/**
 *
 * @export
 * @interface CreatePortfolioItem
 */
export interface CreatePortfolioItem {
    /**
     * The Portfolio this portfolio item should belong to
     * @type {string}
     * @memberof CreatePortfolioItem
     */
    portfolio_id: string;
    /**
     * The service offering ref should be retrieved from a call to the catalog inventory Service.
     * @type {string}
     * @memberof CreatePortfolioItem
     */
    service_offering_ref?: string;
}
/**
 *
 * @export
 * @interface GraphQLRequest
 */
export interface GraphQLRequest {
    /**
     * The GraphQL query
     * @type {string}
     * @memberof GraphQLRequest
     */
    query: string;
    /**
     * If the Query contains several named operations, the operationName controls which one should be executed
     * @type {string}
     * @memberof GraphQLRequest
     */
    operationName?: string;
    /**
     * Optional Query variables
     * @type {object}
     * @memberof GraphQLRequest
     */
    variables?: object | null;
}
/**
 *
 * @export
 * @interface GraphQLResponse
 */
export interface GraphQLResponse {
    /**
     * Results from the GraphQL query
     * @type {object}
     * @memberof GraphQLResponse
     */
    data?: object;
    /**
     * Errors resulting from the GraphQL query
     * @type {Array<object>}
     * @memberof GraphQLResponse
     */
    errors?: Array<object>;
}
/**
 *
 * @export
 * @interface Icon
 */
export interface Icon {
    /**
     * The unique identifier for this Service Offering Icon
     * @type {string}
     * @memberof Icon
     */
    id?: string;
    /**
     * The Image reference containing the binary image data for this icon
     * @type {string}
     * @memberof Icon
     */
    image_id?: string;
    /**
     * Stores the Source Ref for this icon
     * @type {string}
     * @memberof Icon
     */
    source_ref?: string;
    /**
     * The source ID for this icon
     * @type {string}
     * @memberof Icon
     */
    source_id?: string;
    /**
     * The portfolio this icon belongs to.
     * @type {string}
     * @memberof Icon
     */
    portfolio_id?: string;
    /**
     * The portfolio_item this icon belongs to.
     * @type {string}
     * @memberof Icon
     */
    portfolio_item_id?: string;
}
/**
 *
 * @export
 * @interface ImportServicePlan
 */
export interface ImportServicePlan {
    /**
     * The Portfolio Item to import the service plans for.
     * @type {string}
     * @memberof ImportServicePlan
     */
    portfolio_item_id?: string;
}
/**
 *
 * @export
 * @interface Order
 */
export interface Order {
    /**
     *
     * @type {string}
     * @memberof Order
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    user_id?: string;
    /**
     * Current State of the order.
     * @type {string}
     * @memberof Order
     */
    state?: OrderStateEnum;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    created_at?: string;
    /**
     * The time at which the order request was sent to the catalog inventory Service
     * @type {string}
     * @memberof Order
     */
    order_request_sent_at?: string | null;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    completed_at?: string;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    owner?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OrderStateEnum {
    Created = 'Created',
    ApprovalPending = 'Approval Pending',
    Ordered = 'Ordered',
    Failed = 'Failed',
    Completed = 'Completed',
    Canceled = 'Canceled'
}

/**
 *
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    id?: string;
    /**
     * Name of the Portfolio Item or Order Process
     * @type {string}
     * @memberof OrderItem
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof OrderItem
     */
    count: number;
    /**
     *
     * @type {object}
     * @memberof OrderItem
     */
    service_parameters?: object | null;
    /**
     * The provider specific parameters needed to provision this service. This might include namespaces, special keys.
     * @type {object}
     * @memberof OrderItem
     */
    provider_control_parameters?: object | null;
    /**
     * Stores the Portfolio Item ID.
     * @type {string}
     * @memberof OrderItem
     */
    portfolio_item_id: string;
    /**
     * Current state of this order item.
     * @type {string}
     * @memberof OrderItem
     */
    state?: OrderItemStateEnum;
    /**
     * The Order that the OrderItem belongs to.
     * @type {string}
     * @memberof OrderItem
     */
    order_id?: string;
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    created_at?: string;
    /**
     * The time at which the order request was sent to the catalog inventory Service
     * @type {string}
     * @memberof OrderItem
     */
    order_request_sent_at?: string;
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    completed_at?: string;
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof OrderItem
     */
    owner?: string;
    /**
     * The external url of the service instance used with relation to this order item
     * @type {string}
     * @memberof OrderItem
     */
    external_url?: string;
    /**
     * The insights request id can be used to collect log data for this order item as its processed by the system
     * @type {string}
     * @memberof OrderItem
     */
    insights_request_id?: string;
    /**
     * The sequence that this order item is ran relative to the other order items within the order.
     * @type {number}
     * @memberof OrderItem
     */
    process_sequence?: number;
    /**
     * Denotes the scope in which the order item will run for the order it belongs to. It can be \'before\', \'after\', or \'product\'
     * @type {string}
     * @memberof OrderItem
     */
    process_scope?: string;
    /**
     * Contains a prefix-stripped key/value object that contains all of the information exposed from product provisioning. Must be exposed from Tower with prefix \'expose_to_cloud_redhat_com_\'
     * @type {object}
     * @memberof OrderItem
     */
    artifacts?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum OrderItemStateEnum {
    Created = 'Created',
    ApprovalPending = 'Approval Pending',
    Ordered = 'Ordered',
    Failed = 'Failed',
    Completed = 'Completed',
    Approved = 'Approved',
    Denied = 'Denied',
    Canceled = 'Canceled'
}

/**
 *
 * @export
 * @interface OrderItemsCollection
 */
export interface OrderItemsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof OrderItemsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof OrderItemsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<OrderItem>}
     * @memberof OrderItemsCollection
     */
    data?: Array<OrderItem>;
}
/**
 *
 * @export
 * @interface OrderProcess
 */
export interface OrderProcess {
    /**
     *
     * @type {string}
     * @memberof OrderProcess
     */
    id?: string;
    /**
     * The name of the order process.
     * @type {string}
     * @memberof OrderProcess
     */
    name?: string;
    /**
     * The order process description.
     * @type {string}
     * @memberof OrderProcess
     */
    description?: string | null;
    /**
     *
     * @type {string}
     * @memberof OrderProcess
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof OrderProcess
     */
    updated_at?: string;
    /**
     * The ID of the portfolio item associated to the \'before\' step
     * @type {string}
     * @memberof OrderProcess
     */
    before_portfolio_item_id?: string;
    /**
     * The ID of the portfolio item associated to the \'after\' step
     * @type {string}
     * @memberof OrderProcess
     */
    after_portfolio_item_id?: string;
    /**
     * The ID of the portfolio item associated to the item\'s return
     * @type {string}
     * @memberof OrderProcess
     */
    return_portfolio_item_id?: string;
    /**
     * JSON Metadata about the order process
     * @type {object}
     * @memberof OrderProcess
     */
    metadata?: object;
}
/**
 *
 * @export
 * @interface OrderProcessAssociationsToRemove
 */
export interface OrderProcessAssociationsToRemove {
    /**
     *
     * @type {Array<string>}
     * @memberof OrderProcessAssociationsToRemove
     */
    associations_to_remove?: Array<OrderProcessAssociationsToRemoveAssociationsToRemoveEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum OrderProcessAssociationsToRemoveAssociationsToRemoveEnum {
    Before = 'before',
    After = 'after',
    Return = 'return'
}

/**
 *
 * @export
 * @interface OrderProcessCollection
 */
export interface OrderProcessCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof OrderProcessCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof OrderProcessCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<OrderProcess>}
     * @memberof OrderProcessCollection
     */
    data?: Array<OrderProcess>;
}
/**
 *
 * @export
 * @interface OrderProcessPortfolioItemId
 */
export interface OrderProcessPortfolioItemId {
    /**
     *
     * @type {string}
     * @memberof OrderProcessPortfolioItemId
     */
    portfolio_item_id?: string;
}
/**
 *
 * @export
 * @interface OrdersCollection
 */
export interface OrdersCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof OrdersCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof OrdersCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Order>}
     * @memberof OrdersCollection
     */
    data?: Array<Order>;
}
/**
 *
 * @export
 * @interface PatchModifiedServicePlan
 */
export interface PatchModifiedServicePlan {
    /**
     * the new modified schema for the service plan
     * @type {object}
     * @memberof PatchModifiedServicePlan
     */
    modified?: object;
}
/**
 *
 * @export
 * @interface Portfolio
 */
export interface Portfolio {
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    description?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof Portfolio
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    owner?: string;
    /**
     * The Portfolio Icon ID
     * @type {string}
     * @memberof Portfolio
     */
    icon_id?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof Portfolio
     */
    updated_at?: string;
    /**
     * JSON Metadata about the portfolio
     * @type {object}
     * @memberof Portfolio
     */
    metadata?: object;
}
/**
 *
 * @export
 * @interface PortfolioItem
 */
export interface PortfolioItem {
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    id?: string;
    /**
     *
     * @type {boolean}
     * @memberof PortfolioItem
     */
    favorite?: boolean;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    description?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof PortfolioItem
     */
    orphan?: boolean;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    state?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    long_description?: string | null;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    distributor?: string | null;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    documentation_url?: string | null;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    support_url?: string | null;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    owner?: string;
    /**
     * The source reference this product was created from
     * @type {string}
     * @memberof PortfolioItem
     */
    service_offering_source_ref?: string;
    /**
     * The service offering type stored by the catalog inventory Service
     * @type {string}
     * @memberof PortfolioItem
     */
    service_offering_type?: string;
    /**
     * ID of a parent portfolio
     * @type {string}
     * @memberof PortfolioItem
     */
    portfolio_id?: string;
    /**
     * The Portfolio Item Icon ID
     * @type {string}
     * @memberof PortfolioItem
     */
    icon_id?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof PortfolioItem
     */
    updated_at?: string;
    /**
     * JSON Metadata about the portfolio item
     * @type {object}
     * @memberof PortfolioItem
     */
    metadata?: object;
}
/**
 *
 * @export
 * @interface PortfolioItemNextName
 */
export interface PortfolioItemNextName {
    /**
     *
     * @type {string}
     * @memberof PortfolioItemNextName
     */
    next_name?: string;
}
/**
 *
 * @export
 * @interface PortfolioItemsCollection
 */
export interface PortfolioItemsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof PortfolioItemsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof PortfolioItemsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<PortfolioItem>}
     * @memberof PortfolioItemsCollection
     */
    data?: Array<PortfolioItem>;
}
/**
 *
 * @export
 * @interface PortfoliosCollection
 */
export interface PortfoliosCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof PortfoliosCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof PortfoliosCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Portfolio>}
     * @memberof PortfoliosCollection
     */
    data?: Array<Portfolio>;
}
/**
 *
 * @export
 * @interface ProgressMessage
 */
export interface ProgressMessage {
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    received_at?: string;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    level?: ProgressMessageLevelEnum;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof ProgressMessage
     */
    order_item_id?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProgressMessageLevelEnum {
    Info = 'info',
    Error = 'error',
    Warning = 'warning',
    Debug = 'debug'
}

/**
 *
 * @export
 * @interface ProgressMessagesCollection
 */
export interface ProgressMessagesCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ProgressMessagesCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ProgressMessagesCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<ProgressMessage>}
     * @memberof ProgressMessagesCollection
     */
    data?: Array<ProgressMessage>;
}
/**
 * The desired increment relative to its current position, or placement to top or bottom of the list.
 * @export
 * @interface Reposition
 */
export interface Reposition {
    /**
     * Move the record up (negative) or down (positive) in the list. Do not set it if placement is used
     * @type {number}
     * @memberof Reposition
     */
    increment?: number | null;
    /**
     * Place the record to the top or bottom of the list. Do not set it if increment is used
     * @type {string}
     * @memberof Reposition
     */
    placement?: RepositionPlacementEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RepositionPlacementEnum {
    Bottom = 'bottom',
    Top = 'top'
}

/**
 * Resource object definition
 * @export
 * @interface ResourceObject
 */
export interface ResourceObject {
    /**
     * Object type
     * @type {string}
     * @memberof ResourceObject
     */
    object_type: string;
    /**
     * Name of the application that the object belongs to
     * @type {string}
     * @memberof ResourceObject
     */
    app_name: string;
    /**
     * ID of the object
     * @type {string}
     * @memberof ResourceObject
     */
    object_id: string;
}
/**
 *
 * @export
 * @interface RestoreKey
 */
export interface RestoreKey {
    /**
     *
     * @type {string}
     * @memberof RestoreKey
     */
    restore_key?: string;
}
/**
 *
 * @export
 * @interface ServicePlan
 */
export interface ServicePlan {
    /**
     * The name of the service plan.
     * @type {string}
     * @memberof ServicePlan
     */
    name?: string;
    /**
     * The service plan description.
     * @type {string}
     * @memberof ServicePlan
     */
    description?: string;
    /**
     * JSON schema for the object.
     * @type {object}
     * @memberof ServicePlan
     */
    create_json_schema?: object;
    /**
     * The reference ID of the Portfolio Item
     * @type {string}
     * @memberof ServicePlan
     */
    portfolio_item_id?: string;
    /**
     * The unique identifier for this service plan.
     * @type {string}
     * @memberof ServicePlan
     */
    id?: string;
    /**
     * Whether or not the ServicePlan has been imported for editing
     * @type {boolean}
     * @memberof ServicePlan
     */
    imported?: boolean;
    /**
     * Whether or not the ServicePlan has a modified schema
     * @type {boolean}
     * @memberof ServicePlan
     */
    modified?: boolean;
}
/**
 *
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    value?: string;
}
/**
 *
 * @export
 * @interface ShareInfo
 */
export interface ShareInfo {
    /**
     * The Group UUID
     * @type {string}
     * @memberof ShareInfo
     */
    group_uuid?: string;
    /**
     * The Group Name
     * @type {string}
     * @memberof ShareInfo
     */
    group_name?: string;
    /**
     * One or more permissions currently applied to this group.
     * @type {Array<string>}
     * @memberof ShareInfo
     */
    permissions?: Array<ShareInfoPermissionsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareInfoPermissionsEnum {
    Read = 'read',
    Update = 'update',
    Delete = 'delete',
    Order = 'order'
}

/**
 *
 * @export
 * @interface SharePolicy
 */
export interface SharePolicy {
    /**
     * The permissions to apply for this share. The valid values are read, update, delete and order
     * @type {Array<string>}
     * @memberof SharePolicy
     */
    permissions: Array<SharePolicyPermissionsEnum>;
    /**
     * An array of group UUID\'s retrieved from the RBAC Service with whom the resource has to be shared.
     * @type {Array<string>}
     * @memberof SharePolicy
     */
    group_uuids: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum SharePolicyPermissionsEnum {
    Read = 'read',
    Update = 'update',
    Delete = 'delete',
    Order = 'order'
}

/**
 *
 * @export
 * @interface SubstitutionParameters
 */
export interface SubstitutionParameters {
    /**
     * substitutable string
     * @type {string}
     * @memberof SubstitutionParameters
     */
    attributes?: SubstitutionParametersAttributesEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SubstitutionParametersAttributesEnum {
    OrderApprovalDecision = 'order.approval.decision',
    OrderApprovalReason = 'order.approval.reason',
    OrderApprovalUpdatedAt = 'order.approval.updated_at',
    OrderCreatedAt = 'order.created_at',
    OrderOrderId = 'order.order_id',
    OrderOrderedByEmail = 'order.ordered_by.email',
    OrderOrderedByName = 'order.ordered_by.name',
    ProductDescription = 'product.description',
    ProductHelpUrl = 'product.help_url',
    ProductLongDescription = 'product.long_description',
    ProductName = 'product.name',
    ProductPlatform = 'product.platform',
    ProductPortfolioDescription = 'product.portfolio.description',
    ProductPortfolioName = 'product.portfolio.name',
    ProductStatus = 'product.status',
    ProductSupportUrl = 'product.support_url',
    ProductVendor = 'product.vendor'
}

/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    tag?: string;
}
/**
 *
 * @export
 * @interface TagsCollection
 */
export interface TagsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TagsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TagsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Tag>}
     * @memberof TagsCollection
     */
    data?: Array<Tag>;
}
/**
 *
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * The Request account number
     * @type {string}
     * @memberof Tenant
     */
    external_tenant?: string;
    /**
     * The internal tenant id
     * @type {string}
     * @memberof Tenant
     */
    id?: string;
    /**
     * Tenant Seeded
     * @type {boolean}
     * @memberof Tenant
     */
    seeded?: boolean;
}
/**
 * The tenant settings and schema
 * @export
 * @interface TenantSettings
 */
export interface TenantSettings {
    /**
     * The current settings for this tenant
     * @type {object}
     * @memberof TenantSettings
     */
    current?: object;
    /**
     * JSON Schema for the Tenant Settings
     * @type {object}
     * @memberof TenantSettings
     */
    schema?: object;
}
/**
 *
 * @export
 * @interface TenantsCollection
 */
export interface TenantsCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TenantsCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TenantsCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Tenant>}
     * @memberof TenantsCollection
     */
    data?: Array<Tenant>;
}
/**
 *
 * @export
 * @interface UnsharePolicy
 */
export interface UnsharePolicy {
    /**
     * The permissions to remove for this resource.
     * @type {Array<string>}
     * @memberof UnsharePolicy
     */
    permissions: Array<UnsharePolicyPermissionsEnum>;
    /**
     * An array of group UUID\'s retrieved from the RBAC Service from which the permissions have to be removed. If group uuids are not specified we will unshare it from all groups.
     * @type {Array<string>}
     * @memberof UnsharePolicy
     */
    group_uuids?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum UnsharePolicyPermissionsEnum {
    Read = 'read',
    Update = 'update',
    Delete = 'delete',
    Order = 'order'
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/openapi.json`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL: async (graphQLRequest: GraphQLRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphQLRequest' is not null or undefined
            if (graphQLRequest === null || graphQLRequest === undefined) {
                throw new RequiredError('graphQLRequest','Required parameter graphQLRequest was null or undefined when calling postGraphQL.');
            }
            const localVarPath = `/graphql`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof graphQLRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(graphQLRequest !== undefined ? graphQLRequest : {}) : (graphQLRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getDocumentation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGraphQL(graphQLRequest: GraphQLRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphQLResponse>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postGraphQL(graphQLRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).getDocumentation(options).then((request) => request(axios, basePath));
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(graphQLRequest: GraphQLRequest, options?: any): AxiosPromise<GraphQLResponse> {
            return DefaultApiFp(configuration).postGraphQL(graphQLRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @summary Return this API document in JSON format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentation(options?: any) {
        return DefaultApiFp(this.configuration).getDocumentation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a GraphQL Query
     * @summary Perform a GraphQL Query
     * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGraphQL(graphQLRequest: GraphQLRequest, options?: any) {
        return DefaultApiFp(this.configuration).postGraphQL(graphQLRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IconApi - axios parameter creator
 * @export
 */
export const IconApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an Icon from the specified parameters
         * @summary Create an Icon
         * @param {any} [content] The binary image contents, maximum size is 250KB
         * @param {string} [portfolioId] The Portfolio this Icon belongs to
         * @param {string} [portfolioItemId] The Portfolio Item this Icon belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIcon: async (content?: any, portfolioId?: string, portfolioItemId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/icons`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


            if (content !== undefined) {
                localVarFormParams.append('content', content as any);
            }

            if (portfolioId !== undefined) {
                localVarFormParams.append('portfolio_id', portfolioId as any);
            }

            if (portfolioItemId !== undefined) {
                localVarFormParams.append('portfolio_item_id', portfolioItemId as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the icon based on the icon ID passed
         * @summary Delete an existing Icon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIcon: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyIcon.');
            }
            const localVarPath = `/icons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IconApi - functional programming interface
 * @export
 */
export const IconApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates an Icon from the specified parameters
         * @summary Create an Icon
         * @param {any} [content] The binary image contents, maximum size is 250KB
         * @param {string} [portfolioId] The Portfolio this Icon belongs to
         * @param {string} [portfolioItemId] The Portfolio Item this Icon belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIcon(content?: any, portfolioId?: string, portfolioItemId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Icon>> {
            const localVarAxiosArgs = await IconApiAxiosParamCreator(configuration).createIcon(content, portfolioId, portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the icon based on the icon ID passed
         * @summary Delete an existing Icon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyIcon(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IconApiAxiosParamCreator(configuration).destroyIcon(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IconApi - factory interface
 * @export
 */
export const IconApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates an Icon from the specified parameters
         * @summary Create an Icon
         * @param {any} [content] The binary image contents, maximum size is 250KB
         * @param {string} [portfolioId] The Portfolio this Icon belongs to
         * @param {string} [portfolioItemId] The Portfolio Item this Icon belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIcon(content?: any, portfolioId?: string, portfolioItemId?: string, options?: any): AxiosPromise<Icon> {
            return IconApiFp(configuration).createIcon(content, portfolioId, portfolioItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the icon based on the icon ID passed
         * @summary Delete an existing Icon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIcon(id: string, options?: any): AxiosPromise<void> {
            return IconApiFp(configuration).destroyIcon(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IconApi - object-oriented interface
 * @export
 * @class IconApi
 * @extends {BaseAPI}
 */
export class IconApi extends BaseAPI {
    /**
     * Creates an Icon from the specified parameters
     * @summary Create an Icon
     * @param {any} [content] The binary image contents, maximum size is 250KB
     * @param {string} [portfolioId] The Portfolio this Icon belongs to
     * @param {string} [portfolioItemId] The Portfolio Item this Icon belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IconApi
     */
    public createIcon(content?: any, portfolioId?: string, portfolioItemId?: string, options?: any) {
        return IconApiFp(this.configuration).createIcon(content, portfolioId, portfolioItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the icon based on the icon ID passed
     * @summary Delete an existing Icon
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IconApi
     */
    public destroyIcon(id: string, options?: any) {
        return IconApiFp(this.configuration).destroyIcon(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToOrder: async (orderId: string, orderItem: OrderItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling addToOrder.');
            }
            // verify required parameter 'orderItem' is not null or undefined
            if (orderItem === null || orderItem === undefined) {
                throw new RequiredError('orderItem','Required parameter orderItem was null or undefined when calling addToOrder.');
            }
            const localVarPath = `/orders/{order_id}/order_items`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderItem !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderItem !== undefined ? orderItem : {}) : (orderItem || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an updated order.
         * @summary Cancels a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling cancelOrder.');
            }
            const localVarPath = `/orders/{order_id}/cancel`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the Order based on order ID passed
         * @summary Delete an existing Order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrder: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyOrder.');
            }
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItemsFromOrder: async (orderId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling listOrderItemsFromOrder.');
            }
            const localVarPath = `/orders/{order_id}/order_items`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of progress messages associated with an order. As the order is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderProgressMessages: async (orderId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling listOrderProgressMessages.');
            }
            const localVarPath = `/orders/{order_id}/progress_messages`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders: async (limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores the order specified by the order ID.
         * @summary Restore specific Order
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrder: async (id: string, restoreKey: RestoreKey, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restoreOrder.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling restoreOrder.');
            }
            const localVarPath = `/orders/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof restoreKey !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey !== undefined ? restoreKey : {}) : (restoreKey || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific order based on the order ID
         * @summary Get a specific order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrder: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrder.');
            }
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItemFromOrder: async (orderId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling showOrderItemFromOrder.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrderItemFromOrder.');
            }
            const localVarPath = `/orders/{order_id}/order_items/{id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling submitOrder.');
            }
            const localVarPath = `/orders/{order_id}/submit_order`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToOrder(orderId: string, orderItem: OrderItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).addToOrder(orderId, orderItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an updated order.
         * @summary Cancels a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).cancelOrder(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).createOrder(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the Order based on order ID passed
         * @summary Delete an existing Order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyOrder(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).destroyOrder(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrderItemsFromOrder(orderId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemsCollection>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).listOrderItemsFromOrder(orderId, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of progress messages associated with an order. As the order is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrderProgressMessages(orderId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgressMessagesCollection>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).listOrderProgressMessages(orderId, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrders(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrdersCollection>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).listOrders(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Restores the order specified by the order ID.
         * @summary Restore specific Order
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreOrder(id: string, restoreKey: RestoreKey, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).restoreOrder(id, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific order based on the order ID
         * @summary Get a specific order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showOrder(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).showOrder(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showOrderItemFromOrder(orderId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).showOrderItemFromOrder(orderId, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await OrderApiAxiosParamCreator(configuration).submitOrder(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds an order item to an order in pending state
         * @summary Add an order item to an order in pending state
         * @param {string} orderId The Order ID
         * @param {OrderItem} orderItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToOrder(orderId: string, orderItem: OrderItem, options?: any): AxiosPromise<OrderItem> {
            return OrderApiFp(configuration).addToOrder(orderId, orderItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an updated order.
         * @summary Cancels a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options?: any): AxiosPromise<Order> {
            return OrderApiFp(configuration).cancelOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new order.
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(options?: any): AxiosPromise<Order> {
            return OrderApiFp(configuration).createOrder(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the Order based on order ID passed
         * @summary Delete an existing Order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrder(id: string, options?: any): AxiosPromise<RestoreKey> {
            return OrderApiFp(configuration).destroyOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of items associated with an order.
         * @summary Gets a list of items in a given order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItemsFromOrder(orderId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<OrderItemsCollection> {
            return OrderApiFp(configuration).listOrderItemsFromOrder(orderId, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of progress messages associated with an order. As the order is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an order
         * @param {string} orderId The Order ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderProgressMessages(orderId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<ProgressMessagesCollection> {
            return OrderApiFp(configuration).listOrderProgressMessages(orderId, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of orders associated with the logged in user.
         * @summary Get a list of orders
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<OrdersCollection> {
            return OrderApiFp(configuration).listOrders(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores the order specified by the order ID.
         * @summary Restore specific Order
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrder(id: string, restoreKey: RestoreKey, options?: any): AxiosPromise<Order> {
            return OrderApiFp(configuration).restoreOrder(id, restoreKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific order based on the order ID
         * @summary Get a specific order
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrder(id: string, options?: any): AxiosPromise<Order> {
            return OrderApiFp(configuration).showOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an order item associated with an order.
         * @summary Gets an individual order item from a given order
         * @param {string} orderId The Order ID
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItemFromOrder(orderId: string, id: string, options?: any): AxiosPromise<OrderItem> {
            return OrderApiFp(configuration).showOrderItemFromOrder(orderId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an updated order.
         * @summary Submit a given order
         * @param {string} orderId The Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOrder(orderId: string, options?: any): AxiosPromise<Order> {
            return OrderApiFp(configuration).submitOrder(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * Adds an order item to an order in pending state
     * @summary Add an order item to an order in pending state
     * @param {string} orderId The Order ID
     * @param {OrderItem} orderItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public addToOrder(orderId: string, orderItem: OrderItem, options?: any) {
        return OrderApiFp(this.configuration).addToOrder(orderId, orderItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an updated order.
     * @summary Cancels a given order
     * @param {string} orderId The Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).cancelOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new order.
     * @summary Create a new order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrder(options?: any) {
        return OrderApiFp(this.configuration).createOrder(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the Order based on order ID passed
     * @summary Delete an existing Order
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public destroyOrder(id: string, options?: any) {
        return OrderApiFp(this.configuration).destroyOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of items associated with an order.
     * @summary Gets a list of items in a given order
     * @param {string} orderId The Order ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrderItemsFromOrder(orderId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return OrderApiFp(this.configuration).listOrderItemsFromOrder(orderId, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of progress messages associated with an order. As the order is being processed the provider can update the progress messages.
     * @summary Gets a list of progress messages in an order
     * @param {string} orderId The Order ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrderProgressMessages(orderId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return OrderApiFp(this.configuration).listOrderProgressMessages(orderId, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of orders associated with the logged in user.
     * @summary Get a list of orders
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public listOrders(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return OrderApiFp(this.configuration).listOrders(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores the order specified by the order ID.
     * @summary Restore specific Order
     * @param {string} id ID of the resource
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public restoreOrder(id: string, restoreKey: RestoreKey, options?: any) {
        return OrderApiFp(this.configuration).restoreOrder(id, restoreKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific order based on the order ID
     * @summary Get a specific order
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public showOrder(id: string, options?: any) {
        return OrderApiFp(this.configuration).showOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an order item associated with an order.
     * @summary Gets an individual order item from a given order
     * @param {string} orderId The Order ID
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public showOrderItemFromOrder(orderId: string, id: string, options?: any) {
        return OrderApiFp(this.configuration).showOrderItemFromOrder(orderId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an updated order.
     * @summary Submit a given order
     * @param {string} orderId The Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public submitOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).submitOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrderItemApi - axios parameter creator
 * @export
 */
export const OrderItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the order item  based on order item ID passed
         * @summary Delete an existing OrderItem
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrderItem: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyOrderItem.');
            }
            const localVarPath = `/order_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApprovalRequests: async (orderItemId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderItemId' is not null or undefined
            if (orderItemId === null || orderItemId === undefined) {
                throw new RequiredError('orderItemId','Required parameter orderItemId was null or undefined when calling listApprovalRequests.');
            }
            const localVarPath = `/order_items/{order_item_id}/approval_requests`
                .replace(`{${"order_item_id"}}`, encodeURIComponent(String(orderItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItemProgressMessages: async (orderItemId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderItemId' is not null or undefined
            if (orderItemId === null || orderItemId === undefined) {
                throw new RequiredError('orderItemId','Required parameter orderItemId was null or undefined when calling listOrderItemProgressMessages.');
            }
            const localVarPath = `/order_items/{order_item_id}/progress_messages`
                .replace(`{${"order_item_id"}}`, encodeURIComponent(String(orderItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems: async (limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/order_items`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores the order item specified by the order item ID.
         * @summary Restore specific Order item
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrderItem: async (id: string, restoreKey: RestoreKey, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restoreOrderItem.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling restoreOrderItem.');
            }
            const localVarPath = `/order_items/{id}/restore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof restoreKey !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey !== undefined ? restoreKey : {}) : (restoreKey || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific order item based on the order item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrderItem.');
            }
            const localVarPath = `/order_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderItemApi - functional programming interface
 * @export
 */
export const OrderItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes the order item  based on order item ID passed
         * @summary Delete an existing OrderItem
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyOrderItem(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey>> {
            const localVarAxiosArgs = await OrderItemApiAxiosParamCreator(configuration).destroyOrderItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalRequestsCollection>> {
            const localVarAxiosArgs = await OrderItemApiAxiosParamCreator(configuration).listApprovalRequests(orderItemId, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrderItemProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgressMessagesCollection>> {
            const localVarAxiosArgs = await OrderItemApiAxiosParamCreator(configuration).listOrderItemProgressMessages(orderItemId, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrderItems(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemsCollection>> {
            const localVarAxiosArgs = await OrderItemApiAxiosParamCreator(configuration).listOrderItems(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Restores the order item specified by the order item ID.
         * @summary Restore specific Order item
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreOrderItem(id: string, restoreKey: RestoreKey, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem>> {
            const localVarAxiosArgs = await OrderItemApiAxiosParamCreator(configuration).restoreOrderItem(id, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a specific order item based on the order item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showOrderItem(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItem>> {
            const localVarAxiosArgs = await OrderItemApiAxiosParamCreator(configuration).showOrderItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrderItemApi - factory interface
 * @export
 */
export const OrderItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes the order item  based on order item ID passed
         * @summary Delete an existing OrderItem
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrderItem(id: string, options?: any): AxiosPromise<RestoreKey> {
            return OrderItemApiFp(configuration).destroyOrderItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
         * @summary Gets a list of approval requests for an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<ApprovalRequestsCollection> {
            return OrderItemApiFp(configuration).listApprovalRequests(orderItemId, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
         * @summary Gets a list of progress messages in an item
         * @param {string} orderItemId The Order Item ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItemProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<ProgressMessagesCollection> {
            return OrderItemApiFp(configuration).listOrderItemProgressMessages(orderItemId, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of order items.
         * @summary List Order Items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderItems(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<OrderItemsCollection> {
            return OrderItemApiFp(configuration).listOrderItems(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores the order item specified by the order item ID.
         * @summary Restore specific Order item
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreOrderItem(id: string, restoreKey: RestoreKey, options?: any): AxiosPromise<OrderItem> {
            return OrderItemApiFp(configuration).restoreOrderItem(id, restoreKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific order item based on the order item ID passed
         * @summary Gets a specific order item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderItem(id: string, options?: any): AxiosPromise<OrderItem> {
            return OrderItemApiFp(configuration).showOrderItem(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderItemApi - object-oriented interface
 * @export
 * @class OrderItemApi
 * @extends {BaseAPI}
 */
export class OrderItemApi extends BaseAPI {
    /**
     * Deletes the order item  based on order item ID passed
     * @summary Delete an existing OrderItem
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public destroyOrderItem(id: string, options?: any) {
        return OrderItemApiFp(this.configuration).destroyOrderItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of approval request associated with an order item. As the item is being approved one can check the status of the approvals.
     * @summary Gets a list of approval requests for an item
     * @param {string} orderItemId The Order Item ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listApprovalRequests(orderItemId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return OrderItemApiFp(this.configuration).listApprovalRequests(orderItemId, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of progress messages associated with an order item. As the item is being processed the provider can update the progress messages.
     * @summary Gets a list of progress messages in an item
     * @param {string} orderItemId The Order Item ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listOrderItemProgressMessages(orderItemId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return OrderItemApiFp(this.configuration).listOrderItemProgressMessages(orderItemId, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of order items.
     * @summary List Order Items
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public listOrderItems(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return OrderItemApiFp(this.configuration).listOrderItems(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores the order item specified by the order item ID.
     * @summary Restore specific Order item
     * @param {string} id ID of the resource
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public restoreOrderItem(id: string, restoreKey: RestoreKey, options?: any) {
        return OrderItemApiFp(this.configuration).restoreOrderItem(id, restoreKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific order item based on the order item ID passed
     * @summary Gets a specific order item
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderItemApi
     */
    public showOrderItem(id: string, options?: any) {
        return OrderItemApiFp(this.configuration).showOrderItem(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrderProcessApi - axios parameter creator
 * @export
 */
export const OrderProcessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Defines the product that will be executed after ordering when using this Order Process
         * @summary Adds an \'after\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderProcessAfterItem: async (id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addOrderProcessAfterItem.');
            }
            // verify required parameter 'orderProcessPortfolioItemId' is not null or undefined
            if (orderProcessPortfolioItemId === null || orderProcessPortfolioItemId === undefined) {
                throw new RequiredError('orderProcessPortfolioItemId','Required parameter orderProcessPortfolioItemId was null or undefined when calling addOrderProcessAfterItem.');
            }
            const localVarPath = `/order_processes/{id}/after_portfolio_item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderProcessPortfolioItemId !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderProcessPortfolioItemId !== undefined ? orderProcessPortfolioItemId : {}) : (orderProcessPortfolioItemId || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Defines the product that will be executed before ordering when using this Order Process
         * @summary Adds a \'before\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderProcessBeforeItem: async (id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addOrderProcessBeforeItem.');
            }
            // verify required parameter 'orderProcessPortfolioItemId' is not null or undefined
            if (orderProcessPortfolioItemId === null || orderProcessPortfolioItemId === undefined) {
                throw new RequiredError('orderProcessPortfolioItemId','Required parameter orderProcessPortfolioItemId was null or undefined when calling addOrderProcessBeforeItem.');
            }
            const localVarPath = `/order_processes/{id}/before_portfolio_item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderProcessPortfolioItemId !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderProcessPortfolioItemId !== undefined ? orderProcessPortfolioItemId : {}) : (orderProcessPortfolioItemId || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Defines the product that will be executed on return when using this Order Process
         * @summary Adds \'return\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderProcessReturnItem: async (id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addOrderProcessReturnItem.');
            }
            // verify required parameter 'orderProcessPortfolioItemId' is not null or undefined
            if (orderProcessPortfolioItemId === null || orderProcessPortfolioItemId === undefined) {
                throw new RequiredError('orderProcessPortfolioItemId','Required parameter orderProcessPortfolioItemId was null or undefined when calling addOrderProcessReturnItem.');
            }
            const localVarPath = `/order_processes/{id}/return_portfolio_item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderProcessPortfolioItemId !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderProcessPortfolioItemId !== undefined ? orderProcessPortfolioItemId : {}) : (orderProcessPortfolioItemId || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an order process.
         * @summary Add a new order process
         * @param {OrderProcess} orderProcess Parameters needed to add an OrderProcess
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderProcess: async (orderProcess: OrderProcess, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderProcess' is not null or undefined
            if (orderProcess === null || orderProcess === undefined) {
                throw new RequiredError('orderProcess','Required parameter orderProcess was null or undefined when calling createOrderProcess.');
            }
            const localVarPath = `/order_processes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderProcess !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderProcess !== undefined ? orderProcess : {}) : (orderProcess || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the order process specified by the ID.
         * @summary Delete an existing order process
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrderProcess: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyOrderProcess.');
            }
            const localVarPath = `/order_processes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Links a tag to an order process
         * @summary Links a tag to an order process
         * @param {string} id ID of the resource
         * @param {ResourceObject} resourceObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkTagToOrderProcess: async (id: string, resourceObject: ResourceObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling linkTagToOrderProcess.');
            }
            // verify required parameter 'resourceObject' is not null or undefined
            if (resourceObject === null || resourceObject === undefined) {
                throw new RequiredError('resourceObject','Required parameter resourceObject was null or undefined when calling linkTagToOrderProcess.');
            }
            const localVarPath = `/order_processes/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resourceObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resourceObject !== undefined ? resourceObject : {}) : (resourceObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of order processes. Optionally select order processes linked to a resource object whose app_name, object_type and object_id are specified by query parameters.
         * @summary List OrderProcesses
         * @param {string} [appName] Name of the application.
         * @param {string} [objectId] Id of the resource object.
         * @param {string} [objectType] Type of the resource object.
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderProcesses: async (appName?: string, objectId?: string, objectType?: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/order_processes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (appName !== undefined) {
                localVarQueryParameter['app_name'] = appName;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the association to the product(s) defined in the \'before\' and/or \'after\' that would be executed when using this Order Process
         * @summary Removes the \'before\' and/or \'after\' product(s) for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessAssociationsToRemove} orderProcessAssociationsToRemove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrderProcessAssociation: async (id: string, orderProcessAssociationsToRemove: OrderProcessAssociationsToRemove, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeOrderProcessAssociation.');
            }
            // verify required parameter 'orderProcessAssociationsToRemove' is not null or undefined
            if (orderProcessAssociationsToRemove === null || orderProcessAssociationsToRemove === undefined) {
                throw new RequiredError('orderProcessAssociationsToRemove','Required parameter orderProcessAssociationsToRemove was null or undefined when calling removeOrderProcessAssociation.');
            }
            const localVarPath = `/order_processes/{id}/remove_association`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderProcessAssociationsToRemove !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderProcessAssociationsToRemove !== undefined ? orderProcessAssociationsToRemove : {}) : (orderProcessAssociationsToRemove || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adjust the position of an order process related to others by an offset number
         * @summary Adjust the position of an order process
         * @param {string} id ID of the resource
         * @param {Reposition} reposition How many levels should the sequence be brought up or down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reposition: async (id: string, reposition: Reposition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling reposition.');
            }
            // verify required parameter 'reposition' is not null or undefined
            if (reposition === null || reposition === undefined) {
                throw new RequiredError('reposition','Required parameter reposition was null or undefined when calling reposition.');
            }
            const localVarPath = `/order_processes/{id}/reposition`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof reposition !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(reposition !== undefined ? reposition : {}) : (reposition || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the order process specified by the order process ID.
         * @summary Get a specific order process
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderProcess: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrderProcess.');
            }
            const localVarPath = `/order_processes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlinks a tag from an order process
         * @summary Unlinks a tag from an order process
         * @param {string} id ID of the resource
         * @param {ResourceObject} resourceObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkTagFromOrderProcess: async (id: string, resourceObject: ResourceObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlinkTagFromOrderProcess.');
            }
            // verify required parameter 'resourceObject' is not null or undefined
            if (resourceObject === null || resourceObject === undefined) {
                throw new RequiredError('resourceObject','Required parameter resourceObject was null or undefined when calling unlinkTagFromOrderProcess.');
            }
            const localVarPath = `/order_processes/{id}/unlink`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resourceObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resourceObject !== undefined ? resourceObject : {}) : (resourceObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the edited order process.
         * @summary Edit an existing order process
         * @param {string} id ID of the resource
         * @param {OrderProcess} orderProcess Parameters needed to update a OrderProcess
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderProcess: async (id: string, orderProcess: OrderProcess, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateOrderProcess.');
            }
            // verify required parameter 'orderProcess' is not null or undefined
            if (orderProcess === null || orderProcess === undefined) {
                throw new RequiredError('orderProcess','Required parameter orderProcess was null or undefined when calling updateOrderProcess.');
            }
            const localVarPath = `/order_processes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderProcess !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderProcess !== undefined ? orderProcess : {}) : (orderProcess || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderProcessApi - functional programming interface
 * @export
 */
export const OrderProcessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Defines the product that will be executed after ordering when using this Order Process
         * @summary Adds an \'after\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrderProcessAfterItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderProcess>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).addOrderProcessAfterItem(id, orderProcessPortfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Defines the product that will be executed before ordering when using this Order Process
         * @summary Adds a \'before\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrderProcessBeforeItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderProcess>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).addOrderProcessBeforeItem(id, orderProcessPortfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Defines the product that will be executed on return when using this Order Process
         * @summary Adds \'return\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrderProcessReturnItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderProcess>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).addOrderProcessReturnItem(id, orderProcessPortfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds an order process.
         * @summary Add a new order process
         * @param {OrderProcess} orderProcess Parameters needed to add an OrderProcess
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderProcess(orderProcess: OrderProcess, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderProcess>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).createOrderProcess(orderProcess, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the order process specified by the ID.
         * @summary Delete an existing order process
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyOrderProcess(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).destroyOrderProcess(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Links a tag to an order process
         * @summary Links a tag to an order process
         * @param {string} id ID of the resource
         * @param {ResourceObject} resourceObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkTagToOrderProcess(id: string, resourceObject: ResourceObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).linkTagToOrderProcess(id, resourceObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of order processes. Optionally select order processes linked to a resource object whose app_name, object_type and object_id are specified by query parameters.
         * @summary List OrderProcesses
         * @param {string} [appName] Name of the application.
         * @param {string} [objectId] Id of the resource object.
         * @param {string} [objectType] Type of the resource object.
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrderProcesses(appName?: string, objectId?: string, objectType?: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderProcessCollection>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).listOrderProcesses(appName, objectId, objectType, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the association to the product(s) defined in the \'before\' and/or \'after\' that would be executed when using this Order Process
         * @summary Removes the \'before\' and/or \'after\' product(s) for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessAssociationsToRemove} orderProcessAssociationsToRemove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrderProcessAssociation(id: string, orderProcessAssociationsToRemove: OrderProcessAssociationsToRemove, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderProcess>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).removeOrderProcessAssociation(id, orderProcessAssociationsToRemove, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adjust the position of an order process related to others by an offset number
         * @summary Adjust the position of an order process
         * @param {string} id ID of the resource
         * @param {Reposition} reposition How many levels should the sequence be brought up or down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reposition(id: string, reposition: Reposition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).reposition(id, reposition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the order process specified by the order process ID.
         * @summary Get a specific order process
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showOrderProcess(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderProcess>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).showOrderProcess(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unlinks a tag from an order process
         * @summary Unlinks a tag from an order process
         * @param {string} id ID of the resource
         * @param {ResourceObject} resourceObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkTagFromOrderProcess(id: string, resourceObject: ResourceObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).unlinkTagFromOrderProcess(id, resourceObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the edited order process.
         * @summary Edit an existing order process
         * @param {string} id ID of the resource
         * @param {OrderProcess} orderProcess Parameters needed to update a OrderProcess
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrderProcess(id: string, orderProcess: OrderProcess, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderProcess>> {
            const localVarAxiosArgs = await OrderProcessApiAxiosParamCreator(configuration).updateOrderProcess(id, orderProcess, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrderProcessApi - factory interface
 * @export
 */
export const OrderProcessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Defines the product that will be executed after ordering when using this Order Process
         * @summary Adds an \'after\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderProcessAfterItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any): AxiosPromise<OrderProcess> {
            return OrderProcessApiFp(configuration).addOrderProcessAfterItem(id, orderProcessPortfolioItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Defines the product that will be executed before ordering when using this Order Process
         * @summary Adds a \'before\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderProcessBeforeItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any): AxiosPromise<OrderProcess> {
            return OrderProcessApiFp(configuration).addOrderProcessBeforeItem(id, orderProcessPortfolioItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Defines the product that will be executed on return when using this Order Process
         * @summary Adds \'return\' product for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderProcessReturnItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any): AxiosPromise<OrderProcess> {
            return OrderProcessApiFp(configuration).addOrderProcessReturnItem(id, orderProcessPortfolioItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an order process.
         * @summary Add a new order process
         * @param {OrderProcess} orderProcess Parameters needed to add an OrderProcess
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderProcess(orderProcess: OrderProcess, options?: any): AxiosPromise<OrderProcess> {
            return OrderProcessApiFp(configuration).createOrderProcess(orderProcess, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the order process specified by the ID.
         * @summary Delete an existing order process
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyOrderProcess(id: string, options?: any): AxiosPromise<void> {
            return OrderProcessApiFp(configuration).destroyOrderProcess(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Links a tag to an order process
         * @summary Links a tag to an order process
         * @param {string} id ID of the resource
         * @param {ResourceObject} resourceObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkTagToOrderProcess(id: string, resourceObject: ResourceObject, options?: any): AxiosPromise<void> {
            return OrderProcessApiFp(configuration).linkTagToOrderProcess(id, resourceObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of order processes. Optionally select order processes linked to a resource object whose app_name, object_type and object_id are specified by query parameters.
         * @summary List OrderProcesses
         * @param {string} [appName] Name of the application.
         * @param {string} [objectId] Id of the resource object.
         * @param {string} [objectType] Type of the resource object.
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrderProcesses(appName?: string, objectId?: string, objectType?: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<OrderProcessCollection> {
            return OrderProcessApiFp(configuration).listOrderProcesses(appName, objectId, objectType, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the association to the product(s) defined in the \'before\' and/or \'after\' that would be executed when using this Order Process
         * @summary Removes the \'before\' and/or \'after\' product(s) for an Order Process
         * @param {string} id ID of the resource
         * @param {OrderProcessAssociationsToRemove} orderProcessAssociationsToRemove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrderProcessAssociation(id: string, orderProcessAssociationsToRemove: OrderProcessAssociationsToRemove, options?: any): AxiosPromise<OrderProcess> {
            return OrderProcessApiFp(configuration).removeOrderProcessAssociation(id, orderProcessAssociationsToRemove, options).then((request) => request(axios, basePath));
        },
        /**
         * Adjust the position of an order process related to others by an offset number
         * @summary Adjust the position of an order process
         * @param {string} id ID of the resource
         * @param {Reposition} reposition How many levels should the sequence be brought up or down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reposition(id: string, reposition: Reposition, options?: any): AxiosPromise<void> {
            return OrderProcessApiFp(configuration).reposition(id, reposition, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the order process specified by the order process ID.
         * @summary Get a specific order process
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrderProcess(id: string, options?: any): AxiosPromise<OrderProcess> {
            return OrderProcessApiFp(configuration).showOrderProcess(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlinks a tag from an order process
         * @summary Unlinks a tag from an order process
         * @param {string} id ID of the resource
         * @param {ResourceObject} resourceObject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkTagFromOrderProcess(id: string, resourceObject: ResourceObject, options?: any): AxiosPromise<void> {
            return OrderProcessApiFp(configuration).unlinkTagFromOrderProcess(id, resourceObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the edited order process.
         * @summary Edit an existing order process
         * @param {string} id ID of the resource
         * @param {OrderProcess} orderProcess Parameters needed to update a OrderProcess
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderProcess(id: string, orderProcess: OrderProcess, options?: any): AxiosPromise<OrderProcess> {
            return OrderProcessApiFp(configuration).updateOrderProcess(id, orderProcess, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderProcessApi - object-oriented interface
 * @export
 * @class OrderProcessApi
 * @extends {BaseAPI}
 */
export class OrderProcessApi extends BaseAPI {
    /**
     * Defines the product that will be executed after ordering when using this Order Process
     * @summary Adds an \'after\' product for an Order Process
     * @param {string} id ID of the resource
     * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public addOrderProcessAfterItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any) {
        return OrderProcessApiFp(this.configuration).addOrderProcessAfterItem(id, orderProcessPortfolioItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Defines the product that will be executed before ordering when using this Order Process
     * @summary Adds a \'before\' product for an Order Process
     * @param {string} id ID of the resource
     * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public addOrderProcessBeforeItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any) {
        return OrderProcessApiFp(this.configuration).addOrderProcessBeforeItem(id, orderProcessPortfolioItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Defines the product that will be executed on return when using this Order Process
     * @summary Adds \'return\' product for an Order Process
     * @param {string} id ID of the resource
     * @param {OrderProcessPortfolioItemId} orderProcessPortfolioItemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public addOrderProcessReturnItem(id: string, orderProcessPortfolioItemId: OrderProcessPortfolioItemId, options?: any) {
        return OrderProcessApiFp(this.configuration).addOrderProcessReturnItem(id, orderProcessPortfolioItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an order process.
     * @summary Add a new order process
     * @param {OrderProcess} orderProcess Parameters needed to add an OrderProcess
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public createOrderProcess(orderProcess: OrderProcess, options?: any) {
        return OrderProcessApiFp(this.configuration).createOrderProcess(orderProcess, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the order process specified by the ID.
     * @summary Delete an existing order process
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public destroyOrderProcess(id: string, options?: any) {
        return OrderProcessApiFp(this.configuration).destroyOrderProcess(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Links a tag to an order process
     * @summary Links a tag to an order process
     * @param {string} id ID of the resource
     * @param {ResourceObject} resourceObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public linkTagToOrderProcess(id: string, resourceObject: ResourceObject, options?: any) {
        return OrderProcessApiFp(this.configuration).linkTagToOrderProcess(id, resourceObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of order processes. Optionally select order processes linked to a resource object whose app_name, object_type and object_id are specified by query parameters.
     * @summary List OrderProcesses
     * @param {string} [appName] Name of the application.
     * @param {string} [objectId] Id of the resource object.
     * @param {string} [objectType] Type of the resource object.
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public listOrderProcesses(appName?: string, objectId?: string, objectType?: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return OrderProcessApiFp(this.configuration).listOrderProcesses(appName, objectId, objectType, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the association to the product(s) defined in the \'before\' and/or \'after\' that would be executed when using this Order Process
     * @summary Removes the \'before\' and/or \'after\' product(s) for an Order Process
     * @param {string} id ID of the resource
     * @param {OrderProcessAssociationsToRemove} orderProcessAssociationsToRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public removeOrderProcessAssociation(id: string, orderProcessAssociationsToRemove: OrderProcessAssociationsToRemove, options?: any) {
        return OrderProcessApiFp(this.configuration).removeOrderProcessAssociation(id, orderProcessAssociationsToRemove, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adjust the position of an order process related to others by an offset number
     * @summary Adjust the position of an order process
     * @param {string} id ID of the resource
     * @param {Reposition} reposition How many levels should the sequence be brought up or down
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public reposition(id: string, reposition: Reposition, options?: any) {
        return OrderProcessApiFp(this.configuration).reposition(id, reposition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the order process specified by the order process ID.
     * @summary Get a specific order process
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public showOrderProcess(id: string, options?: any) {
        return OrderProcessApiFp(this.configuration).showOrderProcess(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlinks a tag from an order process
     * @summary Unlinks a tag from an order process
     * @param {string} id ID of the resource
     * @param {ResourceObject} resourceObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public unlinkTagFromOrderProcess(id: string, resourceObject: ResourceObject, options?: any) {
        return OrderProcessApiFp(this.configuration).unlinkTagFromOrderProcess(id, resourceObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the edited order process.
     * @summary Edit an existing order process
     * @param {string} id ID of the resource
     * @param {OrderProcess} orderProcess Parameters needed to update a OrderProcess
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderProcessApi
     */
    public updateOrderProcess(id: string, orderProcess: OrderProcess, options?: any) {
        return OrderProcessApiFp(this.configuration).updateOrderProcess(id, orderProcess, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PortfolioApi - axios parameter creator
 * @export
 */
export const PortfolioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioTag: async (id: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPortfolioTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling addPortfolioTag.');
            }
            const localVarPath = `/portfolios/{id}/tag`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio: async (portfolio: Portfolio, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolio' is not null or undefined
            if (portfolio === null || portfolio === undefined) {
                throw new RequiredError('portfolio','Required parameter portfolio was null or undefined when calling createPortfolio.');
            }
            const localVarPath = `/portfolios`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof portfolio !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolio !== undefined ? portfolio : {}) : (portfolio || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolio: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyPortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPortfolioItemsWithPortfolio: async (portfolioId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling fetchPortfolioItemsWithPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/portfolio_items`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listPortfolioTags.');
            }
            const localVarPath = `/portfolios/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolios: async (limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolios`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolio: async (portfolioId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling postCopyPortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/copy`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove Tags from Portfolio
         * @summary Remove Tags from Portfolio
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePortfolioTags: async (id: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removePortfolioTags.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling removePortfolioTags.');
            }
            const localVarPath = `/portfolios/{id}/untag`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareInfo: async (portfolioId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling shareInfo.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/share_info`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePortfolio: async (portfolioId: string, sharePolicy: SharePolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling sharePortfolio.');
            }
            // verify required parameter 'sharePolicy' is not null or undefined
            if (sharePolicy === null || sharePolicy === undefined) {
                throw new RequiredError('sharePolicy','Required parameter sharePolicy was null or undefined when calling sharePortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/share`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof sharePolicy !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sharePolicy !== undefined ? sharePolicy : {}) : (sharePolicy || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolio: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showPortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the specified portfolio\'s icon image.
         * @summary Fetches the specified portfolio\'s icon image
         * @param {string} portfolioId The Portfolio ID
         * @param {string} [cacheId] Artificial string to help avoid falsey browser cache. This can occur after changing static resources like images. The browser will return an outdated cached response. Appending different query will result in a new async call, instead of retrieving the resource from the browser cache.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioIcon: async (portfolioId: string, cacheId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling showPortfolioIcon.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/icon`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (cacheId !== undefined) {
                localVarQueryParameter['cache_id'] = cacheId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolio: async (id: string, restoreKey: RestoreKey, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unDeletePortfolio.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling unDeletePortfolio.');
            }
            const localVarPath = `/portfolios/{id}/undelete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof restoreKey !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey !== undefined ? restoreKey : {}) : (restoreKey || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsharePortfolio: async (portfolioId: string, unsharePolicy: UnsharePolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioId' is not null or undefined
            if (portfolioId === null || portfolioId === undefined) {
                throw new RequiredError('portfolioId','Required parameter portfolioId was null or undefined when calling unsharePortfolio.');
            }
            // verify required parameter 'unsharePolicy' is not null or undefined
            if (unsharePolicy === null || unsharePolicy === undefined) {
                throw new RequiredError('unsharePolicy','Required parameter unsharePolicy was null or undefined when calling unsharePortfolio.');
            }
            const localVarPath = `/portfolios/{portfolio_id}/unshare`
                .replace(`{${"portfolio_id"}}`, encodeURIComponent(String(portfolioId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof unsharePolicy !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(unsharePolicy !== undefined ? unsharePolicy : {}) : (unsharePolicy || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio: async (id: string, portfolio: Portfolio, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolio.');
            }
            // verify required parameter 'portfolio' is not null or undefined
            if (portfolio === null || portfolio === undefined) {
                throw new RequiredError('portfolio','Required parameter portfolio was null or undefined when calling updatePortfolio.');
            }
            const localVarPath = `/portfolios/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof portfolio !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolio !== undefined ? portfolio : {}) : (portfolio || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioApi - functional programming interface
 * @export
 */
export const PortfolioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPortfolioTag(id: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).addPortfolioTag(id, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPortfolio(portfolio: Portfolio, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).createPortfolio(portfolio, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyPortfolio(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).destroyPortfolio(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemsCollection>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPortfolioTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).listPortfolioTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPortfolios(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfoliosCollection>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).listPortfolios(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCopyPortfolio(portfolioId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).postCopyPortfolio(portfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove Tags from Portfolio
         * @summary Remove Tags from Portfolio
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePortfolioTags(id: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).removePortfolioTags(id, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareInfo(portfolioId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShareInfo>>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).shareInfo(portfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).sharePortfolio(portfolioId, sharePolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showPortfolio(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).showPortfolio(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the specified portfolio\'s icon image.
         * @summary Fetches the specified portfolio\'s icon image
         * @param {string} portfolioId The Portfolio ID
         * @param {string} [cacheId] Artificial string to help avoid falsey browser cache. This can occur after changing static resources like images. The browser will return an outdated cached response. Appending different query will result in a new async call, instead of retrieving the resource from the browser cache.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showPortfolioIcon(portfolioId: string, cacheId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).showPortfolioIcon(portfolioId, cacheId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).unDeletePortfolio(id, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).unsharePortfolio(portfolioId, unsharePolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePortfolio(id: string, portfolio: Portfolio, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Portfolio>> {
            const localVarAxiosArgs = await PortfolioApiAxiosParamCreator(configuration).updatePortfolio(id, portfolio, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PortfolioApi - factory interface
 * @export
 */
export const PortfolioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a single tag to Portfolio object
         * @summary Add Tag for Portfolio
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioTag(id: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return PortfolioApiFp(configuration).addPortfolioTag(id, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a portfolio.
         * @summary Add a new portfolio
         * @param {Portfolio} portfolio Parameters needed to add a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolio(portfolio: Portfolio, options?: any): AxiosPromise<Portfolio> {
            return PortfolioApiFp(configuration).createPortfolio(portfolio, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the portfolio specified by the ID.
         * @summary Delete an existing portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolio(id: string, options?: any): AxiosPromise<RestoreKey> {
            return PortfolioApiFp(configuration).destroyPortfolio(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all portfilio items in the portfolio specified by the given ID.
         * @summary Get all portfolio items from a specific portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<PortfolioItemsCollection> {
            return PortfolioApiFp(configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<TagsCollection> {
            return PortfolioApiFp(configuration).listPortfolioTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of portfolios.
         * @summary List portfolios
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolios(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<PortfoliosCollection> {
            return PortfolioApiFp(configuration).listPortfolios(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Make a copy of the Portfolio.
         * @summary Make a copy of the Portfolio
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolio(portfolioId: string, options?: any): AxiosPromise<Portfolio> {
            return PortfolioApiFp(configuration).postCopyPortfolio(portfolioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove Tags from Portfolio
         * @summary Remove Tags from Portfolio
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePortfolioTags(id: string, tag: Array<Tag>, options?: any): AxiosPromise<void> {
            return PortfolioApiFp(configuration).removePortfolioTags(id, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch share information about a portfolio
         * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
         * @param {string} portfolioId The Portfolio ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareInfo(portfolioId: string, options?: any): AxiosPromise<Array<ShareInfo>> {
            return PortfolioApiFp(configuration).shareInfo(portfolioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a Portfolio with one or more groups with specific permissions
         * @summary Share a portfolio with one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {SharePolicy} sharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any): AxiosPromise<void> {
            return PortfolioApiFp(configuration).sharePortfolio(portfolioId, sharePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the portfolio specified by the portfolio ID.
         * @summary Get a specific portfolio
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolio(id: string, options?: any): AxiosPromise<Portfolio> {
            return PortfolioApiFp(configuration).showPortfolio(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the specified portfolio\'s icon image.
         * @summary Fetches the specified portfolio\'s icon image
         * @param {string} portfolioId The Portfolio ID
         * @param {string} [cacheId] Artificial string to help avoid falsey browser cache. This can occur after changing static resources like images. The browser will return an outdated cached response. Appending different query will result in a new async call, instead of retrieving the resource from the browser cache.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioIcon(portfolioId: string, cacheId?: string, options?: any): AxiosPromise<any> {
            return PortfolioApiFp(configuration).showPortfolioIcon(portfolioId, cacheId, options).then((request) => request(axios, basePath));
        },
        /**
         * Undeletes the portfolio specified by the portfolio ID.
         * @summary Undelete specific portfolio
         * @param {string} id ID of the resource
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any): AxiosPromise<Portfolio> {
            return PortfolioApiFp(configuration).unDeletePortfolio(id, restoreKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Unshare a Portfolio with one or more groups with specific permissions
         * @summary Unshare a portfolio from one or more groups with specific permission
         * @param {string} portfolioId The Portfolio ID
         * @param {UnsharePolicy} unsharePolicy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any): AxiosPromise<void> {
            return PortfolioApiFp(configuration).unsharePortfolio(portfolioId, unsharePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the edited portfolio.
         * @summary Edit an existing portfolio
         * @param {string} id ID of the resource
         * @param {Portfolio} portfolio Parameters needed to update a Portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolio(id: string, portfolio: Portfolio, options?: any): AxiosPromise<Portfolio> {
            return PortfolioApiFp(configuration).updatePortfolio(id, portfolio, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
    /**
     * Adds a single tag to Portfolio object
     * @summary Add Tag for Portfolio
     * @param {string} id ID of the resource
     * @param {Array<Tag>} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public addPortfolioTag(id: string, tag: Array<Tag>, options?: any) {
        return PortfolioApiFp(this.configuration).addPortfolioTag(id, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a portfolio.
     * @summary Add a new portfolio
     * @param {Portfolio} portfolio Parameters needed to add a Portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public createPortfolio(portfolio: Portfolio, options?: any) {
        return PortfolioApiFp(this.configuration).createPortfolio(portfolio, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the portfolio specified by the ID.
     * @summary Delete an existing portfolio
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public destroyPortfolio(id: string, options?: any) {
        return PortfolioApiFp(this.configuration).destroyPortfolio(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all portfilio items in the portfolio specified by the given ID.
     * @summary Get all portfolio items from a specific portfolio
     * @param {string} portfolioId The Portfolio ID
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public fetchPortfolioItemsWithPortfolio(portfolioId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return PortfolioApiFp(this.configuration).fetchPortfolioItemsWithPortfolio(portfolioId, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for Portfolio
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public listPortfolioTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return PortfolioApiFp(this.configuration).listPortfolioTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of portfolios.
     * @summary List portfolios
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public listPortfolios(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return PortfolioApiFp(this.configuration).listPortfolios(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make a copy of the Portfolio.
     * @summary Make a copy of the Portfolio
     * @param {string} portfolioId The Portfolio ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public postCopyPortfolio(portfolioId: string, options?: any) {
        return PortfolioApiFp(this.configuration).postCopyPortfolio(portfolioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove Tags from Portfolio
     * @summary Remove Tags from Portfolio
     * @param {string} id ID of the resource
     * @param {Array<Tag>} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public removePortfolioTags(id: string, tag: Array<Tag>, options?: any) {
        return PortfolioApiFp(this.configuration).removePortfolioTags(id, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch share information about a portfolio
     * @summary Fetch share information about this portfolio, the response would include a collection of groups and permissions with each group
     * @param {string} portfolioId The Portfolio ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public shareInfo(portfolioId: string, options?: any) {
        return PortfolioApiFp(this.configuration).shareInfo(portfolioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Share a Portfolio with one or more groups with specific permissions
     * @summary Share a portfolio with one or more groups with specific permission
     * @param {string} portfolioId The Portfolio ID
     * @param {SharePolicy} sharePolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public sharePortfolio(portfolioId: string, sharePolicy: SharePolicy, options?: any) {
        return PortfolioApiFp(this.configuration).sharePortfolio(portfolioId, sharePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the portfolio specified by the portfolio ID.
     * @summary Get a specific portfolio
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public showPortfolio(id: string, options?: any) {
        return PortfolioApiFp(this.configuration).showPortfolio(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the specified portfolio\'s icon image.
     * @summary Fetches the specified portfolio\'s icon image
     * @param {string} portfolioId The Portfolio ID
     * @param {string} [cacheId] Artificial string to help avoid falsey browser cache. This can occur after changing static resources like images. The browser will return an outdated cached response. Appending different query will result in a new async call, instead of retrieving the resource from the browser cache.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public showPortfolioIcon(portfolioId: string, cacheId?: string, options?: any) {
        return PortfolioApiFp(this.configuration).showPortfolioIcon(portfolioId, cacheId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Undeletes the portfolio specified by the portfolio ID.
     * @summary Undelete specific portfolio
     * @param {string} id ID of the resource
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public unDeletePortfolio(id: string, restoreKey: RestoreKey, options?: any) {
        return PortfolioApiFp(this.configuration).unDeletePortfolio(id, restoreKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unshare a Portfolio with one or more groups with specific permissions
     * @summary Unshare a portfolio from one or more groups with specific permission
     * @param {string} portfolioId The Portfolio ID
     * @param {UnsharePolicy} unsharePolicy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public unsharePortfolio(portfolioId: string, unsharePolicy: UnsharePolicy, options?: any) {
        return PortfolioApiFp(this.configuration).unsharePortfolio(portfolioId, unsharePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the edited portfolio.
     * @summary Edit an existing portfolio
     * @param {string} id ID of the resource
     * @param {Portfolio} portfolio Parameters needed to update a Portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public updatePortfolio(id: string, portfolio: Portfolio, options?: any) {
        return PortfolioApiFp(this.configuration).updatePortfolio(id, portfolio, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PortfolioItemApi - axios parameter creator
 * @export
 */
export const PortfolioItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a single tag to a Portfolio Item object
         * @summary Add Tag for Portfolio Item
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemTag: async (id: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPortfolioItemTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling addPortfolioItemTag.');
            }
            const localVarPath = `/portfolio_items/{id}/tag`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioItem: async (createPortfolioItem: CreatePortfolioItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPortfolioItem' is not null or undefined
            if (createPortfolioItem === null || createPortfolioItem === undefined) {
                throw new RequiredError('createPortfolioItem','Required parameter createPortfolioItem was null or undefined when calling createPortfolioItem.');
            }
            const localVarPath = `/portfolio_items`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createPortfolioItem !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createPortfolioItem !== undefined ? createPortfolioItem : {}) : (createPortfolioItem || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolioItem: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the next name for a the Portfolio Item prior to a copy operation
         * @summary Get the next name for a the Portfolio Item prior to a copy operation
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {string} [destinationPortfolioId] The destination portfolio to compare names against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioItemNextName: async (portfolioItemId: string, destinationPortfolioId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling getPortfolioItemNextName.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/next_name`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (destinationPortfolioId !== undefined) {
                localVarQueryParameter['destination_portfolio_id'] = destinationPortfolioId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio Items
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItemTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listPortfolioItemTags.');
            }
            const localVarPath = `/portfolio_items/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItems: async (limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/portfolio_items`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the catalog inventory service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans: async (portfolioItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling listServicePlans.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/service_plans`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolioItem: async (portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling postCopyPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/copy`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof copyPortfolioItem !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(copyPortfolioItem !== undefined ? copyPortfolioItem : {}) : (copyPortfolioItem || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove Tags from Portfolio Item
         * @summary Remove Tags from Portfolio Item
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePortfolioItemTags: async (id: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removePortfolioItemTags.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling removePortfolioItemTags.');
            }
            const localVarPath = `/portfolio_items/{id}/untag`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {boolean} [showDiscarded] Whether or not to display the discarded result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItem: async (id: string, showDiscarded?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showPortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (showDiscarded !== undefined) {
                localVarQueryParameter['show_discarded'] = showDiscarded;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the specified portfolio item\'s icon image.
         * @summary Fetches the specified portfolio item\'s icon image
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItemIcon: async (portfolioItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling showPortfolioItemIcon.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/icon`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolioItem: async (portfolioItemId: string, restoreKey: RestoreKey, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioItemId' is not null or undefined
            if (portfolioItemId === null || portfolioItemId === undefined) {
                throw new RequiredError('portfolioItemId','Required parameter portfolioItemId was null or undefined when calling unDeletePortfolioItem.');
            }
            // verify required parameter 'restoreKey' is not null or undefined
            if (restoreKey === null || restoreKey === undefined) {
                throw new RequiredError('restoreKey','Required parameter restoreKey was null or undefined when calling unDeletePortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{portfolio_item_id}/undelete`
                .replace(`{${"portfolio_item_id"}}`, encodeURIComponent(String(portfolioItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof restoreKey !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(restoreKey !== undefined ? restoreKey : {}) : (restoreKey || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioItem: async (id: string, portfolioItem: PortfolioItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePortfolioItem.');
            }
            // verify required parameter 'portfolioItem' is not null or undefined
            if (portfolioItem === null || portfolioItem === undefined) {
                throw new RequiredError('portfolioItem','Required parameter portfolioItem was null or undefined when calling updatePortfolioItem.');
            }
            const localVarPath = `/portfolio_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof portfolioItem !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(portfolioItem !== undefined ? portfolioItem : {}) : (portfolioItem || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioItemApi - functional programming interface
 * @export
 */
export const PortfolioItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a single tag to a Portfolio Item object
         * @summary Add Tag for Portfolio Item
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPortfolioItemTag(id: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).addPortfolioItemTag(id, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).createPortfolioItem(createPortfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyPortfolioItem(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreKey>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).destroyPortfolioItem(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the next name for a the Portfolio Item prior to a copy operation
         * @summary Get the next name for a the Portfolio Item prior to a copy operation
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {string} [destinationPortfolioId] The destination portfolio to compare names against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioItemNextName(portfolioItemId: string, destinationPortfolioId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemNextName>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).getPortfolioItemNextName(portfolioItemId, destinationPortfolioId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio Items
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPortfolioItemTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).listPortfolioItemTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPortfolioItems(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItemsCollection>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).listPortfolioItems(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the catalog inventory service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServicePlans(portfolioItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServicePlan>>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).listServicePlans(portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove Tags from Portfolio Item
         * @summary Remove Tags from Portfolio Item
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePortfolioItemTags(id: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).removePortfolioItemTags(id, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {boolean} [showDiscarded] Whether or not to display the discarded result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showPortfolioItem(id: string, showDiscarded?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).showPortfolioItem(id, showDiscarded, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the specified portfolio item\'s icon image.
         * @summary Fetches the specified portfolio item\'s icon image
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showPortfolioItemIcon(portfolioItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).showPortfolioItemIcon(portfolioItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unDeletePortfolioItem(portfolioItemId: string, restoreKey: RestoreKey, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).unDeletePortfolioItem(portfolioItemId, restoreKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioItem>> {
            const localVarAxiosArgs = await PortfolioItemApiAxiosParamCreator(configuration).updatePortfolioItem(id, portfolioItem, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PortfolioItemApi - factory interface
 * @export
 */
export const PortfolioItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a single tag to a Portfolio Item object
         * @summary Add Tag for Portfolio Item
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioItemTag(id: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return PortfolioItemApiFp(configuration).addPortfolioItemTag(id, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a name and description for a portfolio item and returns the newly created portfolio item.
         * @summary Add a new portfolio item
         * @param {CreatePortfolioItem} createPortfolioItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any): AxiosPromise<PortfolioItem> {
            return PortfolioItemApiFp(configuration).createPortfolioItem(createPortfolioItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the portfolio item based on portfolio item ID passed
         * @summary Delete an existing portfolio item
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPortfolioItem(id: string, options?: any): AxiosPromise<RestoreKey> {
            return PortfolioItemApiFp(configuration).destroyPortfolioItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the next name for a the Portfolio Item prior to a copy operation
         * @summary Get the next name for a the Portfolio Item prior to a copy operation
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {string} [destinationPortfolioId] The destination portfolio to compare names against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioItemNextName(portfolioItemId: string, destinationPortfolioId?: string, options?: any): AxiosPromise<PortfolioItemNextName> {
            return PortfolioItemApiFp(configuration).getPortfolioItemNextName(portfolioItemId, destinationPortfolioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag objects
         * @summary List Tags for Portfolio Items
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItemTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<TagsCollection> {
            return PortfolioItemApiFp(configuration).listPortfolioItemTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of portfolio items.
         * @summary List all portfolio items
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string} [sortBy] Field to sort collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioItems(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<PortfolioItemsCollection> {
            return PortfolioItemApiFp(configuration).listPortfolioItems(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all service plans for a portfolio item.
         * @summary Gets all service plans for a specific portfolio item; requires a connection to the catalog inventory service.
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(portfolioItemId: string, options?: any): AxiosPromise<Array<ServicePlan>> {
            return PortfolioItemApiFp(configuration).listServicePlans(portfolioItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Make a copy of the Portfolio Item.
         * @summary Make a copy of the Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {CopyPortfolioItem} [copyPortfolioItem]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any): AxiosPromise<PortfolioItem> {
            return PortfolioItemApiFp(configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove Tags from Portfolio Item
         * @summary Remove Tags from Portfolio Item
         * @param {string} id ID of the resource
         * @param {Array<Tag>} tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePortfolioItemTags(id: string, tag: Array<Tag>, options?: any): AxiosPromise<void> {
            return PortfolioItemApiFp(configuration).removePortfolioItemTags(id, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific portfolio item based on the portfolio item ID passed
         * @summary Gets a specific portfolio item
         * @param {string} id ID of the resource
         * @param {boolean} [showDiscarded] Whether or not to display the discarded result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItem(id: string, showDiscarded?: boolean, options?: any): AxiosPromise<PortfolioItem> {
            return PortfolioItemApiFp(configuration).showPortfolioItem(id, showDiscarded, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the specified portfolio item\'s icon image.
         * @summary Fetches the specified portfolio item\'s icon image
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPortfolioItemIcon(portfolioItemId: string, options?: any): AxiosPromise<any> {
            return PortfolioItemApiFp(configuration).showPortfolioItemIcon(portfolioItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * If a record has been discarded, this operation will undelete it so it can be requested normally.
         * @summary Undelete a specified Portfolio Item
         * @param {string} portfolioItemId The Portfolio Item ID
         * @param {RestoreKey} restoreKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDeletePortfolioItem(portfolioItemId: string, restoreKey: RestoreKey, options?: any): AxiosPromise<PortfolioItem> {
            return PortfolioItemApiFp(configuration).unDeletePortfolioItem(portfolioItemId, restoreKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits portfolio item specified by the given ID.
         * @summary Edit an existing portfolio item
         * @param {string} id ID of the resource
         * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any): AxiosPromise<PortfolioItem> {
            return PortfolioItemApiFp(configuration).updatePortfolioItem(id, portfolioItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfolioItemApi - object-oriented interface
 * @export
 * @class PortfolioItemApi
 * @extends {BaseAPI}
 */
export class PortfolioItemApi extends BaseAPI {
    /**
     * Adds a single tag to a Portfolio Item object
     * @summary Add Tag for Portfolio Item
     * @param {string} id ID of the resource
     * @param {Array<Tag>} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public addPortfolioItemTag(id: string, tag: Array<Tag>, options?: any) {
        return PortfolioItemApiFp(this.configuration).addPortfolioItemTag(id, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a name and description for a portfolio item and returns the newly created portfolio item.
     * @summary Add a new portfolio item
     * @param {CreatePortfolioItem} createPortfolioItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public createPortfolioItem(createPortfolioItem: CreatePortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).createPortfolioItem(createPortfolioItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the portfolio item based on portfolio item ID passed
     * @summary Delete an existing portfolio item
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public destroyPortfolioItem(id: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).destroyPortfolioItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the next name for a the Portfolio Item prior to a copy operation
     * @summary Get the next name for a the Portfolio Item prior to a copy operation
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {string} [destinationPortfolioId] The destination portfolio to compare names against
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public getPortfolioItemNextName(portfolioItemId: string, destinationPortfolioId?: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).getPortfolioItemNextName(portfolioItemId, destinationPortfolioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag objects
     * @summary List Tags for Portfolio Items
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listPortfolioItemTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).listPortfolioItemTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of portfolio items.
     * @summary List all portfolio items
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string} [sortBy] Field to sort collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listPortfolioItems(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).listPortfolioItems(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all service plans for a portfolio item.
     * @summary Gets all service plans for a specific portfolio item; requires a connection to the catalog inventory service.
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public listServicePlans(portfolioItemId: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).listServicePlans(portfolioItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make a copy of the Portfolio Item.
     * @summary Make a copy of the Portfolio Item
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {CopyPortfolioItem} [copyPortfolioItem]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public postCopyPortfolioItem(portfolioItemId: string, copyPortfolioItem?: CopyPortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).postCopyPortfolioItem(portfolioItemId, copyPortfolioItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove Tags from Portfolio Item
     * @summary Remove Tags from Portfolio Item
     * @param {string} id ID of the resource
     * @param {Array<Tag>} tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public removePortfolioItemTags(id: string, tag: Array<Tag>, options?: any) {
        return PortfolioItemApiFp(this.configuration).removePortfolioItemTags(id, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific portfolio item based on the portfolio item ID passed
     * @summary Gets a specific portfolio item
     * @param {string} id ID of the resource
     * @param {boolean} [showDiscarded] Whether or not to display the discarded result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public showPortfolioItem(id: string, showDiscarded?: boolean, options?: any) {
        return PortfolioItemApiFp(this.configuration).showPortfolioItem(id, showDiscarded, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the specified portfolio item\'s icon image.
     * @summary Fetches the specified portfolio item\'s icon image
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public showPortfolioItemIcon(portfolioItemId: string, options?: any) {
        return PortfolioItemApiFp(this.configuration).showPortfolioItemIcon(portfolioItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If a record has been discarded, this operation will undelete it so it can be requested normally.
     * @summary Undelete a specified Portfolio Item
     * @param {string} portfolioItemId The Portfolio Item ID
     * @param {RestoreKey} restoreKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public unDeletePortfolioItem(portfolioItemId: string, restoreKey: RestoreKey, options?: any) {
        return PortfolioItemApiFp(this.configuration).unDeletePortfolioItem(portfolioItemId, restoreKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits portfolio item specified by the given ID.
     * @summary Edit an existing portfolio item
     * @param {string} id ID of the resource
     * @param {PortfolioItem} portfolioItem Parameters needed to update a Portfolio Item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioItemApi
     */
    public updatePortfolioItem(id: string, portfolioItem: PortfolioItem, options?: any) {
        return PortfolioItemApiFp(this.configuration).updatePortfolioItem(id, portfolioItem, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ServicePlansApi - axios parameter creator
 * @export
 */
export const ServicePlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the new Service Plan
         * @summary Create Service Plan
         * @param {ImportServicePlan} [importServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePlan: async (importServicePlan?: ImportServicePlan, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_plans`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof importServicePlan !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(importServicePlan !== undefined ? importServicePlan : {}) : (importServicePlan || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch Service Plan Modified Schema
         * @param {string} id ID of the resource
         * @param {PatchModifiedServicePlan} [patchModifiedServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchServicePlanModified: async (id: string, patchModifiedServicePlan?: PatchModifiedServicePlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchServicePlanModified.');
            }
            const localVarPath = `/service_plans/{id}/modified`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchModifiedServicePlan !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchModifiedServicePlan !== undefined ? patchModifiedServicePlan : {}) : (patchModifiedServicePlan || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the Service Plan\'s Modified schema and returns the new one if it has been reset
         * @summary Reset Service Plan Modified schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetServicePlanModified: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resetServicePlanModified.');
            }
            const localVarPath = `/service_plans/{id}/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified Service Plan
         * @summary Show Service Plan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServicePlan.');
            }
            const localVarPath = `/service_plans/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified Service Plan\'s base schema
         * @summary Show Service Plan Base Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanBase: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServicePlanBase.');
            }
            const localVarPath = `/service_plans/{id}/base`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified Service Plan\'s modified schema
         * @summary Show Service Plan modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanModified: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServicePlanModified.');
            }
            const localVarPath = `/service_plans/{id}/modified`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicePlansApi - functional programming interface
 * @export
 */
export const ServicePlansApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the new Service Plan
         * @summary Create Service Plan
         * @param {ImportServicePlan} [importServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServicePlan(importServicePlan?: ImportServicePlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServicePlan>>> {
            const localVarAxiosArgs = await ServicePlansApiAxiosParamCreator(configuration).createServicePlan(importServicePlan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Patch Service Plan Modified Schema
         * @param {string} id ID of the resource
         * @param {PatchModifiedServicePlan} [patchModifiedServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchServicePlanModified(id: string, patchModifiedServicePlan?: PatchModifiedServicePlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await ServicePlansApiAxiosParamCreator(configuration).patchServicePlanModified(id, patchModifiedServicePlan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Resets the Service Plan\'s Modified schema and returns the new one if it has been reset
         * @summary Reset Service Plan Modified schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetServicePlanModified(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServicePlan>>> {
            const localVarAxiosArgs = await ServicePlansApiAxiosParamCreator(configuration).resetServicePlanModified(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified Service Plan
         * @summary Show Service Plan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServicePlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlan>> {
            const localVarAxiosArgs = await ServicePlansApiAxiosParamCreator(configuration).showServicePlan(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified Service Plan\'s base schema
         * @summary Show Service Plan Base Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServicePlanBase(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlan>> {
            const localVarAxiosArgs = await ServicePlansApiAxiosParamCreator(configuration).showServicePlanBase(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified Service Plan\'s modified schema
         * @summary Show Service Plan modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServicePlanModified(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlan>> {
            const localVarAxiosArgs = await ServicePlansApiAxiosParamCreator(configuration).showServicePlanModified(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ServicePlansApi - factory interface
 * @export
 */
export const ServicePlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the new Service Plan
         * @summary Create Service Plan
         * @param {ImportServicePlan} [importServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePlan(importServicePlan?: ImportServicePlan, options?: any): AxiosPromise<Array<ServicePlan>> {
            return ServicePlansApiFp(configuration).createServicePlan(importServicePlan, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch Service Plan Modified Schema
         * @param {string} id ID of the resource
         * @param {PatchModifiedServicePlan} [patchModifiedServicePlan]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchServicePlanModified(id: string, patchModifiedServicePlan?: PatchModifiedServicePlan, options?: any): AxiosPromise<object> {
            return ServicePlansApiFp(configuration).patchServicePlanModified(id, patchModifiedServicePlan, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the Service Plan\'s Modified schema and returns the new one if it has been reset
         * @summary Reset Service Plan Modified schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetServicePlanModified(id: string, options?: any): AxiosPromise<Array<ServicePlan>> {
            return ServicePlansApiFp(configuration).resetServicePlanModified(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified Service Plan
         * @summary Show Service Plan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan(id: string, options?: any): AxiosPromise<ServicePlan> {
            return ServicePlansApiFp(configuration).showServicePlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified Service Plan\'s base schema
         * @summary Show Service Plan Base Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanBase(id: string, options?: any): AxiosPromise<ServicePlan> {
            return ServicePlansApiFp(configuration).showServicePlanBase(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified Service Plan\'s modified schema
         * @summary Show Service Plan modified Schema
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlanModified(id: string, options?: any): AxiosPromise<ServicePlan> {
            return ServicePlansApiFp(configuration).showServicePlanModified(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServicePlansApi - object-oriented interface
 * @export
 * @class ServicePlansApi
 * @extends {BaseAPI}
 */
export class ServicePlansApi extends BaseAPI {
    /**
     * Returns the new Service Plan
     * @summary Create Service Plan
     * @param {ImportServicePlan} [importServicePlan]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public createServicePlan(importServicePlan?: ImportServicePlan, options?: any) {
        return ServicePlansApiFp(this.configuration).createServicePlan(importServicePlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Patch Service Plan Modified Schema
     * @param {string} id ID of the resource
     * @param {PatchModifiedServicePlan} [patchModifiedServicePlan]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public patchServicePlanModified(id: string, patchModifiedServicePlan?: PatchModifiedServicePlan, options?: any) {
        return ServicePlansApiFp(this.configuration).patchServicePlanModified(id, patchModifiedServicePlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the Service Plan\'s Modified schema and returns the new one if it has been reset
     * @summary Reset Service Plan Modified schema
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public resetServicePlanModified(id: string, options?: any) {
        return ServicePlansApiFp(this.configuration).resetServicePlanModified(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified Service Plan
     * @summary Show Service Plan
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public showServicePlan(id: string, options?: any) {
        return ServicePlansApiFp(this.configuration).showServicePlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified Service Plan\'s base schema
     * @summary Show Service Plan Base Schema
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public showServicePlanBase(id: string, options?: any) {
        return ServicePlansApiFp(this.configuration).showServicePlanBase(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified Service Plan\'s modified schema
     * @summary Show Service Plan modified Schema
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicePlansApi
     */
    public showServicePlanModified(id: string, options?: any) {
        return ServicePlansApiFp(this.configuration).showServicePlanModified(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Tenant Setting
         * @summary Create Tenant Setting
         * @param {Setting} setting Json encoded key/value pair to create a new setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetting: async (setting: Setting, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            if (setting === null || setting === undefined) {
                throw new RequiredError('setting','Required parameter setting was null or undefined when calling createSetting.');
            }
            const localVarPath = `/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof setting !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(setting !== undefined ? setting : {}) : (setting || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Tenant Setting
         * @summary Delete a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySetting: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling destroySetting.');
            }
            const localVarPath = `/settings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Tenant Settings
         * @summary List Tenant Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSettings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific Tenant Setting
         * @summary Get a specific Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSetting: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling showSetting.');
            }
            const localVarPath = `/settings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Tenant Setting
         * @summary Update a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateSetting.');
            }
            const localVarPath = `/settings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create Tenant Setting
         * @summary Create Tenant Setting
         * @param {Setting} setting Json encoded key/value pair to create a new setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSetting(setting: Setting, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SettingsApiAxiosParamCreator(configuration).createSetting(setting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Tenant Setting
         * @summary Delete a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySetting(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SettingsApiAxiosParamCreator(configuration).destroySetting(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List Tenant Settings
         * @summary List Tenant Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSettings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantSettings>> {
            const localVarAxiosArgs = await SettingsApiAxiosParamCreator(configuration).listSettings(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a specific Tenant Setting
         * @summary Get a specific Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showSetting(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SettingsApiAxiosParamCreator(configuration).showSetting(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Tenant Setting
         * @summary Update a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSetting(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SettingsApiAxiosParamCreator(configuration).updateSetting(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create Tenant Setting
         * @summary Create Tenant Setting
         * @param {Setting} setting Json encoded key/value pair to create a new setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSetting(setting: Setting, options?: any): AxiosPromise<void> {
            return SettingsApiFp(configuration).createSetting(setting, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Tenant Setting
         * @summary Delete a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySetting(name: string, options?: any): AxiosPromise<void> {
            return SettingsApiFp(configuration).destroySetting(name, options).then((request) => request(axios, basePath));
        },
        /**
         * List Tenant Settings
         * @summary List Tenant Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSettings(options?: any): AxiosPromise<TenantSettings> {
            return SettingsApiFp(configuration).listSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific Tenant Setting
         * @summary Get a specific Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSetting(name: string, options?: any): AxiosPromise<void> {
            return SettingsApiFp(configuration).showSetting(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Tenant Setting
         * @summary Update a Tenant Setting
         * @param {string} name name of the setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSetting(name: string, options?: any): AxiosPromise<void> {
            return SettingsApiFp(configuration).updateSetting(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Create Tenant Setting
     * @summary Create Tenant Setting
     * @param {Setting} setting Json encoded key/value pair to create a new setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createSetting(setting: Setting, options?: any) {
        return SettingsApiFp(this.configuration).createSetting(setting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Tenant Setting
     * @summary Delete a Tenant Setting
     * @param {string} name name of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public destroySetting(name: string, options?: any) {
        return SettingsApiFp(this.configuration).destroySetting(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Tenant Settings
     * @summary List Tenant Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public listSettings(options?: any) {
        return SettingsApiFp(this.configuration).listSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific Tenant Setting
     * @summary Get a specific Tenant Setting
     * @param {string} name name of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public showSetting(name: string, options?: any) {
        return SettingsApiFp(this.configuration).showSetting(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Tenant Setting
     * @summary Update a Tenant Setting
     * @param {string} name name of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateSetting(name: string, options?: any) {
        return SettingsApiFp(this.configuration).updateSetting(name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List Tags
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List Tags
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).listTags(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List Tags
         * @summary List Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(options?: any): AxiosPromise<TagsCollection> {
            return TagsApiFp(configuration).listTags(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * List Tags
     * @summary List Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public listTags(options?: any) {
        return TagsApiFp(this.configuration).listTags(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TenantApi - axios parameter creator
 * @export
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of tenants.
         * @summary List Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTenants: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenants`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the tenant specified by the tenant id.
         * @summary Get a specific Tenant
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTenant: async (tenantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling showTenant.');
            }
            const localVarPath = `/tenants/{tenant_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a task to seed the Tenant Groups required for an org admin to onboard additional users.
         * @summary Seed Tenant Groups
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantSeed: async (tenantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling tenantSeed.');
            }
            const localVarPath = `/tenants/{tenant_id}/seed`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 * @export
 */
export const TenantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of tenants.
         * @summary List Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTenants(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantsCollection>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).listTenants(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the tenant specified by the tenant id.
         * @summary Get a specific Tenant
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showTenant(tenantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).showTenant(tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Run a task to seed the Tenant Groups required for an org admin to onboard additional users.
         * @summary Seed Tenant Groups
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantSeed(tenantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).tenantSeed(tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TenantApi - factory interface
 * @export
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get a list of tenants.
         * @summary List Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTenants(options?: any): AxiosPromise<TenantsCollection> {
            return TenantApiFp(configuration).listTenants(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the tenant specified by the tenant id.
         * @summary Get a specific Tenant
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTenant(tenantId: string, options?: any): AxiosPromise<Tenant> {
            return TenantApiFp(configuration).showTenant(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a task to seed the Tenant Groups required for an org admin to onboard additional users.
         * @summary Seed Tenant Groups
         * @param {string} tenantId ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantSeed(tenantId: string, options?: any): AxiosPromise<void> {
            return TenantApiFp(configuration).tenantSeed(tenantId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
export class TenantApi extends BaseAPI {
    /**
     * Get a list of tenants.
     * @summary List Tenants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public listTenants(options?: any) {
        return TenantApiFp(this.configuration).listTenants(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the tenant specified by the tenant id.
     * @summary Get a specific Tenant
     * @param {string} tenantId ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public showTenant(tenantId: string, options?: any) {
        return TenantApiFp(this.configuration).showTenant(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a task to seed the Tenant Groups required for an org admin to onboard additional users.
     * @summary Seed Tenant Groups
     * @param {string} tenantId ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public tenantSeed(tenantId: string, options?: any) {
        return TenantApiFp(this.configuration).tenantSeed(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

}


