// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Cost Management
 * The API for Cost Management.  You can find out more about     Cost Management at [https://github.com/project-koku/](https://github.com/project-koku/).
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cloud.redhat.com/api/cost-management/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface CloudAccountOut
 */
export interface CloudAccountOut {
    /**
     *
     * @type {string}
     * @memberof CloudAccountOut
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CloudAccountOut
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof CloudAccountOut
     */
    description?: string;
    /**
     *
     * @type {Date}
     * @memberof CloudAccountOut
     */
    updatedTimestamp?: Date;
}

/**
 *
 * @export
 * @interface CloudAccountPagination
 */
export interface CloudAccountPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof CloudAccountPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof CloudAccountPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<CloudAccountOut>}
     * @memberof CloudAccountPagination
     */
    data: Array<CloudAccountOut>;
}

/**
 *
 * @export
 * @interface CostModel
 */
export interface CostModel {
    /**
     *
     * @type {string}
     * @memberof CostModel
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CostModel
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof CostModel
     */
    sourceType: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CostModel
     */
    providerUuids?: Array<string>;
    /**
     *
     * @type {Array<Rate>}
     * @memberof CostModel
     */
    rates?: Array<Rate>;
    /**
     *
     * @type {Markup}
     * @memberof CostModel
     */
    markup?: Markup;
}

/**
 *
 * @export
 * @interface CostModelOut
 */
export interface CostModelOut {
    /**
     *
     * @type {string}
     * @memberof CostModelOut
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CostModelOut
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof CostModelOut
     */
    sourceType: string;
    /**
     *
     * @type {Array<CostModelRespProviders>}
     * @memberof CostModelOut
     */
    providers?: Array<CostModelRespProviders>;
    /**
     *
     * @type {Array<Rate>}
     * @memberof CostModelOut
     */
    rates?: Array<Rate>;
    /**
     *
     * @type {string}
     * @memberof CostModelOut
     */
    uuid?: string;
    /**
     *
     * @type {Date}
     * @memberof CostModelOut
     */
    createdTimestamp?: Date;
    /**
     *
     * @type {Date}
     * @memberof CostModelOut
     */
    updatedTimestamp?: Date;
    /**
     *
     * @type {Markup}
     * @memberof CostModelOut
     */
    markup?: Markup;
}

/**
 *
 * @export
 * @interface CostModelPagination
 */
export interface CostModelPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof CostModelPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof CostModelPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<CostModelOut>}
     * @memberof CostModelPagination
     */
    data: Array<CostModelOut>;
}

/**
 *
 * @export
 * @interface CostModelResp
 */
export interface CostModelResp {
    /**
     *
     * @type {string}
     * @memberof CostModelResp
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CostModelResp
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof CostModelResp
     */
    sourceType: string;
    /**
     *
     * @type {Array<CostModelRespProviders>}
     * @memberof CostModelResp
     */
    providers?: Array<CostModelRespProviders>;
    /**
     *
     * @type {Array<Rate>}
     * @memberof CostModelResp
     */
    rates?: Array<Rate>;
}

/**
 *
 * @export
 * @interface CostModelRespProviders
 */
export interface CostModelRespProviders {
    /**
     *
     * @type {string}
     * @memberof CostModelRespProviders
     */
    uuid?: string;
    /**
     *
     * @type {string}
     * @memberof CostModelRespProviders
     */
    name?: string;
}

/**
 *
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     *
     * @type {string}
     * @memberof Customer
     */
    accountId: string;
}

/**
 *
 * @export
 * @interface CustomerOut
 */
export interface CustomerOut {
    /**
     *
     * @type {string}
     * @memberof CustomerOut
     */
    accountId: string;
    /**
     *
     * @type {string}
     * @memberof CustomerOut
     */
    uuid: string;
    /**
     *
     * @type {Date}
     * @memberof CustomerOut
     */
    dateCreated: Date;
}

/**
 *
 * @export
 * @interface DataExportRequest
 */
export interface DataExportRequest {
    /**
     *
     * @type {string}
     * @memberof DataExportRequest
     */
    startDate: string;
    /**
     *
     * @type {string}
     * @memberof DataExportRequest
     */
    endDate: string;
    /**
     *
     * @type {string}
     * @memberof DataExportRequest
     */
    bucketName: string;
}

/**
 *
 * @export
 * @interface DataExportRequestOut
 */
export interface DataExportRequestOut {
    /**
     *
     * @type {string}
     * @memberof DataExportRequestOut
     */
    startDate: string;
    /**
     *
     * @type {string}
     * @memberof DataExportRequestOut
     */
    endDate: string;
    /**
     *
     * @type {string}
     * @memberof DataExportRequestOut
     */
    bucketName: string;
    /**
     *
     * @type {string}
     * @memberof DataExportRequestOut
     */
    uuid: string;
    /**
     *
     * @type {Date}
     * @memberof DataExportRequestOut
     */
    createdTimestamp?: Date;
    /**
     *
     * @type {Date}
     * @memberof DataExportRequestOut
     */
    updatedTimestamp?: Date;
    /**
     *
     * @type {string}
     * @memberof DataExportRequestOut
     */
    status?: DataExportRequestOut.StatusEnum;
}

/**
 * @export
 * @namespace DataExportRequestOut
 */
export namespace DataExportRequestOut {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Pending = 'pending',
        Complete = 'complete'
    }
}

/**
 *
 * @export
 * @interface DataExportRequestPagination
 */
export interface DataExportRequestPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof DataExportRequestPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof DataExportRequestPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<DataExportRequestOut>}
     * @memberof DataExportRequestPagination
     */
    data: Array<DataExportRequestOut>;
}

/**
 *
 * @export
 * @interface ListPagination
 */
export interface ListPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof ListPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ListPagination
     */
    links?: PaginationLinks;
}

/**
 *
 * @export
 * @interface Markup
 */
export interface Markup {
    /**
     *
     * @type {number}
     * @memberof Markup
     */
    value?: number;
    /**
     *
     * @type {string}
     * @memberof Markup
     */
    unit?: Markup.UnitEnum;
}

/**
 * @export
 * @namespace Markup
 */
export namespace Markup {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitEnum {
        Percent = 'percent'
    }
}

/**
 *
 * @export
 * @interface Metrics
 */
export interface Metrics {
    /**
     *
     * @type {PaginationMeta}
     * @memberof Metrics
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof Metrics
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<MetricsOut>}
     * @memberof Metrics
     */
    data: Array<MetricsOut>;
}

/**
 *
 * @export
 * @interface MetricsOut
 */
export interface MetricsOut {
    /**
     *
     * @type {string}
     * @memberof MetricsOut
     */
    sourceType: string;
    /**
     *
     * @type {string}
     * @memberof MetricsOut
     */
    metric: string;
    /**
     *
     * @type {string}
     * @memberof MetricsOut
     */
    labelMetric: string;
    /**
     *
     * @type {string}
     * @memberof MetricsOut
     */
    labelMeasurement: string;
    /**
     *
     * @type {string}
     * @memberof MetricsOut
     */
    labelMeasurementUnit: string;
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {Array<any>}
     * @memberof ModelError
     */
    errors: Array<any>;
}

/**
 *
 * @export
 * @interface PaginationLinks
 */
export interface PaginationLinks {
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    first?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    previous?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    next?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    last?: string;
}

/**
 *
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     *
     * @type {number}
     * @memberof PaginationMeta
     */
    count?: number;
}

/**
 *
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     *
     * @type {string}
     * @memberof Provider
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Provider
     */
    type: string;
}

/**
 *
 * @export
 * @interface ProviderAuthenticationIn
 */
export interface ProviderAuthenticationIn {
    /**
     *
     * @type {string}
     * @memberof ProviderAuthenticationIn
     */
    providerResourceName?: string;
    /**
     *
     * @type {any}
     * @memberof ProviderAuthenticationIn
     */
    credentials?: any;
}

/**
 *
 * @export
 * @interface ProviderAuthenticationOut
 */
export interface ProviderAuthenticationOut {
    /**
     *
     * @type {string}
     * @memberof ProviderAuthenticationOut
     */
    providerResourceName?: string;
    /**
     *
     * @type {any}
     * @memberof ProviderAuthenticationOut
     */
    credentials?: any;
    /**
     *
     * @type {string}
     * @memberof ProviderAuthenticationOut
     */
    uuid: string;
}

/**
 *
 * @export
 * @interface ProviderBillingSourceIn
 */
export interface ProviderBillingSourceIn {
    /**
     *
     * @type {string}
     * @memberof ProviderBillingSourceIn
     */
    bucket?: string;
    /**
     *
     * @type {any}
     * @memberof ProviderBillingSourceIn
     */
    dataSource?: any;
}

/**
 *
 * @export
 * @interface ProviderBillingSourceOut
 */
export interface ProviderBillingSourceOut {
    /**
     *
     * @type {string}
     * @memberof ProviderBillingSourceOut
     */
    bucket?: string;
    /**
     *
     * @type {any}
     * @memberof ProviderBillingSourceOut
     */
    dataSource?: any;
    /**
     *
     * @type {string}
     * @memberof ProviderBillingSourceOut
     */
    uuid: string;
}

/**
 *
 * @export
 * @interface ProviderIn
 */
export interface ProviderIn {
    /**
     *
     * @type {string}
     * @memberof ProviderIn
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof ProviderIn
     */
    type: string;
    /**
     *
     * @type {ProviderAuthenticationIn}
     * @memberof ProviderIn
     */
    authentication: ProviderAuthenticationIn;
    /**
     *
     * @type {ProviderBillingSourceIn}
     * @memberof ProviderIn
     */
    billingSource: ProviderBillingSourceIn;
}

/**
 *
 * @export
 * @interface ProviderOut
 */
export interface ProviderOut {
    /**
     *
     * @type {string}
     * @memberof ProviderOut
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof ProviderOut
     */
    type: string;
    /**
     *
     * @type {string}
     * @memberof ProviderOut
     */
    uuid: string;
    /**
     *
     * @type {ProviderAuthenticationOut}
     * @memberof ProviderOut
     */
    authentication: ProviderAuthenticationOut;
    /**
     *
     * @type {ProviderBillingSourceOut}
     * @memberof ProviderOut
     */
    billingSource: ProviderBillingSourceOut;
    /**
     *
     * @type {CustomerOut}
     * @memberof ProviderOut
     */
    customer: CustomerOut;
    /**
     *
     * @type {UserOut}
     * @memberof ProviderOut
     */
    createdBy: UserOut;
    /**
     * Dictionary key is the start of a billing month.  Value is report processing statistics.
     * @type {any}
     * @memberof ProviderOut
     */
    stats?: any;
    /**
     * OpenShift foundational infrastructure type.
     * @type {string}
     * @memberof ProviderOut
     */
    infrastructure?: string;
    /**
     * Flag to indicate when the provider is configured correctly
     * @type {boolean}
     * @memberof ProviderOut
     */
    active?: boolean;
    /**
     * List of cost model name and UUIDs associated with this provider.
     * @type {Array<any>}
     * @memberof ProviderOut
     */
    costModels?: Array<any>;
}

/**
 *
 * @export
 * @interface ProviderPagination
 */
export interface ProviderPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof ProviderPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ProviderPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<ProviderOut>}
     * @memberof ProviderPagination
     */
    data: Array<ProviderOut>;
}

/**
 *
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     *
     * @type {string}
     * @memberof Rate
     */
    uuid?: string;
    /**
     *
     * @type {any}
     * @memberof Rate
     */
    metric: any;
    /**
     *
     * @type {Array<any>}
     * @memberof Rate
     */
    tieredRates?: Array<any>;
}

/**
 *
 * @export
 * @interface Report
 */
export interface Report {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof Report
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof Report
     */
    links?: PaginationLinks;
}

/**
 *
 * @export
 * @interface ReportAzureFilter
 */
export interface ReportAzureFilter {
    /**
     * Limits the data points returns and aggregates remaining data.
     * @type {number}
     * @memberof ReportAzureFilter
     */
    limit?: number;
    /**
     * Offsets the data points returned when using limit.
     * @type {number}
     * @memberof ReportAzureFilter
     */
    offset?: number;
    /**
     *
     * @type {ReportResolution}
     * @memberof ReportAzureFilter
     */
    resolution?: ReportResolution;
    /**
     *
     * @type {ReportTimeScopeValue}
     * @memberof ReportAzureFilter
     */
    timeScopeValue?: ReportTimeScopeValue;
    /**
     *
     * @type {ReportTimeScopeUnits}
     * @memberof ReportAzureFilter
     */
    timeScopeUnits?: ReportTimeScopeUnits;
    /**
     *
     * @type {Array<ReportResourceScope>}
     * @memberof ReportAzureFilter
     */
    resourceScope?: Array<ReportResourceScope>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureFilter
     */
    subscriptionGuid?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureFilter
     */
    serviceName?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureFilter
     */
    resourceLocation?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureFilter
     */
    instanceType?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureFilter
     */
    tag?: Array<string>;
}

/**
 * The grouping to apply to the report. No grouping by default. When grouping by account the account_alias will be provided if avaiable.
 * @export
 * @interface ReportAzureGrouping
 */
export interface ReportAzureGrouping {
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureGrouping
     */
    subscriptionGuid?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureGrouping
     */
    serviceName?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureGrouping
     */
    resourceLocation?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureGrouping
     */
    instanceType?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportAzureGrouping
     */
    tag?: Array<string>;
}

/**
 * The ordering to apply to the report. Default is ascending order for the data.
 * @export
 * @interface ReportAzureOrdering
 */
export interface ReportAzureOrdering {
    /**
     *
     * @type {string}
     * @memberof ReportAzureOrdering
     */
    cost?: ReportAzureOrdering.CostEnum;
    /**
     *
     * @type {string}
     * @memberof ReportAzureOrdering
     */
    usage?: ReportAzureOrdering.UsageEnum;
    /**
     *
     * @type {string}
     * @memberof ReportAzureOrdering
     */
    delta?: ReportAzureOrdering.DeltaEnum;
    /**
     *
     * @type {string}
     * @memberof ReportAzureOrdering
     */
    subscriptionGuid?: ReportAzureOrdering.SubscriptionGuidEnum;
    /**
     *
     * @type {string}
     * @memberof ReportAzureOrdering
     */
    resourceLocation?: ReportAzureOrdering.ResourceLocationEnum;
    /**
     *
     * @type {string}
     * @memberof ReportAzureOrdering
     */
    serviceName?: ReportAzureOrdering.ServiceNameEnum;
    /**
     *
     * @type {string}
     * @memberof ReportAzureOrdering
     */
    instanceType?: ReportAzureOrdering.InstanceTypeEnum;
}

/**
 * @export
 * @namespace ReportAzureOrdering
 */
export namespace ReportAzureOrdering {
    /**
     * @export
     * @enum {string}
     */
    export enum CostEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UsageEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DeltaEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubscriptionGuidEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ResourceLocationEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ServiceNameEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InstanceTypeEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 *
 * @export
 * @interface ReportCost
 */
export interface ReportCost {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportCost
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportCost
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportCost
     */
    data: Array<any>;
}

/**
 *
 * @export
 * @interface ReportCosts
 */
export interface ReportCosts {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportCosts
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportCosts
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportCosts
     */
    data: Array<any>;
}

/**
 * The ordering to apply to the report. Default is ascending order for the data.
 * @export
 * @interface ReportCostsOpenShiftOrdering
 */
export interface ReportCostsOpenShiftOrdering {
    /**
     *
     * @type {string}
     * @memberof ReportCostsOpenShiftOrdering
     */
    cluster?: ReportCostsOpenShiftOrdering.ClusterEnum;
    /**
     *
     * @type {string}
     * @memberof ReportCostsOpenShiftOrdering
     */
    project?: ReportCostsOpenShiftOrdering.ProjectEnum;
    /**
     *
     * @type {string}
     * @memberof ReportCostsOpenShiftOrdering
     */
    node?: ReportCostsOpenShiftOrdering.NodeEnum;
    /**
     *
     * @type {string}
     * @memberof ReportCostsOpenShiftOrdering
     */
    cost?: ReportCostsOpenShiftOrdering.CostEnum;
}

/**
 * @export
 * @namespace ReportCostsOpenShiftOrdering
 */
export namespace ReportCostsOpenShiftOrdering {
    /**
     * @export
     * @enum {string}
     */
    export enum ClusterEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ProjectEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NodeEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CostEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 * Field to calculate delta values for in report.
 * @export
 * @interface ReportDelta
 */
export interface ReportDelta {
    /**
     *
     * @type {string}
     * @memberof ReportDelta
     */
    delta?: string;
}

/**
 *
 * @export
 * @interface ReportFilter
 */
export interface ReportFilter {
    /**
     * Limits the data points returns and aggregates remaining data.
     * @type {number}
     * @memberof ReportFilter
     */
    limit?: number;
    /**
     * Offsets the data points returned when using limit.
     * @type {number}
     * @memberof ReportFilter
     */
    offset?: number;
    /**
     *
     * @type {ReportResolution}
     * @memberof ReportFilter
     */
    resolution?: ReportResolution;
    /**
     *
     * @type {ReportTimeScopeValue}
     * @memberof ReportFilter
     */
    timeScopeValue?: ReportTimeScopeValue;
    /**
     *
     * @type {ReportTimeScopeUnits}
     * @memberof ReportFilter
     */
    timeScopeUnits?: ReportTimeScopeUnits;
    /**
     *
     * @type {Array<ReportResourceScope>}
     * @memberof ReportFilter
     */
    resourceScope?: Array<ReportResourceScope>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportFilter
     */
    account?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportFilter
     */
    service?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportFilter
     */
    region?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportFilter
     */
    az?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportFilter
     */
    tag?: Array<string>;
}

/**
 * The grouping to apply to the report. No grouping by default. When grouping by account the account_alias will be provided if avaiable.
 * @export
 * @interface ReportGrouping
 */
export interface ReportGrouping {
    /**
     *
     * @type {Array<string>}
     * @memberof ReportGrouping
     */
    account?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportGrouping
     */
    service?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportGrouping
     */
    region?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportGrouping
     */
    az?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportGrouping
     */
    instanceType?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportGrouping
     */
    storageType?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportGrouping
     */
    tag?: Array<string>;
}

/**
 *
 * @export
 * @interface ReportInstanceInventory
 */
export interface ReportInstanceInventory {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportInstanceInventory
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportInstanceInventory
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportInstanceInventory
     */
    data: Array<any>;
}

/**
 * The ordering to apply to the report. Default is ascending order for the data.
 * @export
 * @interface ReportInventoryOpenShiftOrdering
 */
export interface ReportInventoryOpenShiftOrdering {
    /**
     *
     * @type {string}
     * @memberof ReportInventoryOpenShiftOrdering
     */
    cluster?: ReportInventoryOpenShiftOrdering.ClusterEnum;
    /**
     *
     * @type {string}
     * @memberof ReportInventoryOpenShiftOrdering
     */
    project?: ReportInventoryOpenShiftOrdering.ProjectEnum;
    /**
     *
     * @type {string}
     * @memberof ReportInventoryOpenShiftOrdering
     */
    node?: ReportInventoryOpenShiftOrdering.NodeEnum;
    /**
     *
     * @type {string}
     * @memberof ReportInventoryOpenShiftOrdering
     */
    usage?: ReportInventoryOpenShiftOrdering.UsageEnum;
    /**
     *
     * @type {string}
     * @memberof ReportInventoryOpenShiftOrdering
     */
    request?: ReportInventoryOpenShiftOrdering.RequestEnum;
    /**
     *
     * @type {string}
     * @memberof ReportInventoryOpenShiftOrdering
     */
    cost?: ReportInventoryOpenShiftOrdering.CostEnum;
    /**
     *
     * @type {string}
     * @memberof ReportInventoryOpenShiftOrdering
     */
    limit?: ReportInventoryOpenShiftOrdering.LimitEnum;
}

/**
 * @export
 * @namespace ReportInventoryOpenShiftOrdering
 */
export namespace ReportInventoryOpenShiftOrdering {
    /**
     * @export
     * @enum {string}
     */
    export enum ClusterEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ProjectEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NodeEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UsageEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RequestEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CostEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LimitEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 *
 * @export
 * @interface ReportOpenShiftAWSFilter
 */
export interface ReportOpenShiftAWSFilter {
    /**
     * Limits the data points returns and aggregates remaining data.
     * @type {number}
     * @memberof ReportOpenShiftAWSFilter
     */
    limit?: number;
    /**
     * Offsets the data points returned when using limit.
     * @type {number}
     * @memberof ReportOpenShiftAWSFilter
     */
    offset?: number;
    /**
     *
     * @type {ReportResolution}
     * @memberof ReportOpenShiftAWSFilter
     */
    resolution?: ReportResolution;
    /**
     *
     * @type {ReportTimeScopeValue}
     * @memberof ReportOpenShiftAWSFilter
     */
    timeScopeValue?: ReportTimeScopeValue;
    /**
     *
     * @type {ReportTimeScopeUnits}
     * @memberof ReportOpenShiftAWSFilter
     */
    timeScopeUnits?: ReportTimeScopeUnits;
    /**
     *
     * @type {Array<ReportResourceScope>}
     * @memberof ReportOpenShiftAWSFilter
     */
    resourceScope?: Array<ReportResourceScope>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSFilter
     */
    account?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSFilter
     */
    service?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSFilter
     */
    region?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSFilter
     */
    az?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSFilter
     */
    tag?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSFilter
     */
    project?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSFilter
     */
    cluster?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSFilter
     */
    node?: Array<string>;
}

/**
 * The grouping to apply to the report. No grouping by default. When grouping by account the account_alias will be provided if avaiable.
 * @export
 * @interface ReportOpenShiftAWSGrouping
 */
export interface ReportOpenShiftAWSGrouping {
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    account?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    service?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    region?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    az?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    instanceType?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    storageType?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    tag?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    cluster?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    project?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAWSGrouping
     */
    node?: Array<string>;
}

/**
 *
 * @export
 * @interface ReportOpenShiftAWSInstanceInventory
 */
export interface ReportOpenShiftAWSInstanceInventory {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportOpenShiftAWSInstanceInventory
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportOpenShiftAWSInstanceInventory
     */
    links?: PaginationLinks;
    /**
     *
     * @type {ReportOpenShiftAWSGrouping}
     * @memberof ReportOpenShiftAWSInstanceInventory
     */
    groupBy?: ReportOpenShiftAWSGrouping;
    /**
     *
     * @type {ReportOpenShiftAWSOrdering}
     * @memberof ReportOpenShiftAWSInstanceInventory
     */
    orderBy?: ReportOpenShiftAWSOrdering;
    /**
     *
     * @type {ReportOpenShiftAWSFilter}
     * @memberof ReportOpenShiftAWSInstanceInventory
     */
    filter?: ReportOpenShiftAWSFilter;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportOpenShiftAWSInstanceInventory
     */
    data: Array<any>;
}

/**
 * The ordering to apply to the report. Default is ascending order for the data.
 * @export
 * @interface ReportOpenShiftAWSOrdering
 */
export interface ReportOpenShiftAWSOrdering {
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    cost?: ReportOpenShiftAWSOrdering.CostEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    usage?: ReportOpenShiftAWSOrdering.UsageEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    delta?: ReportOpenShiftAWSOrdering.DeltaEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    accountAlias?: ReportOpenShiftAWSOrdering.AccountAliasEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    region?: ReportOpenShiftAWSOrdering.RegionEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    service?: ReportOpenShiftAWSOrdering.ServiceEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    cluster?: ReportOpenShiftAWSOrdering.ClusterEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    project?: ReportOpenShiftAWSOrdering.ProjectEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAWSOrdering
     */
    node?: ReportOpenShiftAWSOrdering.NodeEnum;
}

/**
 * @export
 * @namespace ReportOpenShiftAWSOrdering
 */
export namespace ReportOpenShiftAWSOrdering {
    /**
     * @export
     * @enum {string}
     */
    export enum CostEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UsageEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DeltaEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AccountAliasEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RegionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ServiceEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ClusterEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ProjectEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NodeEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 *
 * @export
 * @interface ReportOpenShiftAWSStorageInventory
 */
export interface ReportOpenShiftAWSStorageInventory {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportOpenShiftAWSStorageInventory
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportOpenShiftAWSStorageInventory
     */
    links?: PaginationLinks;
    /**
     *
     * @type {ReportOpenShiftAWSGrouping}
     * @memberof ReportOpenShiftAWSStorageInventory
     */
    groupBy?: ReportOpenShiftAWSGrouping;
    /**
     *
     * @type {ReportOpenShiftAWSOrdering}
     * @memberof ReportOpenShiftAWSStorageInventory
     */
    orderBy?: ReportOpenShiftAWSOrdering;
    /**
     *
     * @type {ReportOpenShiftAWSFilter}
     * @memberof ReportOpenShiftAWSStorageInventory
     */
    filter?: ReportOpenShiftAWSFilter;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportOpenShiftAWSStorageInventory
     */
    data: Array<any>;
}

/**
 *
 * @export
 * @interface ReportOpenShiftAzureFilter
 */
export interface ReportOpenShiftAzureFilter {
    /**
     * Limits the data points returns and aggregates remaining data.
     * @type {number}
     * @memberof ReportOpenShiftAzureFilter
     */
    limit?: number;
    /**
     * Offsets the data points returned when using limit.
     * @type {number}
     * @memberof ReportOpenShiftAzureFilter
     */
    offset?: number;
    /**
     *
     * @type {ReportResolution}
     * @memberof ReportOpenShiftAzureFilter
     */
    resolution?: ReportResolution;
    /**
     *
     * @type {ReportTimeScopeValue}
     * @memberof ReportOpenShiftAzureFilter
     */
    timeScopeValue?: ReportTimeScopeValue;
    /**
     *
     * @type {ReportTimeScopeUnits}
     * @memberof ReportOpenShiftAzureFilter
     */
    timeScopeUnits?: ReportTimeScopeUnits;
    /**
     *
     * @type {Array<ReportResourceScope>}
     * @memberof ReportOpenShiftAzureFilter
     */
    resourceScope?: Array<ReportResourceScope>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureFilter
     */
    subscriptionGuid?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureFilter
     */
    serviceName?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureFilter
     */
    resourceLocation?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureFilter
     */
    instanceType?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureFilter
     */
    tag?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureFilter
     */
    project?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureFilter
     */
    cluster?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureFilter
     */
    node?: Array<string>;
}

/**
 * The grouping to apply to the report. No grouping by default. When grouping by account the account_alias will be provided if avaiable.
 * @export
 * @interface ReportOpenShiftAzureGrouping
 */
export interface ReportOpenShiftAzureGrouping {
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureGrouping
     */
    subscriptionGuid?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureGrouping
     */
    serviceName?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureGrouping
     */
    resourceLocation?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureGrouping
     */
    instanceType?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureGrouping
     */
    tag?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureGrouping
     */
    cluster?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureGrouping
     */
    project?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftAzureGrouping
     */
    node?: Array<string>;
}

/**
 *
 * @export
 * @interface ReportOpenShiftAzureInstanceInventory
 */
export interface ReportOpenShiftAzureInstanceInventory {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportOpenShiftAzureInstanceInventory
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportOpenShiftAzureInstanceInventory
     */
    links?: PaginationLinks;
    /**
     *
     * @type {ReportOpenShiftAzureGrouping}
     * @memberof ReportOpenShiftAzureInstanceInventory
     */
    groupBy?: ReportOpenShiftAzureGrouping;
    /**
     *
     * @type {ReportOpenShiftAzureOrdering}
     * @memberof ReportOpenShiftAzureInstanceInventory
     */
    orderBy?: ReportOpenShiftAzureOrdering;
    /**
     *
     * @type {ReportOpenShiftAzureFilter}
     * @memberof ReportOpenShiftAzureInstanceInventory
     */
    filter?: ReportOpenShiftAzureFilter;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportOpenShiftAzureInstanceInventory
     */
    data: Array<any>;
}

/**
 * The ordering to apply to the report. Default is ascending order for the data.
 * @export
 * @interface ReportOpenShiftAzureOrdering
 */
export interface ReportOpenShiftAzureOrdering {
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    cost?: ReportOpenShiftAzureOrdering.CostEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    usage?: ReportOpenShiftAzureOrdering.UsageEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    delta?: ReportOpenShiftAzureOrdering.DeltaEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    subscriptionGuid?: ReportOpenShiftAzureOrdering.SubscriptionGuidEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    resourceLocation?: ReportOpenShiftAzureOrdering.ResourceLocationEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    serviceName?: ReportOpenShiftAzureOrdering.ServiceNameEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    instanceType?: ReportOpenShiftAzureOrdering.InstanceTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    cluster?: ReportOpenShiftAzureOrdering.ClusterEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    project?: ReportOpenShiftAzureOrdering.ProjectEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOpenShiftAzureOrdering
     */
    node?: ReportOpenShiftAzureOrdering.NodeEnum;
}

/**
 * @export
 * @namespace ReportOpenShiftAzureOrdering
 */
export namespace ReportOpenShiftAzureOrdering {
    /**
     * @export
     * @enum {string}
     */
    export enum CostEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UsageEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DeltaEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubscriptionGuidEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ResourceLocationEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ServiceNameEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InstanceTypeEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ClusterEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ProjectEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NodeEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 *
 * @export
 * @interface ReportOpenShiftAzureStorageInventory
 */
export interface ReportOpenShiftAzureStorageInventory {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportOpenShiftAzureStorageInventory
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportOpenShiftAzureStorageInventory
     */
    links?: PaginationLinks;
    /**
     *
     * @type {ReportOpenShiftAzureGrouping}
     * @memberof ReportOpenShiftAzureStorageInventory
     */
    groupBy?: ReportOpenShiftAzureGrouping;
    /**
     *
     * @type {ReportOpenShiftAzureOrdering}
     * @memberof ReportOpenShiftAzureStorageInventory
     */
    orderBy?: ReportOpenShiftAzureOrdering;
    /**
     *
     * @type {ReportOpenShiftAzureFilter}
     * @memberof ReportOpenShiftAzureStorageInventory
     */
    filter?: ReportOpenShiftAzureFilter;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportOpenShiftAzureStorageInventory
     */
    data: Array<any>;
}

/**
 *
 * @export
 * @interface ReportOpenShiftCpu
 */
export interface ReportOpenShiftCpu {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportOpenShiftCpu
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportOpenShiftCpu
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportOpenShiftCpu
     */
    data: Array<any>;
}

/**
 *
 * @export
 * @interface ReportOpenShiftFilter
 */
export interface ReportOpenShiftFilter {
    /**
     * Limits the data points returns and aggregates remaining data.
     * @type {number}
     * @memberof ReportOpenShiftFilter
     */
    limit?: number;
    /**
     * Offsets the data points returned when using limit.
     * @type {number}
     * @memberof ReportOpenShiftFilter
     */
    offset?: number;
    /**
     *
     * @type {ReportResolution}
     * @memberof ReportOpenShiftFilter
     */
    resolution?: ReportResolution;
    /**
     *
     * @type {ReportTimeScopeValue}
     * @memberof ReportOpenShiftFilter
     */
    timeScopeValue?: ReportTimeScopeValue;
    /**
     *
     * @type {ReportTimeScopeUnits}
     * @memberof ReportOpenShiftFilter
     */
    timeScopeUnits?: ReportTimeScopeUnits;
    /**
     *
     * @type {Array<ReportResourceScope>}
     * @memberof ReportOpenShiftFilter
     */
    resourceScope?: Array<ReportResourceScope>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftFilter
     */
    project?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftFilter
     */
    cluster?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftFilter
     */
    pod?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftFilter
     */
    node?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftFilter
     */
    tag?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftFilter
     */
    infrastructures?: Array<string>;
}

/**
 * The grouping to apply to the report. No grouping by default.
 * @export
 * @interface ReportOpenShiftGrouping
 */
export interface ReportOpenShiftGrouping {
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftGrouping
     */
    cluster?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftGrouping
     */
    project?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftGrouping
     */
    node?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ReportOpenShiftGrouping
     */
    tag?: Array<string>;
}

/**
 *
 * @export
 * @interface ReportOpenShiftMemory
 */
export interface ReportOpenShiftMemory {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportOpenShiftMemory
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportOpenShiftMemory
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportOpenShiftMemory
     */
    data: Array<any>;
}

/**
 *
 * @export
 * @interface ReportOpenShiftVolume
 */
export interface ReportOpenShiftVolume {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportOpenShiftVolume
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportOpenShiftVolume
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportOpenShiftVolume
     */
    data: Array<any>;
}

/**
 * The ordering to apply to the report. Default is ascending order for the data.
 * @export
 * @interface ReportOrdering
 */
export interface ReportOrdering {
    /**
     *
     * @type {string}
     * @memberof ReportOrdering
     */
    cost?: ReportOrdering.CostEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOrdering
     */
    usage?: ReportOrdering.UsageEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOrdering
     */
    delta?: ReportOrdering.DeltaEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOrdering
     */
    accountAlias?: ReportOrdering.AccountAliasEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOrdering
     */
    region?: ReportOrdering.RegionEnum;
    /**
     *
     * @type {string}
     * @memberof ReportOrdering
     */
    service?: ReportOrdering.ServiceEnum;
}

/**
 * @export
 * @namespace ReportOrdering
 */
export namespace ReportOrdering {
    /**
     * @export
     * @enum {string}
     */
    export enum CostEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UsageEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DeltaEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AccountAliasEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RegionEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ServiceEnum {
        Asc = 'asc',
        Desc = 'desc'
    }
}

/**
 *
 * @export
 * @interface ReportPaginationMeta
 */
export interface ReportPaginationMeta {
    /**
     *
     * @type {number}
     * @memberof ReportPaginationMeta
     */
    count?: number;
    /**
     *
     * @type {ReportDelta}
     * @memberof ReportPaginationMeta
     */
    delta?: ReportDelta;
    /**
     *
     * @type {Object}
     * @memberof ReportPaginationMeta
     */
    groupBy?: Object;
    /**
     *
     * @type {Object}
     * @memberof ReportPaginationMeta
     */
    orderBy?: Object;
    /**
     *
     * @type {Object}
     * @memberof ReportPaginationMeta
     */
    filter?: Object;
    /**
     * The units for the output data.
     * @type {string}
     * @memberof ReportPaginationMeta
     */
    units?: string;
}

/**
 * The resolution to apply to the report. Default resolution is daily.
 * @export
 * @enum {string}
 */
export enum ReportResolution {
    Daily = 'daily',
    Monthly = 'monthly'
}

/**
 * The resources scope to apply to the report. Default resource scope is null, meaning no product or service filtering.
 * @export
 * @enum {string}
 */
export enum ReportResourceScope {
    EC2 = 'EC2',
    EBS = 'EBS',
    EFS = 'EFS',
    S3 = 'S3'
}

/**
 *
 * @export
 * @interface ReportStorageInventory
 */
export interface ReportStorageInventory {
    /**
     *
     * @type {ReportPaginationMeta}
     * @memberof ReportStorageInventory
     */
    meta?: ReportPaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ReportStorageInventory
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<any>}
     * @memberof ReportStorageInventory
     */
    data: Array<any>;
}

/**
 * The units to apply to the report. Default time_scope_units is day.
 * @export
 * @enum {string}
 */
export enum ReportTimeScopeUnits {
    Day = 'day',
    Month = 'month'
}

/**
 * The time scope to apply to the report. Default time scope is '-10', meaning the last 10 days. Last 30 days would be '-30'. '-10' and '-30' are only valid when used with 'day' time_scope_units.'-1' is used for current month, '-2' is used for last month when time_scope_units is 'month' otherwise invalid.
 * @export
 * @enum {string}
 */
export enum ReportTimeScopeValue {
    NUMBER_MINUS_1 = -1,
    NUMBER_MINUS_2 = -2,
    NUMBER_MINUS_10 = -10,
    NUMBER_MINUS_30 = -30
}

/**
 *
 * @export
 * @interface Source
 */
export interface Source {
    /**
     *
     * @type {number}
     * @memberof Source
     */
    sourceId: number;
    /**
     *
     * @type {string}
     * @memberof Source
     */
    sourceType: string;
}

/**
 *
 * @export
 * @interface SourceIn
 */
export interface SourceIn {
    /**
     *
     * @type {number}
     * @memberof SourceIn
     */
    sourceId: number;
    /**
     *
     * @type {string}
     * @memberof SourceIn
     */
    sourceType: string;
    /**
     * Dictionary containing resource name.
     * @type {any}
     * @memberof SourceIn
     */
    authentication: any;
    /**
     * Dictionary containing billing source.
     * @type {any}
     * @memberof SourceIn
     */
    billingSource: any;
}

/**
 *
 * @export
 * @interface SourceOut
 */
export interface SourceOut {
    /**
     *
     * @type {number}
     * @memberof SourceOut
     */
    sourceId: number;
    /**
     *
     * @type {string}
     * @memberof SourceOut
     */
    sourceType: string;
    /**
     *
     * @type {string}
     * @memberof SourceOut
     */
    name: string;
    /**
     * Dictionary containing resource name.
     * @type {any}
     * @memberof SourceOut
     */
    authentication: any;
    /**
     * Dictionary containing billing source.
     * @type {any}
     * @memberof SourceOut
     */
    billingSource: any;
    /**
     *
     * @type {string}
     * @memberof SourceOut
     */
    kokuUuid?: string;
    /**
     *
     * @type {string}
     * @memberof SourceOut
     */
    sourceUuid: string;
}

/**
 *
 * @export
 * @interface SourcePagination
 */
export interface SourcePagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof SourcePagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof SourcePagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<SourceOut>}
     * @memberof SourcePagination
     */
    data: Array<SourceOut>;
}

/**
 *
 * @export
 * @interface Status
 */
export interface Status {
    /**
     *
     * @type {number}
     * @memberof Status
     */
    apiVersion: number;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    commit?: string;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    serverAddress?: string;
    /**
     *
     * @type {number}
     * @memberof Status
     */
    rbacCacheTtl?: number;
    /**
     *
     * @type {any}
     * @memberof Status
     */
    platformInfo?: any;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    pythonVersion?: string;
    /**
     *
     * @type {any}
     * @memberof Status
     */
    modules?: any;
}

/**
 *
 * @export
 * @interface Tags
 */
export interface Tags {
    /**
     *
     * @type {TagsFilter}
     * @memberof Tags
     */
    filter?: TagsFilter;
    /**
     *
     * @type {Array<any>}
     * @memberof Tags
     */
    data?: Array<any>;
}

/**
 *
 * @export
 * @interface TagsFilter
 */
export interface TagsFilter {
    /**
     *
     * @type {ReportResolution}
     * @memberof TagsFilter
     */
    resolution?: ReportResolution;
    /**
     *
     * @type {ReportTimeScopeValue}
     * @memberof TagsFilter
     */
    timeScopeValue?: ReportTimeScopeValue;
    /**
     *
     * @type {ReportTimeScopeUnits}
     * @memberof TagsFilter
     */
    timeScopeUnits?: ReportTimeScopeUnits;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    email: string;
}

/**
 *
 * @export
 * @interface UserOut
 */
export interface UserOut {
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    uuid: string;
}

/**
 *
 * @export
 * @interface UserPreference
 */
export interface UserPreference {
    /**
     *
     * @type {string}
     * @memberof UserPreference
     */
    name: string;
    /**
     *
     * @type {any}
     * @memberof UserPreference
     */
    preference: any;
    /**
     *
     * @type {string}
     * @memberof UserPreference
     */
    description?: string;
}

/**
 *
 * @export
 * @interface UserPreferenceOut
 */
export interface UserPreferenceOut {
    /**
     *
     * @type {string}
     * @memberof UserPreferenceOut
     */
    name: string;
    /**
     *
     * @type {any}
     * @memberof UserPreferenceOut
     */
    preference: any;
    /**
     *
     * @type {string}
     * @memberof UserPreferenceOut
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof UserPreferenceOut
     */
    uuid: string;
    /**
     *
     * @type {UserOut}
     * @memberof UserPreferenceOut
     */
    user: UserOut;
}

/**
 *
 * @export
 * @interface UserPreferencePagination
 */
export interface UserPreferencePagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof UserPreferencePagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof UserPreferencePagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<UserPreferenceOut>}
     * @memberof UserPreferencePagination
     */
    data: Array<UserPreferenceOut>;
}


/**
 * AWSReportApi - axios parameter creator
 * @export
 */
export const AWSReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/aws/costs/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (delta !== undefined) {
                localVarQueryParameter['delta'] = delta;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain AWS instance type data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSInstanceReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/aws/instance-types/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSStorageReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/aws/storage/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AWSReportApi - functional programming interface
 * @export
 */
export const AWSReportApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportCost> {
            const localVarAxiosArgs = AWSReportApiAxiosParamCreator(configuration).getAWSCostReports(delta, filter, groupBy, orderBy, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain AWS instance type data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSInstanceReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportInstanceInventory> {
            const localVarAxiosArgs = AWSReportApiAxiosParamCreator(configuration).getAWSInstanceReports(filter, groupBy, orderBy, units, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSStorageReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportStorageInventory> {
            const localVarAxiosArgs = AWSReportApiAxiosParamCreator(configuration).getAWSStorageReports(filter, groupBy, orderBy, units, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AWSReportApi - factory interface
 * @export
 */
export const AWSReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
            return AWSReportApiFp(configuration).getAWSCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain AWS instance type data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSInstanceReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
            return AWSReportApiFp(configuration).getAWSInstanceReports(filter, groupBy, orderBy, units, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSStorageReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
            return AWSReportApiFp(configuration).getAWSStorageReports(filter, groupBy, orderBy, units, offset, limit, options)(axios, basePath);
        },
    };
};

/**
 * AWSReportApi - object-oriented interface
 * @export
 * @class AWSReportApi
 * @extends {BaseAPI}
 */
export class AWSReportApi extends BaseAPI {
    /**
     *
     * @summary Query to obtain cost reports
     * @param {string} [delta] Toggle to include delta values in report.
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AWSReportApi
     */
    public getAWSCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
        return AWSReportApiFp(this.configuration).getAWSCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain AWS instance type data
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {string} [units] The units used to report data.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AWSReportApi
     */
    public getAWSInstanceReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
        return AWSReportApiFp(this.configuration).getAWSInstanceReports(filter, groupBy, orderBy, units, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain AWS storage data
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {string} [units] The units used to report data.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AWSReportApi
     */
    public getAWSStorageReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
        return AWSReportApiFp(this.configuration).getAWSStorageReports(filter, groupBy, orderBy, units, offset, limit, options)(this.axios, this.basePath);
    }

}

/**
 * AzureReportApi - axios parameter creator
 * @export
 */
export const AzureReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/azure/costs/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (delta !== undefined) {
                localVarQueryParameter['delta'] = delta;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain Azure instance type data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureInstanceReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/azure/instance-types/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureStorageReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/azure/storage/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AzureReportApi - functional programming interface
 * @export
 */
export const AzureReportApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportCost> {
            const localVarAxiosArgs = AzureReportApiAxiosParamCreator(configuration).getAzureCostReports(delta, filter, groupBy, orderBy, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain Azure instance type data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureInstanceReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportInstanceInventory> {
            const localVarAxiosArgs = AzureReportApiAxiosParamCreator(configuration).getAzureInstanceReports(filter, groupBy, orderBy, units, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureStorageReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportStorageInventory> {
            const localVarAxiosArgs = AzureReportApiAxiosParamCreator(configuration).getAzureStorageReports(filter, groupBy, orderBy, units, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AzureReportApi - factory interface
 * @export
 */
export const AzureReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
            return AzureReportApiFp(configuration).getAzureCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain Azure instance type data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureInstanceReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
            return AzureReportApiFp(configuration).getAzureInstanceReports(filter, groupBy, orderBy, units, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureStorageReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
            return AzureReportApiFp(configuration).getAzureStorageReports(filter, groupBy, orderBy, units, offset, limit, options)(axios, basePath);
        },
    };
};

/**
 * AzureReportApi - object-oriented interface
 * @export
 * @class AzureReportApi
 * @extends {BaseAPI}
 */
export class AzureReportApi extends BaseAPI {
    /**
     *
     * @summary Query to obtain cost reports
     * @param {string} [delta] Toggle to include delta values in report.
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureReportApi
     */
    public getAzureCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
        return AzureReportApiFp(this.configuration).getAzureCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain Azure instance type data
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {string} [units] The units used to report data.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureReportApi
     */
    public getAzureInstanceReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
        return AzureReportApiFp(this.configuration).getAzureInstanceReports(filter, groupBy, orderBy, units, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain AWS storage data
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {string} [units] The units used to report data.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureReportApi
     */
    public getAzureStorageReports(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
        return AzureReportApiFp(this.configuration).getAzureStorageReports(filter, groupBy, orderBy, units, offset, limit, options)(this.axios, this.basePath);
    }

}

/**
 * CloudAccountsApi - axios parameter creator
 * @export
 */
export const CloudAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain defined cloud accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudAccounts(options: any = {}): RequestArgs {
            const localVarPath = `/cloud-accounts/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudAccountsApi - functional programming interface
 * @export
 */
export const CloudAccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain defined cloud accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudAccounts(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudAccountPagination> {
            const localVarAxiosArgs = CloudAccountsApiAxiosParamCreator(configuration).getCloudAccounts(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CloudAccountsApi - factory interface
 * @export
 */
export const CloudAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Obtain defined cloud accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudAccounts(options?: any) {
            return CloudAccountsApiFp(configuration).getCloudAccounts(options)(axios, basePath);
        },
    };
};

/**
 * CloudAccountsApi - object-oriented interface
 * @export
 * @class CloudAccountsApi
 * @extends {BaseAPI}
 */
export class CloudAccountsApi extends BaseAPI {
    /**
     *
     * @summary Obtain defined cloud accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudAccountsApi
     */
    public getCloudAccounts(options?: any) {
        return CloudAccountsApiFp(this.configuration).getCloudAccounts(options)(this.axios, this.basePath);
    }

}

/**
 * CostModelApi - axios parameter creator
 * @export
 */
export const CostModelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new cost model.
         * @param {CostModel} costModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCostModel(costModel: CostModel, options: any = {}): RequestArgs {
            // verify required parameter 'costModel' is not null or undefined
            if (costModel === null || costModel === undefined) {
                throw new RequiredError('costModel','Required parameter costModel was null or undefined when calling createCostModel.');
            }
            const localVarPath = `/costmodels/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CostModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(costModel || {}) : (costModel || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Cost Model
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCostModel(costModelUuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'costModelUuid' is not null or undefined
            if (costModelUuid === null || costModelUuid === undefined) {
                throw new RequiredError('costModelUuid','Required parameter costModelUuid was null or undefined when calling deleteCostModel.');
            }
            const localVarPath = `/costmodels/{cost_model_uuid}/`
                .replace(`{${"cost_model_uuid"}}`, encodeURIComponent(String(costModelUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Cost Model.
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostModel(costModelUuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'costModelUuid' is not null or undefined
            if (costModelUuid === null || costModelUuid === undefined) {
                throw new RequiredError('costModelUuid','Required parameter costModelUuid was null or undefined when calling getCostModel.');
            }
            const localVarPath = `/costmodels/{cost_model_uuid}/`
                .replace(`{${"cost_model_uuid"}}`, encodeURIComponent(String(costModelUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the cost models
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {string} [providerUuid] Filter response on provider uuid.
         * @param {string} [sourceType] Filter response on provider source type.
         * @param {string} [name] Filter response on cost model name.
         * @param {string} [description] Filter response on cost model description.
         * @param {'name' | '-name' | 'source_type' | '-source_type' | 'updated_timestamp' | '-updated_timestamp'} [ordering] Order response on cost model by allowed fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCostModels(offset?: number, limit?: number, providerUuid?: string, sourceType?: string, name?: string, description?: string, ordering?: 'name' | '-name' | 'source_type' | '-source_type' | 'updated_timestamp' | '-updated_timestamp', options: any = {}): RequestArgs {
            const localVarPath = `/costmodels/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (providerUuid !== undefined) {
                localVarQueryParameter['provider_uuid'] = providerUuid;
            }

            if (sourceType !== undefined) {
                localVarQueryParameter['source_type'] = sourceType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a Cost Model
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {CostModel} costModel Update to a Cost Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCostModel(costModelUuid: string, costModel: CostModel, options: any = {}): RequestArgs {
            // verify required parameter 'costModelUuid' is not null or undefined
            if (costModelUuid === null || costModelUuid === undefined) {
                throw new RequiredError('costModelUuid','Required parameter costModelUuid was null or undefined when calling updateCostModel.');
            }
            // verify required parameter 'costModel' is not null or undefined
            if (costModel === null || costModel === undefined) {
                throw new RequiredError('costModel','Required parameter costModel was null or undefined when calling updateCostModel.');
            }
            const localVarPath = `/costmodels/{cost_model_uuid}/`
                .replace(`{${"cost_model_uuid"}}`, encodeURIComponent(String(costModelUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CostModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(costModel || {}) : (costModel || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CostModelApi - functional programming interface
 * @export
 */
export const CostModelApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new cost model.
         * @param {CostModel} costModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCostModel(costModel: CostModel, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostModelOut> {
            const localVarAxiosArgs = CostModelApiAxiosParamCreator(configuration).createCostModel(costModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a Cost Model
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCostModel(costModelUuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CostModelApiAxiosParamCreator(configuration).deleteCostModel(costModelUuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a Cost Model.
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostModel(costModelUuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostModelOut> {
            const localVarAxiosArgs = CostModelApiAxiosParamCreator(configuration).getCostModel(costModelUuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List the cost models
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {string} [providerUuid] Filter response on provider uuid.
         * @param {string} [sourceType] Filter response on provider source type.
         * @param {string} [name] Filter response on cost model name.
         * @param {string} [description] Filter response on cost model description.
         * @param {'name' | '-name' | 'source_type' | '-source_type' | 'updated_timestamp' | '-updated_timestamp'} [ordering] Order response on cost model by allowed fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCostModels(offset?: number, limit?: number, providerUuid?: string, sourceType?: string, name?: string, description?: string, ordering?: 'name' | '-name' | 'source_type' | '-source_type' | 'updated_timestamp' | '-updated_timestamp', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostModelPagination> {
            const localVarAxiosArgs = CostModelApiAxiosParamCreator(configuration).listCostModels(offset, limit, providerUuid, sourceType, name, description, ordering, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a Cost Model
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {CostModel} costModel Update to a Cost Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCostModel(costModelUuid: string, costModel: CostModel, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostModelOut> {
            const localVarAxiosArgs = CostModelApiAxiosParamCreator(configuration).updateCostModel(costModelUuid, costModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CostModelApi - factory interface
 * @export
 */
export const CostModelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a new cost model.
         * @param {CostModel} costModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCostModel(costModel: CostModel, options?: any) {
            return CostModelApiFp(configuration).createCostModel(costModel, options)(axios, basePath);
        },
        /**
         *
         * @summary Delete a Cost Model
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCostModel(costModelUuid: string, options?: any) {
            return CostModelApiFp(configuration).deleteCostModel(costModelUuid, options)(axios, basePath);
        },
        /**
         *
         * @summary Get a Cost Model.
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostModel(costModelUuid: string, options?: any) {
            return CostModelApiFp(configuration).getCostModel(costModelUuid, options)(axios, basePath);
        },
        /**
         *
         * @summary List the cost models
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {string} [providerUuid] Filter response on provider uuid.
         * @param {string} [sourceType] Filter response on provider source type.
         * @param {string} [name] Filter response on cost model name.
         * @param {string} [description] Filter response on cost model description.
         * @param {'name' | '-name' | 'source_type' | '-source_type' | 'updated_timestamp' | '-updated_timestamp'} [ordering] Order response on cost model by allowed fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCostModels(offset?: number, limit?: number, providerUuid?: string, sourceType?: string, name?: string, description?: string, ordering?: 'name' | '-name' | 'source_type' | '-source_type' | 'updated_timestamp' | '-updated_timestamp', options?: any) {
            return CostModelApiFp(configuration).listCostModels(offset, limit, providerUuid, sourceType, name, description, ordering, options)(axios, basePath);
        },
        /**
         *
         * @summary Update a Cost Model
         * @param {string} costModelUuid UUID of Cost Model to get
         * @param {CostModel} costModel Update to a Cost Model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCostModel(costModelUuid: string, costModel: CostModel, options?: any) {
            return CostModelApiFp(configuration).updateCostModel(costModelUuid, costModel, options)(axios, basePath);
        },
    };
};

/**
 * CostModelApi - object-oriented interface
 * @export
 * @class CostModelApi
 * @extends {BaseAPI}
 */
export class CostModelApi extends BaseAPI {
    /**
     *
     * @summary Create a new cost model.
     * @param {CostModel} costModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostModelApi
     */
    public createCostModel(costModel: CostModel, options?: any) {
        return CostModelApiFp(this.configuration).createCostModel(costModel, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Delete a Cost Model
     * @param {string} costModelUuid UUID of Cost Model to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostModelApi
     */
    public deleteCostModel(costModelUuid: string, options?: any) {
        return CostModelApiFp(this.configuration).deleteCostModel(costModelUuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Get a Cost Model.
     * @param {string} costModelUuid UUID of Cost Model to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostModelApi
     */
    public getCostModel(costModelUuid: string, options?: any) {
        return CostModelApiFp(this.configuration).getCostModel(costModelUuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary List the cost models
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {string} [providerUuid] Filter response on provider uuid.
     * @param {string} [sourceType] Filter response on provider source type.
     * @param {string} [name] Filter response on cost model name.
     * @param {string} [description] Filter response on cost model description.
     * @param {'name' | '-name' | 'source_type' | '-source_type' | 'updated_timestamp' | '-updated_timestamp'} [ordering] Order response on cost model by allowed fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostModelApi
     */
    public listCostModels(offset?: number, limit?: number, providerUuid?: string, sourceType?: string, name?: string, description?: string, ordering?: 'name' | '-name' | 'source_type' | '-source_type' | 'updated_timestamp' | '-updated_timestamp', options?: any) {
        return CostModelApiFp(this.configuration).listCostModels(offset, limit, providerUuid, sourceType, name, description, ordering, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Update a Cost Model
     * @param {string} costModelUuid UUID of Cost Model to get
     * @param {CostModel} costModel Update to a Cost Model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostModelApi
     */
    public updateCostModel(costModelUuid: string, costModel: CostModel, options?: any) {
        return CostModelApiFp(this.configuration).updateCostModel(costModelUuid, costModel, options)(this.axios, this.basePath);
    }

}

/**
 * DataExportRequestApi - axios parameter creator
 * @export
 */
export const DataExportRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a data export request
         * @param {DataExportRequest} dataExportRequest Data export request to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataExportRequest(dataExportRequest: DataExportRequest, options: any = {}): RequestArgs {
            // verify required parameter 'dataExportRequest' is not null or undefined
            if (dataExportRequest === null || dataExportRequest === undefined) {
                throw new RequiredError('dataExportRequest','Required parameter dataExportRequest was null or undefined when calling createDataExportRequest.');
            }
            const localVarPath = `/dataexportrequests/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DataExportRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dataExportRequest || {}) : (dataExportRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the data export requests
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataExportRequests(offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/dataexportrequests/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a data export request
         * @param {string} uuid ID of data export request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDataExportRequest(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling retrieveDataExportRequest.');
            }
            const localVarPath = `/dataexportrequests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataExportRequestApi - functional programming interface
 * @export
 */
export const DataExportRequestApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a data export request
         * @param {DataExportRequest} dataExportRequest Data export request to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataExportRequest(dataExportRequest: DataExportRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataExportRequestOut> {
            const localVarAxiosArgs = DataExportRequestApiAxiosParamCreator(configuration).createDataExportRequest(dataExportRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List the data export requests
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataExportRequests(offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataExportRequestPagination> {
            const localVarAxiosArgs = DataExportRequestApiAxiosParamCreator(configuration).listDataExportRequests(offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a data export request
         * @param {string} uuid ID of data export request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDataExportRequest(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataExportRequestOut> {
            const localVarAxiosArgs = DataExportRequestApiAxiosParamCreator(configuration).retrieveDataExportRequest(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataExportRequestApi - factory interface
 * @export
 */
export const DataExportRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a data export request
         * @param {DataExportRequest} dataExportRequest Data export request to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataExportRequest(dataExportRequest: DataExportRequest, options?: any) {
            return DataExportRequestApiFp(configuration).createDataExportRequest(dataExportRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary List the data export requests
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataExportRequests(offset?: number, limit?: number, options?: any) {
            return DataExportRequestApiFp(configuration).listDataExportRequests(offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Get a data export request
         * @param {string} uuid ID of data export request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDataExportRequest(uuid: string, options?: any) {
            return DataExportRequestApiFp(configuration).retrieveDataExportRequest(uuid, options)(axios, basePath);
        },
    };
};

/**
 * DataExportRequestApi - object-oriented interface
 * @export
 * @class DataExportRequestApi
 * @extends {BaseAPI}
 */
export class DataExportRequestApi extends BaseAPI {
    /**
     *
     * @summary Create a data export request
     * @param {DataExportRequest} dataExportRequest Data export request to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportRequestApi
     */
    public createDataExportRequest(dataExportRequest: DataExportRequest, options?: any) {
        return DataExportRequestApiFp(this.configuration).createDataExportRequest(dataExportRequest, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary List the data export requests
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportRequestApi
     */
    public listDataExportRequests(offset?: number, limit?: number, options?: any) {
        return DataExportRequestApiFp(this.configuration).listDataExportRequests(offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Get a data export request
     * @param {string} uuid ID of data export request to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportRequestApi
     */
    public retrieveDataExportRequest(uuid: string, options?: any) {
        return DataExportRequestApiFp(this.configuration).retrieveDataExportRequest(uuid, options)(this.axios, this.basePath);
    }

}

/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options: any = {}): RequestArgs {
            const localVarPath = `/metrics/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metrics> {
            const localVarAxiosArgs = MetricsApiAxiosParamCreator(configuration).getMetrics(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Obtain Metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any) {
            return MetricsApiFp(configuration).getMetrics(options)(axios, basePath);
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     *
     * @summary Obtain Metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(options?: any) {
        return MetricsApiFp(this.configuration).getMetrics(options)(this.axios, this.basePath);
    }

}

/**
 * OpenShiftReportApi - axios parameter creator
 * @export
 */
export const OpenShiftReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Query to obtain OpenShift on AWS cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/infrastructures/aws/costs/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (delta !== undefined) {
                localVarQueryParameter['delta'] = delta;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on AWS instance data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSInventoryInstanceReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/infrastructures/aws/instance-types/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSInventoryStorageReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/infrastructures/aws/storage/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/infrastructures/azure/costs/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (delta !== undefined) {
                localVarQueryParameter['delta'] = delta;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure instance data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureInventoryInstanceReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/infrastructures/azure/instance-types/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureInventoryStorageReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/infrastructures/azure/storage/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift compute usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftComputeReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/compute/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/costs/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (delta !== undefined) {
                localVarQueryParameter['delta'] = delta;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift memory usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftMemoryReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/memory/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift volume usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftVolumeReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/reports/openshift/volumes/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenShiftReportApi - functional programming interface
 * @export
 */
export const OpenShiftReportApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Query to obtain OpenShift on AWS cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportCosts> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftAWSCostReports(delta, filter, groupBy, orderBy, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on AWS instance data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSInventoryInstanceReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportOpenShiftAWSInstanceInventory> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftAWSInventoryInstanceReport(filter, groupBy, orderBy, units, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSInventoryStorageReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportOpenShiftAWSStorageInventory> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftAWSInventoryStorageReport(filter, groupBy, orderBy, units, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportCosts> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftAzureCostReports(delta, filter, groupBy, orderBy, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure instance data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureInventoryInstanceReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportOpenShiftAzureInstanceInventory> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftAzureInventoryInstanceReport(filter, groupBy, orderBy, units, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureInventoryStorageReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportOpenShiftAzureStorageInventory> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftAzureInventoryStorageReport(filter, groupBy, orderBy, units, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift compute usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftComputeReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportOpenShiftCpu> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftComputeReports(filter, groupBy, orderBy, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportCost> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftCostReports(delta, filter, groupBy, orderBy, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift memory usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftMemoryReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportOpenShiftMemory> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftMemoryReports(filter, groupBy, orderBy, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift volume usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftVolumeReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportOpenShiftVolume> {
            const localVarAxiosArgs = OpenShiftReportApiAxiosParamCreator(configuration).getOpenShiftVolumeReports(filter, groupBy, orderBy, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OpenShiftReportApi - factory interface
 * @export
 */
export const OpenShiftReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Query to obtain OpenShift on AWS cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftAWSCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift on AWS instance data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSInventoryInstanceReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftAWSInventoryInstanceReport(filter, groupBy, orderBy, units, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift on AWS storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSInventoryStorageReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftAWSInventoryStorageReport(filter, groupBy, orderBy, units, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftAzureCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure instance data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureInventoryInstanceReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftAzureInventoryInstanceReport(filter, groupBy, orderBy, units, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift on Azure storage data
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {string} [units] The units used to report data.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureInventoryStorageReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftAzureInventoryStorageReport(filter, groupBy, orderBy, units, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift compute usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftComputeReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftComputeReports(filter, groupBy, orderBy, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain cost reports
         * @param {string} [delta] Toggle to include delta values in report.
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift memory usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftMemoryReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftMemoryReports(filter, groupBy, orderBy, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift volume usage information
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
         * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftVolumeReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
            return OpenShiftReportApiFp(configuration).getOpenShiftVolumeReports(filter, groupBy, orderBy, offset, limit, options)(axios, basePath);
        },
    };
};

/**
 * OpenShiftReportApi - object-oriented interface
 * @export
 * @class OpenShiftReportApi
 * @extends {BaseAPI}
 */
export class OpenShiftReportApi extends BaseAPI {
    /**
     *
     * @summary Query to obtain OpenShift on AWS cost reports
     * @param {string} [delta] Toggle to include delta values in report.
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftAWSCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftAWSCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift on AWS instance data
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {string} [units] The units used to report data.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftAWSInventoryInstanceReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftAWSInventoryInstanceReport(filter, groupBy, orderBy, units, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift on AWS storage data
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {string} [units] The units used to report data.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftAWSInventoryStorageReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftAWSInventoryStorageReport(filter, groupBy, orderBy, units, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift on Azure cost reports
     * @param {string} [delta] Toggle to include delta values in report.
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftAzureCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftAzureCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift on Azure instance data
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {string} [units] The units used to report data.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftAzureInventoryInstanceReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftAzureInventoryInstanceReport(filter, groupBy, orderBy, units, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift on Azure storage data
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {string} [units] The units used to report data.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftAzureInventoryStorageReport(filter?: any, groupBy?: any, orderBy?: any, units?: string, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftAzureInventoryStorageReport(filter, groupBy, orderBy, units, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift compute usage information
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftComputeReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftComputeReports(filter, groupBy, orderBy, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain cost reports
     * @param {string} [delta] Toggle to include delta values in report.
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftCostReports(delta?: string, filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftCostReports(delta, filter, groupBy, orderBy, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift memory usage information
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftMemoryReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftMemoryReports(filter, groupBy, orderBy, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift volume usage information
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {any} [groupBy] The grouping to apply to the report as a URL encoded dictionary.
     * @param {any} [orderBy] The ordering to apply to the report as a URL encoded dictionary.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenShiftReportApi
     */
    public getOpenShiftVolumeReports(filter?: any, groupBy?: any, orderBy?: any, offset?: number, limit?: number, options?: any) {
        return OpenShiftReportApiFp(this.configuration).getOpenShiftVolumeReports(filter, groupBy, orderBy, offset, limit, options)(this.axios, this.basePath);
    }

}

/**
 * ProviderApi - axios parameter creator
 * @export
 */
export const ProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a provider
         * @param {ProviderIn} providerIn Provider to add to a Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProvider(providerIn: ProviderIn, options: any = {}): RequestArgs {
            // verify required parameter 'providerIn' is not null or undefined
            if (providerIn === null || providerIn === undefined) {
                throw new RequiredError('providerIn','Required parameter providerIn was null or undefined when calling createProvider.');
            }
            const localVarPath = `/providers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProviderIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(providerIn || {}) : (providerIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a provider
         * @param {string} uuid ID of provider to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvider(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteProvider.');
            }
            const localVarPath = `/providers/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a provider
         * @param {string} uuid ID of provider to get
         * @param {'true' | 'false'} [stats] Include provider status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(uuid: string, stats?: 'true' | 'false', options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getProvider.');
            }
            const localVarPath = `/providers/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (stats !== undefined) {
                localVarQueryParameter['stats'] = stats;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the providers
         * @param {string} [type] The type of provider to filter for.
         * @param {string} [name] The name of the provider to filter for.
         * @param {'true' | 'false'} [stats] Include provider status
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviders(type?: string, name?: string, stats?: 'true' | 'false', offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/providers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (stats !== undefined) {
                localVarQueryParameter['stats'] = stats;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a provider
         * @param {string} uuid ID of provider to update
         * @param {ProviderIn} providerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProvider(uuid: string, providerIn: ProviderIn, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateProvider.');
            }
            // verify required parameter 'providerIn' is not null or undefined
            if (providerIn === null || providerIn === undefined) {
                throw new RequiredError('providerIn','Required parameter providerIn was null or undefined when calling updateProvider.');
            }
            const localVarPath = `/providers/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProviderIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(providerIn || {}) : (providerIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderApi - functional programming interface
 * @export
 */
export const ProviderApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a provider
         * @param {ProviderIn} providerIn Provider to add to a Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProvider(providerIn: ProviderIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderOut> {
            const localVarAxiosArgs = ProviderApiAxiosParamCreator(configuration).createProvider(providerIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a provider
         * @param {string} uuid ID of provider to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvider(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ProviderApiAxiosParamCreator(configuration).deleteProvider(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a provider
         * @param {string} uuid ID of provider to get
         * @param {'true' | 'false'} [stats] Include provider status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(uuid: string, stats?: 'true' | 'false', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderOut> {
            const localVarAxiosArgs = ProviderApiAxiosParamCreator(configuration).getProvider(uuid, stats, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List the providers
         * @param {string} [type] The type of provider to filter for.
         * @param {string} [name] The name of the provider to filter for.
         * @param {'true' | 'false'} [stats] Include provider status
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviders(type?: string, name?: string, stats?: 'true' | 'false', offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderPagination> {
            const localVarAxiosArgs = ProviderApiAxiosParamCreator(configuration).listProviders(type, name, stats, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a provider
         * @param {string} uuid ID of provider to update
         * @param {ProviderIn} providerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProvider(uuid: string, providerIn: ProviderIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderOut> {
            const localVarAxiosArgs = ProviderApiAxiosParamCreator(configuration).updateProvider(uuid, providerIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProviderApi - factory interface
 * @export
 */
export const ProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a provider
         * @param {ProviderIn} providerIn Provider to add to a Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProvider(providerIn: ProviderIn, options?: any) {
            return ProviderApiFp(configuration).createProvider(providerIn, options)(axios, basePath);
        },
        /**
         *
         * @summary Delete a provider
         * @param {string} uuid ID of provider to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvider(uuid: string, options?: any) {
            return ProviderApiFp(configuration).deleteProvider(uuid, options)(axios, basePath);
        },
        /**
         *
         * @summary Get a provider
         * @param {string} uuid ID of provider to get
         * @param {'true' | 'false'} [stats] Include provider status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvider(uuid: string, stats?: 'true' | 'false', options?: any) {
            return ProviderApiFp(configuration).getProvider(uuid, stats, options)(axios, basePath);
        },
        /**
         *
         * @summary List the providers
         * @param {string} [type] The type of provider to filter for.
         * @param {string} [name] The name of the provider to filter for.
         * @param {'true' | 'false'} [stats] Include provider status
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProviders(type?: string, name?: string, stats?: 'true' | 'false', offset?: number, limit?: number, options?: any) {
            return ProviderApiFp(configuration).listProviders(type, name, stats, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Update a provider
         * @param {string} uuid ID of provider to update
         * @param {ProviderIn} providerIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProvider(uuid: string, providerIn: ProviderIn, options?: any) {
            return ProviderApiFp(configuration).updateProvider(uuid, providerIn, options)(axios, basePath);
        },
    };
};

/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
export class ProviderApi extends BaseAPI {
    /**
     *
     * @summary Create a provider
     * @param {ProviderIn} providerIn Provider to add to a Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public createProvider(providerIn: ProviderIn, options?: any) {
        return ProviderApiFp(this.configuration).createProvider(providerIn, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Delete a provider
     * @param {string} uuid ID of provider to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public deleteProvider(uuid: string, options?: any) {
        return ProviderApiFp(this.configuration).deleteProvider(uuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Get a provider
     * @param {string} uuid ID of provider to get
     * @param {'true' | 'false'} [stats] Include provider status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public getProvider(uuid: string, stats?: 'true' | 'false', options?: any) {
        return ProviderApiFp(this.configuration).getProvider(uuid, stats, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary List the providers
     * @param {string} [type] The type of provider to filter for.
     * @param {string} [name] The name of the provider to filter for.
     * @param {'true' | 'false'} [stats] Include provider status
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public listProviders(type?: string, name?: string, stats?: 'true' | 'false', offset?: number, limit?: number, options?: any) {
        return ProviderApiFp(this.configuration).listProviders(type, name, stats, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Update a provider
     * @param {string} uuid ID of provider to update
     * @param {ProviderIn} providerIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    public updateProvider(uuid: string, providerIn: ProviderIn, options?: any) {
        return ProviderApiFp(this.configuration).updateProvider(uuid, providerIn, options)(this.axios, this.basePath);
    }

}

/**
 * SourcesApi - axios parameter creator
 * @export
 */
export const SourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a source
         * @param {number} sourceId ID of source to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(sourceId: number, options: any = {}): RequestArgs {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling getSource.');
            }
            const localVarPath = `/sources/{source_id}/`
                .replace(`{${"source_id"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(options: any = {}): RequestArgs {
            const localVarPath = `/sources/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a source
         * @param {number} sourceId ID of source to update
         * @param {SourceIn} sourceIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(sourceId: number, sourceIn: SourceIn, options: any = {}): RequestArgs {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling updateSource.');
            }
            // verify required parameter 'sourceIn' is not null or undefined
            if (sourceIn === null || sourceIn === undefined) {
                throw new RequiredError('sourceIn','Required parameter sourceIn was null or undefined when calling updateSource.');
            }
            const localVarPath = `/sources/{source_id}/`
                .replace(`{${"source_id"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SourceIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sourceIn || {}) : (sourceIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a source
         * @param {number} sourceId ID of source to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(sourceId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceOut> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).getSource(sourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List the sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourcePagination> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).listSources(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a source
         * @param {number} sourceId ID of source to update
         * @param {SourceIn} sourceIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(sourceId: number, sourceIn: SourceIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceOut> {
            const localVarAxiosArgs = SourcesApiAxiosParamCreator(configuration).updateSource(sourceId, sourceIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Get a source
         * @param {number} sourceId ID of source to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(sourceId: number, options?: any) {
            return SourcesApiFp(configuration).getSource(sourceId, options)(axios, basePath);
        },
        /**
         *
         * @summary List the sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(options?: any) {
            return SourcesApiFp(configuration).listSources(options)(axios, basePath);
        },
        /**
         *
         * @summary Update a source
         * @param {number} sourceId ID of source to update
         * @param {SourceIn} sourceIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(sourceId: number, sourceIn: SourceIn, options?: any) {
            return SourcesApiFp(configuration).updateSource(sourceId, sourceIn, options)(axios, basePath);
        },
    };
};

/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     *
     * @summary Get a source
     * @param {number} sourceId ID of source to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSource(sourceId: number, options?: any) {
        return SourcesApiFp(this.configuration).getSource(sourceId, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary List the sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listSources(options?: any) {
        return SourcesApiFp(this.configuration).listSources(options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Update a source
     * @param {number} sourceId ID of source to update
     * @param {SourceIn} sourceIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSource(sourceId: number, sourceIn: SourceIn, options?: any) {
        return SourcesApiFp(this.configuration).updateSource(sourceId, sourceIn, options)(this.axios, this.basePath);
    }

}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options: any = {}): RequestArgs {
            const localVarPath = `/status/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status> {
            const localVarAxiosArgs = StatusApiAxiosParamCreator(configuration).getStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any) {
            return StatusApiFp(configuration).getStatus(options)(axios, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     *
     * @summary Obtain server status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatus(options?: any) {
        return StatusApiFp(this.configuration).getStatus(options)(this.axios, this.basePath);
    }

}

/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Query to obtain AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/tags/aws/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (keyOnly !== undefined) {
                localVarQueryParameter['key_only'] = keyOnly;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/tags/azure/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (keyOnly !== undefined) {
                localVarQueryParameter['key_only'] = keyOnly;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift-on-AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/tags/openshift/infrastructures/aws/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (keyOnly !== undefined) {
                localVarQueryParameter['key_only'] = keyOnly;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift-on-Azure tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/tags/openshift/infrastructures/azure/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (keyOnly !== undefined) {
                localVarQueryParameter['key_only'] = keyOnly;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/tags/openshift/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (keyOnly !== undefined) {
                localVarQueryParameter['key_only'] = keyOnly;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Query to obtain AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).getAWSTagData(filter, keyOnly, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).getAzureTagData(filter, keyOnly, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift-on-AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).getOpenShiftAWSTagData(filter, keyOnly, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift-on-Azure tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).getOpenShiftAzureTagData(filter, keyOnly, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Query to obtain OpenShift tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).getOpenShiftTagData(filter, keyOnly, offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Query to obtain AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAWSTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
            return TagsApiFp(configuration).getAWSTagData(filter, keyOnly, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
            return TagsApiFp(configuration).getAzureTagData(filter, keyOnly, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift-on-AWS tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAWSTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
            return TagsApiFp(configuration).getOpenShiftAWSTagData(filter, keyOnly, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift-on-Azure tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftAzureTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
            return TagsApiFp(configuration).getOpenShiftAzureTagData(filter, keyOnly, offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Query to obtain OpenShift tags
         * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
         * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenShiftTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
            return TagsApiFp(configuration).getOpenShiftTagData(filter, keyOnly, offset, limit, options)(axios, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     *
     * @summary Query to obtain AWS tags
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getAWSTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
        return TagsApiFp(this.configuration).getAWSTagData(filter, keyOnly, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain AWS tags
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getAzureTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
        return TagsApiFp(this.configuration).getAzureTagData(filter, keyOnly, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift-on-AWS tags
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getOpenShiftAWSTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
        return TagsApiFp(this.configuration).getOpenShiftAWSTagData(filter, keyOnly, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift-on-Azure tags
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getOpenShiftAzureTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
        return TagsApiFp(this.configuration).getOpenShiftAzureTagData(filter, keyOnly, offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Query to obtain OpenShift tags
     * @param {any} [filter] The filter to apply to the report as a URL encoded dictionary.
     * @param {boolean} [keyOnly] Flag to indicate whether or not only the tag key values will be returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getOpenShiftTagData(filter?: any, keyOnly?: boolean, offset?: number, limit?: number, options?: any) {
        return TagsApiFp(this.configuration).getOpenShiftTagData(filter, keyOnly, offset, limit, options)(this.axios, this.basePath);
    }

}

/**
 * UserPreferenceApi - axios parameter creator
 * @export
 */
export const UserPreferenceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a user preference
         * @param {UserPreference} userPreference Preference to add to a Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPreference(userPreference: UserPreference, options: any = {}): RequestArgs {
            // verify required parameter 'userPreference' is not null or undefined
            if (userPreference === null || userPreference === undefined) {
                throw new RequiredError('userPreference','Required parameter userPreference was null or undefined when calling createUserPreference.');
            }
            const localVarPath = `/preferences/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserPreference" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userPreference || {}) : (userPreference || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPreference(prefUuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'prefUuid' is not null or undefined
            if (prefUuid === null || prefUuid === undefined) {
                throw new RequiredError('prefUuid','Required parameter prefUuid was null or undefined when calling deleteUserPreference.');
            }
            const localVarPath = `/preferences/{pref_uuid}/`
                .replace(`{${"pref_uuid"}}`, encodeURIComponent(String(prefUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreference(prefUuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'prefUuid' is not null or undefined
            if (prefUuid === null || prefUuid === undefined) {
                throw new RequiredError('prefUuid','Required parameter prefUuid was null or undefined when calling getUserPreference.');
            }
            const localVarPath = `/preferences/{pref_uuid}/`
                .replace(`{${"pref_uuid"}}`, encodeURIComponent(String(prefUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the user's preferences
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences(offset?: number, limit?: number, options: any = {}): RequestArgs {
            const localVarPath = `/preferences/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {UserPreference} userPreference Update to a Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreference(prefUuid: string, userPreference: UserPreference, options: any = {}): RequestArgs {
            // verify required parameter 'prefUuid' is not null or undefined
            if (prefUuid === null || prefUuid === undefined) {
                throw new RequiredError('prefUuid','Required parameter prefUuid was null or undefined when calling updateUserPreference.');
            }
            // verify required parameter 'userPreference' is not null or undefined
            if (userPreference === null || userPreference === undefined) {
                throw new RequiredError('userPreference','Required parameter userPreference was null or undefined when calling updateUserPreference.');
            }
            const localVarPath = `/preferences/{pref_uuid}/`
                .replace(`{${"pref_uuid"}}`, encodeURIComponent(String(prefUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserPreference" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userPreference || {}) : (userPreference || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPreferenceApi - functional programming interface
 * @export
 */
export const UserPreferenceApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a user preference
         * @param {UserPreference} userPreference Preference to add to a Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPreference(userPreference: UserPreference, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferenceOut> {
            const localVarAxiosArgs = UserPreferenceApiAxiosParamCreator(configuration).createUserPreference(userPreference, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPreference(prefUuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UserPreferenceApiAxiosParamCreator(configuration).deleteUserPreference(prefUuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreference(prefUuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferenceOut> {
            const localVarAxiosArgs = UserPreferenceApiAxiosParamCreator(configuration).getUserPreference(prefUuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary List the user's preferences
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences(offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferencePagination> {
            const localVarAxiosArgs = UserPreferenceApiAxiosParamCreator(configuration).listUserPreferences(offset, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {UserPreference} userPreference Update to a Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreference(prefUuid: string, userPreference: UserPreference, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UserPreferenceApiAxiosParamCreator(configuration).updateUserPreference(prefUuid, userPreference, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserPreferenceApi - factory interface
 * @export
 */
export const UserPreferenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a user preference
         * @param {UserPreference} userPreference Preference to add to a Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserPreference(userPreference: UserPreference, options?: any) {
            return UserPreferenceApiFp(configuration).createUserPreference(userPreference, options)(axios, basePath);
        },
        /**
         *
         * @summary Delete a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPreference(prefUuid: string, options?: any) {
            return UserPreferenceApiFp(configuration).deleteUserPreference(prefUuid, options)(axios, basePath);
        },
        /**
         *
         * @summary Get a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreference(prefUuid: string, options?: any) {
            return UserPreferenceApiFp(configuration).getUserPreference(prefUuid, options)(axios, basePath);
        },
        /**
         *
         * @summary List the user's preferences
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {number} [limit] Parameter for selecting the amount of data in a returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences(offset?: number, limit?: number, options?: any) {
            return UserPreferenceApiFp(configuration).listUserPreferences(offset, limit, options)(axios, basePath);
        },
        /**
         *
         * @summary Update a user preference
         * @param {string} prefUuid ID of preference to get
         * @param {UserPreference} userPreference Update to a Preference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreference(prefUuid: string, userPreference: UserPreference, options?: any) {
            return UserPreferenceApiFp(configuration).updateUserPreference(prefUuid, userPreference, options)(axios, basePath);
        },
    };
};

/**
 * UserPreferenceApi - object-oriented interface
 * @export
 * @class UserPreferenceApi
 * @extends {BaseAPI}
 */
export class UserPreferenceApi extends BaseAPI {
    /**
     *
     * @summary Create a user preference
     * @param {UserPreference} userPreference Preference to add to a Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferenceApi
     */
    public createUserPreference(userPreference: UserPreference, options?: any) {
        return UserPreferenceApiFp(this.configuration).createUserPreference(userPreference, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Delete a user preference
     * @param {string} prefUuid ID of preference to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferenceApi
     */
    public deleteUserPreference(prefUuid: string, options?: any) {
        return UserPreferenceApiFp(this.configuration).deleteUserPreference(prefUuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Get a user preference
     * @param {string} prefUuid ID of preference to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferenceApi
     */
    public getUserPreference(prefUuid: string, options?: any) {
        return UserPreferenceApiFp(this.configuration).getUserPreference(prefUuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary List the user's preferences
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {number} [limit] Parameter for selecting the amount of data in a returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferenceApi
     */
    public listUserPreferences(offset?: number, limit?: number, options?: any) {
        return UserPreferenceApiFp(this.configuration).listUserPreferences(offset, limit, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Update a user preference
     * @param {string} prefUuid ID of preference to get
     * @param {UserPreference} userPreference Update to a Preference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferenceApi
     */
    public updateUserPreference(prefUuid: string, userPreference: UserPreference, options?: any) {
        return UserPreferenceApiFp(this.configuration).updateUserPreference(prefUuid, userPreference, options)(this.axios, this.basePath);
    }

}

