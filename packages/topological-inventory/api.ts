// tslint:disable
/**
 * Topological Inventory
 * Topological Inventory
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template condition
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AppliedInventoriesParametersServicePlan
 */
export interface AppliedInventoriesParametersServicePlan {
    /**
     * The provider specific parameters needed to compute list of used service inventorie
     * @type {object}
     * @memberof AppliedInventoriesParametersServicePlan
     */
    service_parameters?: object;
}
/**
 * 
 * @export
 * @interface AvailabilitiesCollection
 */
export interface AvailabilitiesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof AvailabilitiesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof AvailabilitiesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Availability>}
     * @memberof AvailabilitiesCollection
     */
    data?: Array<Availability>;
}
/**
 * 
 * @export
 * @interface Availability
 */
export interface Availability {
    /**
     * 
     * @type {string}
     * @memberof Availability
     */
    action?: string;
    /**
     * 
     * @type {string}
     * @memberof Availability
     */
    availability?: string;
    /**
     * 
     * @type {string}
     * @memberof Availability
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Availability
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Availability
     */
    identifier?: string;
    /**
     * 
     * @type {string}
     * @memberof Availability
     */
    last_checked_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Availability
     */
    last_valid_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Availability
     */
    resource_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Availability
     */
    resource_type?: string;
    /**
     * 
     * @type {string}
     * @memberof Availability
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    created_at?: string;
    /**
     * 
     * @type {object}
     * @memberof Cluster
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Cluster
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Cluster
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    uid_ems?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ClustersCollection
 */
export interface ClustersCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ClustersCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ClustersCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Cluster>}
     * @memberof ClustersCollection
     */
    data?: Array<Cluster>;
}
/**
 * 
 * @export
 * @interface CollectionLink
 */
export interface CollectionLinks {
    /**
     * 
     * @type {string}
     * @memberof CollectionLink
     */
    first?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionLink
     */
    last?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionLink
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof CollectionLink
     */
    prev?: string;
}
/**
 * 
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     * 
     * @type {number}
     * @memberof CollectionMetadata
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetadata
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetadata
     */
    offset?: number;
}
/**
 * 
 * @export
 * @interface Container
 */
export interface Container {
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    archived_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Container
     */
    container_group_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Container
     */
    container_image_id?: string;
    /**
     * 
     * @type {number}
     * @memberof Container
     */
    cpu_limit?: number;
    /**
     * 
     * @type {number}
     * @memberof Container
     */
    cpu_request?: number;
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Container
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    last_seen_at?: string;
    /**
     * 
     * @type {number}
     * @memberof Container
     */
    memory_limit?: number;
    /**
     * 
     * @type {number}
     * @memberof Container
     */
    memory_request?: number;
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Container
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ContainerGroup
 */
export interface ContainerGroup {
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    archived_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerGroup
     */
    container_node_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerGroup
     */
    container_project_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerGroup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    ipaddress?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    resource_version?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerGroup
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerGroup
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ContainerGroupsCollection
 */
export interface ContainerGroupsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ContainerGroupsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ContainerGroupsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ContainerGroup>}
     * @memberof ContainerGroupsCollection
     */
    data?: Array<ContainerGroup>;
}
/**
 * 
 * @export
 * @interface ContainerImage
 */
export interface ContainerImage {
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerImage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    resource_version?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerImage
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ContainerImagesCollection
 */
export interface ContainerImagesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ContainerImagesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ContainerImagesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ContainerImage>}
     * @memberof ContainerImagesCollection
     */
    data?: Array<ContainerImage>;
}
/**
 * 
 * @export
 * @interface ContainerNode
 */
export interface ContainerNode {
    /**
     * 
     * @type {object}
     * @memberof ContainerNode
     */
    addresses?: object;
    /**
     * 
     * @type {number}
     * @memberof ContainerNode
     */
    allocatable_cpus?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerNode
     */
    allocatable_memory?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerNode
     */
    allocatable_pods?: number;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    archived_at?: string;
    /**
     * 
     * @type {object}
     * @memberof ContainerNode
     */
    conditions?: object;
    /**
     * 
     * @type {number}
     * @memberof ContainerNode
     */
    cpus?: number;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerNode
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    last_seen_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerNode
     */
    lives_on_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    lives_on_type?: string;
    /**
     * 
     * @type {number}
     * @memberof ContainerNode
     */
    memory?: number;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    name?: string;
    /**
     * 
     * @type {object}
     * @memberof ContainerNode
     */
    node_info?: object;
    /**
     * 
     * @type {number}
     * @memberof ContainerNode
     */
    pods?: number;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    resource_version?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerNode
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerNode
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ContainerNodesCollection
 */
export interface ContainerNodesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ContainerNodesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ContainerNodesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ContainerNode>}
     * @memberof ContainerNodesCollection
     */
    data?: Array<ContainerNode>;
}
/**
 * 
 * @export
 * @interface ContainerProject
 */
export interface ContainerProject {
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    display_name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerProject
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    resource_version?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerProject
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    status_phase?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProject
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ContainerProjectsCollection
 */
export interface ContainerProjectsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ContainerProjectsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ContainerProjectsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ContainerProject>}
     * @memberof ContainerProjectsCollection
     */
    data?: Array<ContainerProject>;
}
/**
 * 
 * @export
 * @interface ContainerResourceQuota
 */
export interface ContainerResourceQuota {
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    archived_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    container_project_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    resource_version?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    source_ref?: string;
    /**
     * 
     * @type {object}
     * @memberof ContainerResourceQuota
     */
    spec?: object;
    /**
     * 
     * @type {object}
     * @memberof ContainerResourceQuota
     */
    status?: object;
    /**
     * 
     * @type {string}
     * @memberof ContainerResourceQuota
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ContainerResourceQuotaCollection
 */
export interface ContainerResourceQuotaCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ContainerResourceQuotaCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ContainerResourceQuotaCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ContainerResourceQuota>}
     * @memberof ContainerResourceQuotaCollection
     */
    data?: Array<ContainerResourceQuota>;
}
/**
 * 
 * @export
 * @interface ContainerTemplate
 */
export interface ContainerTemplate {
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    archived_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerTemplate
     */
    container_project_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerTemplate
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    resource_version?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ContainerTemplate
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerTemplate
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ContainerTemplatesCollection
 */
export interface ContainerTemplatesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ContainerTemplatesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ContainerTemplatesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ContainerTemplate>}
     * @memberof ContainerTemplatesCollection
     */
    data?: Array<ContainerTemplate>;
}
/**
 * 
 * @export
 * @interface ContainersCollection
 */
export interface ContainersCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ContainersCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ContainersCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Container>}
     * @memberof ContainersCollection
     */
    data?: Array<Container>;
}
/**
 * 
 * @export
 * @interface Datastore
 */
export interface Datastore {
    /**
     * 
     * @type {boolean}
     * @memberof Datastore
     */
    accessible?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    created_at?: string;
    /**
     * 
     * @type {object}
     * @memberof Datastore
     */
    extra?: object;
    /**
     * 
     * @type {number}
     * @memberof Datastore
     */
    free_space?: number;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Datastore
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Datastore
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof Datastore
     */
    total_space?: number;
    /**
     * 
     * @type {string}
     * @memberof Datastore
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface DatastoresCollection
 */
export interface DatastoresCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof DatastoresCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof DatastoresCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Datastore>}
     * @memberof DatastoresCollection
     */
    data?: Array<Datastore>;
}
/**
 * 
 * @export
 * @interface ErrorNotFound
 */
export interface ErrorNotFound {
    /**
     * 
     * @type {Array<ErrorNotFoundErrors>}
     * @memberof ErrorNotFound
     */
    errors?: Array<ErrorNotFoundErrors>;
}
/**
 * 
 * @export
 * @interface ErrorNotFoundError
 */
export interface ErrorNotFoundErrors {
    /**
     * 
     * @type {number}
     * @memberof ErrorNotFoundError
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorNotFoundError
     */
    detail?: string;
}
/**
 * 
 * @export
 * @interface Flavor
 */
export interface Flavor {
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    archived_at?: string;
    /**
     * Number of CPU
     * @type {number}
     * @memberof Flavor
     */
    cpus?: number;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    created_at?: string;
    /**
     * The number of default disk
     * @type {number}
     * @memberof Flavor
     */
    disk_count?: number;
    /**
     * Size of the default disks in byte
     * @type {number}
     * @memberof Flavor
     */
    disk_size?: number;
    /**
     * 
     * @type {object}
     * @memberof Flavor
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Flavor
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    last_seen_at?: string;
    /**
     * Amount of RAM in byte
     * @type {number}
     * @memberof Flavor
     */
    memory?: number;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Flavor
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof Flavor
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface FlavorsCollection
 */
export interface FlavorsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof FlavorsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof FlavorsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Flavor>}
     * @memberof FlavorsCollection
     */
    data?: Array<Flavor>;
}
/**
 * 
 * @export
 * @interface GraphQLRequest
 */
export interface GraphQLRequest {
    /**
     * The GraphQL query
     * @type {string}
     * @memberof GraphQLRequest
     */
    query: string;
    /**
     * If the Query contains several named operations, the operationName controls which one should be executed
     * @type {string}
     * @memberof GraphQLRequest
     */
    operationName?: string;
    /**
     * Optional Query variable
     * @type {object}
     * @memberof GraphQLRequest
     */
    variables?: object | null;
}
/**
 * 
 * @export
 * @interface GraphQLResponse
 */
export interface GraphQLResponse {
    /**
     * Results from the GraphQL query
     * @type {object}
     * @memberof GraphQLResponse
     */
    data?: object;
    /**
     * Errors resulting from the GraphQL query
     * @type {Array<object>}
     * @memberof GraphQLResponse
     */
    errors?: Array<object>;
}
/**
 * 
 * @export
 * @interface Host
 */
export interface Host {
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    archived_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Host
     */
    cluster_id?: string;
    /**
     * 
     * @type {number}
     * @memberof Host
     */
    cpus?: number;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof Host
     */
    extra?: object;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    hostname?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Host
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    last_seen_at?: string;
    /**
     * 
     * @type {number}
     * @memberof Host
     */
    memory?: number;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    power_state?: string;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Host
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    uid_ems?: string;
    /**
     * 
     * @type {string}
     * @memberof Host
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface HostsCollection
 */
export interface HostsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof HostsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof HostsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Host>}
     * @memberof HostsCollection
     */
    data?: Array<Host>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    task_id?: string;
}
/**
 * 
 * @export
 * @interface Ipaddre
 */
export interface Ipaddress {
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    created_at?: string;
    /**
     * 
     * @type {object}
     * @memberof Ipaddre
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Ipaddre
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    ipaddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    last_seen_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Ipaddre
     */
    network_adapter_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Ipaddre
     */
    orchestration_stack_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Ipaddre
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Ipaddre
     */
    source_region_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Ipaddre
     */
    subnet_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Ipaddre
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Ipaddre
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface IpaddressesCollection
 */
export interface IpaddressesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof IpaddressesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof IpaddressesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Ipaddress>}
     * @memberof IpaddressesCollection
     */
    data?: Array<Ipaddress>;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    cidr?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    created_at?: string;
    /**
     * 
     * @type {object}
     * @memberof Network
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Network
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Network
     */
    orchestration_stack_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Network
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Network
     */
    source_region_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    status?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Network
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface NetworkAdapter
 */
export interface NetworkAdapter {
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof NetworkAdapter
     */
    device_id?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    device_type?: string;
    /**
     * 
     * @type {object}
     * @memberof NetworkAdapter
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof NetworkAdapter
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    mac_address?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof NetworkAdapter
     */
    orchestration_stack_id?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof NetworkAdapter
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof NetworkAdapter
     */
    source_region_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof NetworkAdapter
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface NetworkAdaptersCollection
 */
export interface NetworkAdaptersCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof NetworkAdaptersCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof NetworkAdaptersCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<NetworkAdapter>}
     * @memberof NetworkAdaptersCollection
     */
    data?: Array<NetworkAdapter>;
}
/**
 * 
 * @export
 * @interface NetworksCollection
 */
export interface NetworksCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof NetworksCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof NetworksCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Network>}
     * @memberof NetworksCollection
     */
    data?: Array<Network>;
}
/**
 * 
 * @export
 * @interface OrchestrationStack
 */
export interface OrchestrationStack {
    /**
     * 
     * @type {string}
     * @memberof OrchestrationStack
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof OrchestrationStack
     */
    created_at?: string;
    /**
     * Description of the OrchestrationStack
     * @type {string}
     * @memberof OrchestrationStack
     */
    description?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof OrchestrationStack
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrchestrationStack
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof OrchestrationStack
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof OrchestrationStack
     */
    parent_orchestration_stack_id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrchestrationStack
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof OrchestrationStack
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof OrchestrationStack
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrchestrationStack
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof OrchestrationStack
     */
    source_region_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof OrchestrationStack
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrchestrationStack
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface OrchestrationStacksCollection
 */
export interface OrchestrationStacksCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof OrchestrationStacksCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof OrchestrationStacksCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<OrchestrationStack>}
     * @memberof OrchestrationStacksCollection
     */
    data?: Array<OrchestrationStack>;
}
/**
 * 
 * @export
 * @interface OrderParametersServiceOffering
 */
export interface OrderParametersServiceOffering {
    /**
     * JSON object with provisioning parameter
     * @type {object}
     * @memberof OrderParametersServiceOffering
     */
    service_parameters?: object;
    /**
     * The provider specific parameters needed to provision this service. This might include namespaces, special key
     * @type {object}
     * @memberof OrderParametersServiceOffering
     */
    provider_control_parameters?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof OrderParametersServiceOffering
     */
    service_plan_id?: string;
}
/**
 * 
 * @export
 * @interface OrderParametersServicePlan
 */
export interface OrderParametersServicePlan {
    /**
     * JSON object with provisioning parameter
     * @type {object}
     * @memberof OrderParametersServicePlan
     */
    service_parameters?: object;
    /**
     * The provider specific parameters needed to provision this service. This might include namespaces, special key
     * @type {object}
     * @memberof OrderParametersServicePlan
     */
    provider_control_parameters?: object;
}
/**
 * 
 * @export
 * @interface SecurityGroup
 */
export interface SecurityGroup {
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof SecurityGroup
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof SecurityGroup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof SecurityGroup
     */
    network_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof SecurityGroup
     */
    orchestration_stack_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof SecurityGroup
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof SecurityGroup
     */
    source_region_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof SecurityGroup
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface SecurityGroupsCollection
 */
export interface SecurityGroupsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof SecurityGroupsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof SecurityGroupsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<SecurityGroup>}
     * @memberof SecurityGroupsCollection
     */
    data?: Array<SecurityGroup>;
}
/**
 * 
 * @export
 * @interface ServiceInstance
 */
export interface ServiceInstance {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    external_url?: string;
    /**
     * Extra information about this object in JSON format
     * @type {object}
     * @memberof ServiceInstance
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    root_service_instance_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    service_inventory_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    service_offering_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    service_plan_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    source_region_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstance
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstance
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ServiceInstanceNode
 */
export interface ServiceInstanceNode {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    created_at?: string;
    /**
     * 
     * @type {object}
     * @memberof ServiceInstanceNode
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    root_service_instance_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    service_instance_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    service_inventory_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    source_created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    source_updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceNode
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ServiceInstanceNodesCollection
 */
export interface ServiceInstanceNodesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ServiceInstanceNodesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ServiceInstanceNodesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ServiceInstanceNode>}
     * @memberof ServiceInstanceNodesCollection
     */
    data?: Array<ServiceInstanceNode>;
}
/**
 * 
 * @export
 * @interface ServiceInstancesCollection
 */
export interface ServiceInstancesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ServiceInstancesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ServiceInstancesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ServiceInstance>}
     * @memberof ServiceInstancesCollection
     */
    data?: Array<ServiceInstance>;
}
/**
 * 
 * @export
 * @interface ServiceInventoriesCollection
 */
export interface ServiceInventoriesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ServiceInventoriesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ServiceInventoriesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ServiceInventory>}
     * @memberof ServiceInventoriesCollection
     */
    data?: Array<ServiceInventory>;
}
/**
 * 
 * @export
 * @interface ServiceInventory
 */
export interface ServiceInventory {
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof ServiceInventory
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInventory
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    source_created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceInventory
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    source_updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInventory
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ServiceOffering
 */
export interface ServiceOffering {
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    display_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    distributor?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    documentation_url?: string;
    /**
     * Extra information about this object in JSON format
     * @type {object}
     * @memberof ServiceOffering
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    long_description?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    service_inventory_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    service_offering_icon_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    source_id?: string;
    /**
     * The native reference used by the Source to refer to this object
     * @type {string}
     * @memberof ServiceOffering
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    source_region_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOffering
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    support_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOffering
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ServiceOfferingIcon
 */
export interface ServiceOfferingIcon {
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    created_at?: string;
    /**
     * Raw icon data
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    data?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    last_seen_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingIcon
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ServiceOfferingIconsCollection
 */
export interface ServiceOfferingIconsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ServiceOfferingIconsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ServiceOfferingIconsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ServiceOfferingIcon>}
     * @memberof ServiceOfferingIconsCollection
     */
    data?: Array<ServiceOfferingIcon>;
}
/**
 * 
 * @export
 * @interface ServiceOfferingNode
 */
export interface ServiceOfferingNode {
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    created_at?: string;
    /**
     * 
     * @type {object}
     * @memberof ServiceOfferingNode
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    root_service_offering_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    service_inventory_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    service_offering_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    source_created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    source_updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceOfferingNode
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ServiceOfferingNodesCollection
 */
export interface ServiceOfferingNodesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ServiceOfferingNodesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ServiceOfferingNodesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ServiceOfferingNode>}
     * @memberof ServiceOfferingNodesCollection
     */
    data?: Array<ServiceOfferingNode>;
}
/**
 * 
 * @export
 * @interface ServiceOfferingsCollection
 */
export interface ServiceOfferingsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ServiceOfferingsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ServiceOfferingsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ServiceOffering>}
     * @memberof ServiceOfferingsCollection
     */
    data?: Array<ServiceOffering>;
}
/**
 * 
 * @export
 * @interface ServicePlan
 */
export interface ServicePlan {
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    archived_at?: string;
    /**
     * 
     * @type {object}
     * @memberof ServicePlan
     */
    create_json_schema?: object;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    description?: string;
    /**
     * Extra information about this object in JSON format
     * @type {object}
     * @memberof ServicePlan
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    resource_version?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    service_offering_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    source_region_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof ServicePlan
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    update_json_schema?: string;
    /**
     * 
     * @type {string}
     * @memberof ServicePlan
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ServicePlansCollection
 */
export interface ServicePlansCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof ServicePlansCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof ServicePlansCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<ServicePlan>}
     * @memberof ServicePlansCollection
     */
    data?: Array<ServicePlan>;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Source
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    refresh_status?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    uid?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface SourceRegion
 */
export interface SourceRegion {
    /**
     * 
     * @type {string}
     * @memberof SourceRegion
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceRegion
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceRegion
     */
    endpoint?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof SourceRegion
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceRegion
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceRegion
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof SourceRegion
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceRegion
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceRegion
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface SourceRegionsCollection
 */
export interface SourceRegionsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof SourceRegionsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof SourceRegionsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<SourceRegion>}
     * @memberof SourceRegionsCollection
     */
    data?: Array<SourceRegion>;
}
/**
 * 
 * @export
 * @interface SourcesCollection
 */
export interface SourcesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof SourcesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof SourcesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Source>}
     * @memberof SourcesCollection
     */
    data?: Array<Source>;
}
/**
 * 
 * @export
 * @interface Subnet
 */
export interface Subnet {
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    cidr?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    created_at?: string;
    /**
     * 
     * @type {object}
     * @memberof Subnet
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Subnet
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Subnet
     */
    network_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Subnet
     */
    orchestration_stack_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Subnet
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Subnet
     */
    source_region_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    status?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Subnet
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Subnet
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface SubnetsCollection
 */
export interface SubnetsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof SubnetsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof SubnetsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Subnet>}
     * @memberof SubnetsCollection
     */
    data?: Array<Subnet>;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Subscription
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Subscription
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionsCollection
 */
export interface SubscriptionsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof SubscriptionsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof SubscriptionsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof SubscriptionsCollection
     */
    data?: Array<Subscription>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    description?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Tag
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Tagging
 */
export interface Tagging {
    /**
     * ID of the resource
     * @type {string}
     * @memberof Tagging
     */
    tag_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Tagging
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Tagging
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface TagsCollection
 */
export interface TagsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof TagsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof TagsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagsCollection
     */
    data?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    completed_at?: string;
    /**
     * 
     * @type {object}
     * @memberof Task
     */
    context?: object;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    created_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Task
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface TasksCollection
 */
export interface TasksCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof TasksCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof TasksCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Task>}
     * @memberof TasksCollection
     */
    data?: Array<Task>;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * ID of the resource
     * @type {string}
     * @memberof Tenant
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    external_tenant?: string;
}
/**
 * 
 * @export
 * @interface Vm
 */
export interface Vm {
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    archived_at?: string;
    /**
     * Total number of CPU
     * @type {number}
     * @memberof Vm
     */
    cpus?: number;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    created_at?: string;
    /**
     * Description of the Vm
     * @type {string}
     * @memberof Vm
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof Vm
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    flavor_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    host_inventory_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    hostname?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    last_seen_at?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vm
     */
    mac_addresses?: Array<string>;
    /**
     * Total RAM in byte
     * @type {number}
     * @memberof Vm
     */
    memory?: number;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    orchestration_stack_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    power_state?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    source_region_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Vm
     */
    subscription_id?: string;
    /**
     * Cross-Source Unique Reference
     * @type {string}
     * @memberof Vm
     */
    uid_ems?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface VmsCollection
 */
export interface VmsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof VmsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof VmsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Vm>}
     * @memberof VmsCollection
     */
    data?: Array<Vm>;
}
/**
 * 
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    created_at?: string;
    /**
     * 
     * @type {object}
     * @memberof Volume
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    orchestration_stack_id?: string;
    /**
     * Size of the volume in byte
     * @type {number}
     * @memberof Volume
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    source_created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    source_deleted_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    source_ref?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    source_region_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    state?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    subscription_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    updated_at?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof Volume
     */
    volume_type_id?: string;
}
/**
 * 
 * @export
 * @interface VolumeAttachment
 */
export interface VolumeAttachment {
    /**
     * 
     * @type {string}
     * @memberof VolumeAttachment
     */
    device?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeAttachment
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeAttachment
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeAttachment
     */
    state?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeAttachment
     */
    vm_id?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeAttachment
     */
    volume_id?: string;
}
/**
 * 
 * @export
 * @interface VolumeAttachmentsCollection
 */
export interface VolumeAttachmentsCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof VolumeAttachmentsCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof VolumeAttachmentsCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<VolumeAttachment>}
     * @memberof VolumeAttachmentsCollection
     */
    data?: Array<VolumeAttachment>;
}
/**
 * 
 * @export
 * @interface VolumeType
 */
export interface VolumeType {
    /**
     * 
     * @type {string}
     * @memberof VolumeType
     */
    archived_at?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeType
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeType
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof VolumeType
     */
    extra?: object;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeType
     */
    last_seen_at?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeType
     */
    name?: string;
    /**
     * ID of the resource
     * @type {string}
     * @memberof VolumeType
     */
    source_id?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeType
     */
    source_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeType
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface VolumeTypesCollection
 */
export interface VolumeTypesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof VolumeTypesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof VolumeTypesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<VolumeType>}
     * @memberof VolumeTypesCollection
     */
    data?: Array<VolumeType>;
}
/**
 * 
 * @export
 * @interface VolumesCollection
 */
export interface VolumesCollection {
    /**
     * 
     * @type {CollectionMetadata}
     * @memberof VolumesCollection
     */
    meta?: CollectionMetadata;
    /**
     * 
     * @type {CollectionLinks}
     * @memberof VolumesCollection
     */
    links?: CollectionLinks;
    /**
     * 
     * @type {Array<Volume>}
     * @memberof VolumesCollection
     */
    data?: Array<Volume>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Task id
         * @summary Invokes computing of ServiceInventories for given ServiceOffering
         * @param {string} id ID of the resource
         * @param {AppliedInventoriesParametersServicePlan} appliedInventoriesParametersServicePlan Parameters defining input data for computing inventorie
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedInventoriesForServiceOffering: async (id: string, appliedInventoriesParametersServicePlan: AppliedInventoriesParametersServicePlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling appliedInventoriesForServiceOffering.');
            }
            // verify required parameter 'appliedInventoriesParametersServicePlan' is not null or undefined
            if (appliedInventoriesParametersServicePlan === null || appliedInventoriesParametersServicePlan === undefined) {
                throw new RequiredError('appliedInventoriesParametersServicePlan','Required parameter appliedInventoriesParametersServicePlan was null or undefined when calling appliedInventoriesForServiceOffering.');
            }
            const localVarPath = `/service_offerings/{id}/applied_inventories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof appliedInventoriesParametersServicePlan !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(appliedInventoriesParametersServicePlan !== undefined ? appliedInventoriesParametersServicePlan : {}) : (appliedInventoriesParametersServicePlan || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/openapi.json`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Host object
         * @summary List Hosts for Cluster
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterHosts: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listClusterHosts.');
            }
            const localVarPath = `/clusters/{id}/hosts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Cluster object
         * @summary List Cluster
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/clusters`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Container object
         * @summary List Containers for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupContainers: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerGroupContainers.');
            }
            const localVarPath = `/container_groups/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerGroupTags.');
            }
            const localVarPath = `/container_groups/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroup
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroups: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/container_groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerImage
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImageTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerImageTags.');
            }
            const localVarPath = `/container_images/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImage
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImages: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/container_images`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeContainerGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerNodeContainerGroups.');
            }
            const localVarPath = `/container_nodes/{id}/container_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerNodeTags.');
            }
            const localVarPath = `/container_nodes/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodes: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/container_nodes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerProjectContainerGroups.');
            }
            const localVarPath = `/container_projects/{id}/container_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerResourceQuota object
         * @summary List ContainerResourceQuota for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerResourceQuota: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerProjectContainerResourceQuota.');
            }
            const localVarPath = `/container_projects/{id}/container_resource_quotas`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerTemplates: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerProjectContainerTemplates.');
            }
            const localVarPath = `/container_projects/{id}/container_templates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerProjectTags.');
            }
            const localVarPath = `/container_projects/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProject
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjects: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/container_projects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerResourceQuota object
         * @summary List ContainerResourceQuota
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerResourceQuota: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/container_resource_quotas`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerTemplate
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplateTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listContainerTemplateTags.');
            }
            const localVarPath = `/container_templates/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplate
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplates: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/container_templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Container object
         * @summary List Container
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Datastore object
         * @summary List Datastore
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatastores: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/datastores`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Flavor object
         * @summary List Flavor
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/flavors`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Host object
         * @summary List Host
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHosts: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Ipaddre
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIpaddressTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listIpaddressTags.');
            }
            const localVarPath = `/ipaddresses/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresse
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIpaddresses: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipaddresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for NetworkAdapter
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkAdapterIpaddresses: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listNetworkAdapterIpaddresses.');
            }
            const localVarPath = `/network_adapters/{id}/ipaddresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for NetworkAdapter
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkAdapterTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listNetworkAdapterTags.');
            }
            const localVarPath = `/network_adapters/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapter
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkAdapters: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/network_adapters`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Network
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkSubnets: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listNetworkSubnets.');
            }
            const localVarPath = `/networks/{id}/subnets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Network
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listNetworkTags.');
            }
            const localVarPath = `/networks/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Network
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworks: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/networks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackIpaddresses: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listOrchestrationStackIpaddresses.');
            }
            const localVarPath = `/orchestration_stacks/{id}/ipaddresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackNetworkAdapters: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listOrchestrationStackNetworkAdapters.');
            }
            const localVarPath = `/orchestration_stacks/{id}/network_adapters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackNetworks: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listOrchestrationStackNetworks.');
            }
            const localVarPath = `/orchestration_stacks/{id}/networks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackSecurityGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listOrchestrationStackSecurityGroups.');
            }
            const localVarPath = `/orchestration_stacks/{id}/security_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackSubnets: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listOrchestrationStackSubnets.');
            }
            const localVarPath = `/orchestration_stacks/{id}/subnets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackVms: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listOrchestrationStackVms.');
            }
            const localVarPath = `/orchestration_stacks/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackVolumes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listOrchestrationStackVolumes.');
            }
            const localVarPath = `/orchestration_stacks/{id}/volumes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStack
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStacks: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orchestration_stacks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for SecurityGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurityGroupTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSecurityGroupTags.');
            }
            const localVarPath = `/security_groups/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for SecurityGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurityGroupVms: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSecurityGroupVms.');
            }
            const localVarPath = `/security_groups/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroup
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurityGroups: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstanceNodes: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_instance_nodes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNodes for ServiceInstance
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstanceServiceInstanceNodes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceInstanceServiceInstanceNodes.');
            }
            const localVarPath = `/service_instances/{id}/service_instance_nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstance
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstances: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_instances`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventorie
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInventories: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_inventories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ServiceInventory
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInventoryTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceInventoryTags.');
            }
            const localVarPath = `/service_inventories/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOfferingIcon object
         * @summary List ServiceOfferingIcon
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingIcons: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_offering_icons`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingNodes: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_offering_nodes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServiceInstances: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceOfferingServiceInstances.');
            }
            const localVarPath = `/service_offerings/{id}/service_instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNodes for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServiceOfferingNodes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceOfferingServiceOfferingNodes.');
            }
            const localVarPath = `/service_offerings/{id}/service_offering_nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServicePlans: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceOfferingServicePlans.');
            }
            const localVarPath = `/service_offerings/{id}/service_plans`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServiceOfferingTags.');
            }
            const localVarPath = `/service_offerings/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOffering
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferings: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_offerings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for ServicePlan
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlanServiceInstances: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listServicePlanServiceInstances.');
            }
            const localVarPath = `/service_plans/{id}/service_instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlan
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_plans`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Availability object
         * @summary List Availabilities for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceAvailabilities: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceAvailabilities.');
            }
            const localVarPath = `/sources/{id}/availabilities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Cluster object
         * @summary List Clusters for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceClusters: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceClusters.');
            }
            const localVarPath = `/sources/{id}/clusters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerGroups.');
            }
            const localVarPath = `/sources/{id}/container_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImages for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerImages: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerImages.');
            }
            const localVarPath = `/sources/{id}/container_images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerNodes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerNodes.');
            }
            const localVarPath = `/sources/{id}/container_nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProjects for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerProjects: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerProjects.');
            }
            const localVarPath = `/sources/{id}/container_projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerTemplates: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainerTemplates.');
            }
            const localVarPath = `/sources/{id}/container_templates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Container object
         * @summary List Containers for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainers: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceContainers.');
            }
            const localVarPath = `/sources/{id}/containers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Datastore object
         * @summary List Datastores for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceDatastores: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceDatastores.');
            }
            const localVarPath = `/sources/{id}/datastores`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Host object
         * @summary List Hosts for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceHosts: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceHosts.');
            }
            const localVarPath = `/sources/{id}/hosts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceIpaddresses: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceIpaddresses.');
            }
            const localVarPath = `/sources/{id}/ipaddresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceNetworkAdapters: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceNetworkAdapters.');
            }
            const localVarPath = `/sources/{id}/network_adapters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceNetworks: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceNetworks.');
            }
            const localVarPath = `/sources/{id}/networks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceOrchestrationStacks: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceOrchestrationStacks.');
            }
            const localVarPath = `/sources/{id}/orchestration_stacks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionIpaddresses: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionIpaddresses.');
            }
            const localVarPath = `/source_regions/{id}/ipaddresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionNetworkAdapters: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionNetworkAdapters.');
            }
            const localVarPath = `/source_regions/{id}/network_adapters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionNetworks: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionNetworks.');
            }
            const localVarPath = `/source_regions/{id}/networks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionOrchestrationStacks: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionOrchestrationStacks.');
            }
            const localVarPath = `/source_regions/{id}/orchestration_stacks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionSecurityGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionSecurityGroups.');
            }
            const localVarPath = `/source_regions/{id}/security_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionServiceInstances: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionServiceInstances.');
            }
            const localVarPath = `/source_regions/{id}/service_instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionServiceOfferings: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionServiceOfferings.');
            }
            const localVarPath = `/source_regions/{id}/service_offerings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionServicePlans: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionServicePlans.');
            }
            const localVarPath = `/source_regions/{id}/service_plans`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionSubnets: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionSubnets.');
            }
            const localVarPath = `/source_regions/{id}/subnets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionVms: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionVms.');
            }
            const localVarPath = `/source_regions/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionVolumes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceRegionVolumes.');
            }
            const localVarPath = `/source_regions/{id}/volumes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SourceRegion object
         * @summary List SourceRegion
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegions: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/source_regions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSecurityGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceSecurityGroups.');
            }
            const localVarPath = `/sources/{id}/security_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInstanceNodes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServiceInstanceNodes.');
            }
            const localVarPath = `/sources/{id}/service_instance_nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInstances: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServiceInstances.');
            }
            const localVarPath = `/sources/{id}/service_instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventories for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInventories: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServiceInventories.');
            }
            const localVarPath = `/sources/{id}/service_inventories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceOfferingNodes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServiceOfferingNodes.');
            }
            const localVarPath = `/sources/{id}/service_offering_nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceOfferings: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServiceOfferings.');
            }
            const localVarPath = `/sources/{id}/service_offerings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServicePlans: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceServicePlans.');
            }
            const localVarPath = `/sources/{id}/service_plans`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SourceRegion object
         * @summary List SourceRegions for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSourceRegions: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceSourceRegions.');
            }
            const localVarPath = `/sources/{id}/source_regions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSubnets: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceSubnets.');
            }
            const localVarPath = `/sources/{id}/subnets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subscription object
         * @summary List Subscriptions for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSubscriptions: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceSubscriptions.');
            }
            const localVarPath = `/sources/{id}/subscriptions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVms: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceVms.');
            }
            const localVarPath = `/sources/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of VolumeType object
         * @summary List VolumeTypes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumeTypes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceVolumeTypes.');
            }
            const localVarPath = `/sources/{id}/volume_types`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSourceVolumes.');
            }
            const localVarPath = `/sources/{id}/volumes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Source object
         * @summary List Source
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sources`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubnetIpaddresses: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubnetIpaddresses.');
            }
            const localVarPath = `/subnets/{id}/ipaddresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubnetNetworkAdapters: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubnetNetworkAdapters.');
            }
            const localVarPath = `/subnets/{id}/network_adapters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubnetTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubnetTags.');
            }
            const localVarPath = `/subnets/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnet
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubnets: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/subnets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionIpaddresses: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionIpaddresses.');
            }
            const localVarPath = `/subscriptions/{id}/ipaddresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionNetworkAdapters: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionNetworkAdapters.');
            }
            const localVarPath = `/subscriptions/{id}/network_adapters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionNetworks: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionNetworks.');
            }
            const localVarPath = `/subscriptions/{id}/networks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionOrchestrationStacks: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionOrchestrationStacks.');
            }
            const localVarPath = `/subscriptions/{id}/orchestration_stacks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionSecurityGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionSecurityGroups.');
            }
            const localVarPath = `/subscriptions/{id}/security_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionServiceInstances: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionServiceInstances.');
            }
            const localVarPath = `/subscriptions/{id}/service_instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionServiceOfferings: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionServiceOfferings.');
            }
            const localVarPath = `/subscriptions/{id}/service_offerings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionServicePlans: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionServicePlans.');
            }
            const localVarPath = `/subscriptions/{id}/service_plans`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionSubnets: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionSubnets.');
            }
            const localVarPath = `/subscriptions/{id}/subnets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionVms: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionVms.');
            }
            const localVarPath = `/subscriptions/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionVolumes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listSubscriptionVolumes.');
            }
            const localVarPath = `/subscriptions/{id}/volumes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subscription object
         * @summary List Subscription
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerGroups.');
            }
            const localVarPath = `/tags/{id}/container_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImages for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerImages: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerImages.');
            }
            const localVarPath = `/tags/{id}/container_images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNodes for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerNodes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerNodes.');
            }
            const localVarPath = `/tags/{id}/container_nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProjects for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerProjects: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerProjects.');
            }
            const localVarPath = `/tags/{id}/container_projects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerTemplates: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagContainerTemplates.');
            }
            const localVarPath = `/tags/{id}/container_templates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagIpaddresses: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagIpaddresses.');
            }
            const localVarPath = `/tags/{id}/ipaddresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagNetworkAdapters: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagNetworkAdapters.');
            }
            const localVarPath = `/tags/{id}/network_adapters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagNetworks: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagNetworks.');
            }
            const localVarPath = `/tags/{id}/networks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagSecurityGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagSecurityGroups.');
            }
            const localVarPath = `/tags/{id}/security_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventories for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagServiceInventories: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagServiceInventories.');
            }
            const localVarPath = `/tags/{id}/service_inventories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagServiceOfferings: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagServiceOfferings.');
            }
            const localVarPath = `/tags/{id}/service_offerings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagSubnets: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagSubnets.');
            }
            const localVarPath = `/tags/{id}/subnets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagVms: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listTagVms.');
            }
            const localVarPath = `/tags/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tag
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Task object
         * @summary List Task
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmNetworkAdapters: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVmNetworkAdapters.');
            }
            const localVarPath = `/vms/{id}/network_adapters`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmSecurityGroups: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVmSecurityGroups.');
            }
            const localVarPath = `/vms/{id}/security_groups`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmTags: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVmTags.');
            }
            const localVarPath = `/vms/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of VolumeAttachment object
         * @summary List VolumeAttachments for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumeAttachments: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVmVolumeAttachments.');
            }
            const localVarPath = `/vms/{id}/volume_attachments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVmVolumes.');
            }
            const localVarPath = `/vms/{id}/volumes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vm
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVms: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/vms`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of VolumeAttachment object
         * @summary List VolumeAttachment
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeAttachments: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/volume_attachments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for VolumeType
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypeVolumes: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVolumeTypeVolumes.');
            }
            const localVarPath = `/volume_types/{id}/volumes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of VolumeType object
         * @summary List VolumeType
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/volume_types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Volume
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeVms: async (id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listVolumeVms.');
            }
            const localVarPath = `/volumes/{id}/vms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volume
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes: async (limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/volumes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {OrderParametersServiceOffering} orderParametersServiceOffering Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderServiceOffering: async (id: string, orderParametersServiceOffering: OrderParametersServiceOffering, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderServiceOffering.');
            }
            // verify required parameter 'orderParametersServiceOffering' is not null or undefined
            if (orderParametersServiceOffering === null || orderParametersServiceOffering === undefined) {
                throw new RequiredError('orderParametersServiceOffering','Required parameter orderParametersServiceOffering was null or undefined when calling orderServiceOffering.');
            }
            const localVarPath = `/service_offerings/{id}/order`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderParametersServiceOffering !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderParametersServiceOffering !== undefined ? orderParametersServiceOffering : {}) : (orderParametersServiceOffering || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {OrderParametersServicePlan} orderParametersServicePlan Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderServicePlan: async (id: string, orderParametersServicePlan: OrderParametersServicePlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderServicePlan.');
            }
            // verify required parameter 'orderParametersServicePlan' is not null or undefined
            if (orderParametersServicePlan === null || orderParametersServicePlan === undefined) {
                throw new RequiredError('orderParametersServicePlan','Required parameter orderParametersServicePlan was null or undefined when calling orderServicePlan.');
            }
            const localVarPath = `/service_plans/{id}/order`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof orderParametersServicePlan !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(orderParametersServicePlan !== undefined ? orderParametersServicePlan : {}) : (orderParametersServicePlan || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL: async (graphQLRequest: GraphQLRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphQLRequest' is not null or undefined
            if (graphQLRequest === null || graphQLRequest === undefined) {
                throw new RequiredError('graphQLRequest','Required parameter graphQLRequest was null or undefined when calling postGraphQL.');
            }
            const localVarPath = `/graphql`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof graphQLRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(graphQLRequest !== undefined ? graphQLRequest : {}) : (graphQLRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Cluster object
         * @summary Show an existing Cluster
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showCluster: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showCluster.');
            }
            const localVarPath = `/clusters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Container object
         * @summary Show an existing Container
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainer.');
            }
            const localVarPath = `/containers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerGroup object
         * @summary Show an existing ContainerGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerGroup.');
            }
            const localVarPath = `/container_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerImage object
         * @summary Show an existing ContainerImage
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerImage.');
            }
            const localVarPath = `/container_images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerNode object
         * @summary Show an existing ContainerNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerNode: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerNode.');
            }
            const localVarPath = `/container_nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerProject object
         * @summary Show an existing ContainerProject
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerProject: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerProject.');
            }
            const localVarPath = `/container_projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerResourceQuota object
         * @summary Show an existing ContainerResourceQuota
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerResourceQuota: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerResourceQuota.');
            }
            const localVarPath = `/container_resource_quotas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ContainerTemplate object
         * @summary Show an existing ContainerTemplate
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerTemplate: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showContainerTemplate.');
            }
            const localVarPath = `/container_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Datastore object
         * @summary Show an existing Datastore
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDatastore: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showDatastore.');
            }
            const localVarPath = `/datastores/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Flavor object
         * @summary Show an existing Flavor
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showFlavor: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showFlavor.');
            }
            const localVarPath = `/flavors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Host object
         * @summary Show an existing Host
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHost: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showHost.');
            }
            const localVarPath = `/hosts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Ipaddress object
         * @summary Show an existing Ipaddre
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showIpaddress: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showIpaddress.');
            }
            const localVarPath = `/ipaddresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Network object
         * @summary Show an existing Network
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showNetwork: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showNetwork.');
            }
            const localVarPath = `/networks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a NetworkAdapter object
         * @summary Show an existing NetworkAdapter
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showNetworkAdapter: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showNetworkAdapter.');
            }
            const localVarPath = `/network_adapters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a OrchestrationStack object
         * @summary Show an existing OrchestrationStack
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrchestrationStack: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showOrchestrationStack.');
            }
            const localVarPath = `/orchestration_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a SecurityGroup object
         * @summary Show an existing SecurityGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSecurityGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showSecurityGroup.');
            }
            const localVarPath = `/security_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceInstance object
         * @summary Show an existing ServiceInstance
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInstance: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceInstance.');
            }
            const localVarPath = `/service_instances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceInstanceNode object
         * @summary Show an existing ServiceInstanceNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInstanceNode: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceInstanceNode.');
            }
            const localVarPath = `/service_instance_nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceInventory object
         * @summary Show an existing ServiceInventory
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInventory: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceInventory.');
            }
            const localVarPath = `/service_inventories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceOffering object
         * @summary Show an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOffering: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceOffering.');
            }
            const localVarPath = `/service_offerings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceOfferingIcon object
         * @summary Show an existing ServiceOfferingIcon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIcon: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceOfferingIcon.');
            }
            const localVarPath = `/service_offering_icons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceOfferingIcon IconData
         * @summary Show an existing ServiceOfferingIcon IconData
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIconIconData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceOfferingIconIconData.');
            }
            const localVarPath = `/service_offering_icons/{id}/icon_data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServiceOfferingNode object
         * @summary Show an existing ServiceOfferingNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingNode: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServiceOfferingNode.');
            }
            const localVarPath = `/service_offering_nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ServicePlan object
         * @summary Show an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showServicePlan.');
            }
            const localVarPath = `/service_plans/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Source object
         * @summary Show an existing Source
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSource: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showSource.');
            }
            const localVarPath = `/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a SourceRegion object
         * @summary Show an existing SourceRegion
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSourceRegion: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showSourceRegion.');
            }
            const localVarPath = `/source_regions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Subnet object
         * @summary Show an existing Subnet
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSubnet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showSubnet.');
            }
            const localVarPath = `/subnets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Subscription object
         * @summary Show an existing Subscription
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSubscription: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showSubscription.');
            }
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Tag object
         * @summary Show an existing Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTag: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showTag.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Task object
         * @summary Show an existing Task
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTask: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showTask.');
            }
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Vm object
         * @summary Show an existing Vm
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVm: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showVm.');
            }
            const localVarPath = `/vms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Volume object
         * @summary Show an existing Volume
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolume: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showVolume.');
            }
            const localVarPath = `/volumes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a VolumeAttachment object
         * @summary Show an existing VolumeAttachment
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeAttachment: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showVolumeAttachment.');
            }
            const localVarPath = `/volume_attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a VolumeType object
         * @summary Show an existing VolumeType
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showVolumeType.');
            }
            const localVarPath = `/volume_types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Task object
         * @summary Update an existing Task
         * @param {string} id ID of the resource
         * @param {Task} task Task attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: string, task: Task, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTask.');
            }
            // verify required parameter 'task' is not null or undefined
            if (task === null || task === undefined) {
                throw new RequiredError('task','Required parameter task was null or undefined when calling updateTask.');
            }
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication UserSecurity required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof task !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(task !== undefined ? task : {}) : (task || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a Task id
         * @summary Invokes computing of ServiceInventories for given ServiceOffering
         * @param {string} id ID of the resource
         * @param {AppliedInventoriesParametersServicePlan} appliedInventoriesParametersServicePlan Parameters defining input data for computing inventorie
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appliedInventoriesForServiceOffering(id: string, appliedInventoriesParametersServicePlan: AppliedInventoriesParametersServicePlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).appliedInventoriesForServiceOffering(id, appliedInventoriesParametersServicePlan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getDocumentation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Host object
         * @summary List Hosts for Cluster
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusterHosts(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listClusterHosts(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Cluster object
         * @summary List Cluster
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClusters(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClustersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listClusters(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Container object
         * @summary List Containers for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerGroupContainers(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerGroupContainers(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerGroupTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerGroupTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroup
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerGroups(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerGroups(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerImage
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerImageTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerImageTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImage
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerImages(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImagesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerImages(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerNodeContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerNodeContainerGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerNodeTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerNodeTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerNodes(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerProjectContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerProjectContainerGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerResourceQuota object
         * @summary List ContainerResourceQuota for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerProjectContainerResourceQuota(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResourceQuotaCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerProjectContainerResourceQuota(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerProjectContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplatesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerProjectContainerTemplates(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerProjectTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerProjectTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProject
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerProjects(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerProjectsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerProjects(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerResourceQuota object
         * @summary List ContainerResourceQuota
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerResourceQuota(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResourceQuotaCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerResourceQuota(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerTemplate
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerTemplateTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerTemplateTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplate
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerTemplates(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplatesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainerTemplates(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Container object
         * @summary List Container
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainers(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listContainers(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Datastore object
         * @summary List Datastore
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatastores(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatastoresCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listDatastores(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Flavor object
         * @summary List Flavor
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFlavors(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listFlavors(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Host object
         * @summary List Host
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHosts(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listHosts(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Ipaddre
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIpaddressTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listIpaddressTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresse
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIpaddresses(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpaddressesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listIpaddresses(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for NetworkAdapter
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNetworkAdapterIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpaddressesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listNetworkAdapterIpaddresses(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for NetworkAdapter
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNetworkAdapterTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listNetworkAdapterTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapter
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNetworkAdapters(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdaptersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listNetworkAdapters(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Network
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNetworkSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listNetworkSubnets(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Network
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNetworkTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listNetworkTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Network
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNetworks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listNetworks(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrchestrationStackIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpaddressesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listOrchestrationStackIpaddresses(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrchestrationStackNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdaptersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listOrchestrationStackNetworkAdapters(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrchestrationStackNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listOrchestrationStackNetworks(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrchestrationStackSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listOrchestrationStackSecurityGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrchestrationStackSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listOrchestrationStackSubnets(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrchestrationStackVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listOrchestrationStackVms(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrchestrationStackVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listOrchestrationStackVolumes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStack
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrchestrationStacks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationStacksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listOrchestrationStacks(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for SecurityGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSecurityGroupTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSecurityGroupTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for SecurityGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSecurityGroupVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSecurityGroupVms(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroup
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSecurityGroups(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSecurityGroups(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceInstanceNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstanceNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceInstanceNodes(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNodes for ServiceInstance
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceInstanceServiceInstanceNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstanceNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceInstanceServiceInstanceNodes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstance
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceInstances(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceInstances(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventorie
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceInventories(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInventoriesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceInventories(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ServiceInventory
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceInventoryTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceInventoryTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOfferingIcon object
         * @summary List ServiceOfferingIcon
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceOfferingIcons(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingIconsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceOfferingIcons(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceOfferingNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceOfferingNodes(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceOfferingServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceOfferingServiceInstances(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNodes for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceOfferingServiceOfferingNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceOfferingServiceOfferingNodes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceOfferingServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlansCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceOfferingServicePlans(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceOfferingTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceOfferingTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOffering
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServiceOfferings(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServiceOfferings(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for ServicePlan
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServicePlanServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServicePlanServiceInstances(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlan
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServicePlans(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlansCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listServicePlans(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Availability object
         * @summary List Availabilities for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceAvailabilities(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailabilitiesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceAvailabilities(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Cluster object
         * @summary List Clusters for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceClusters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClustersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceClusters(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceContainerGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImages for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceContainerImages(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImagesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceContainerImages(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceContainerNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceContainerNodes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProjects for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceContainerProjects(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerProjectsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceContainerProjects(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplatesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceContainerTemplates(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Container object
         * @summary List Containers for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceContainers(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceContainers(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Datastore object
         * @summary List Datastores for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceDatastores(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatastoresCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceDatastores(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Host object
         * @summary List Hosts for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceHosts(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceHosts(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpaddressesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceIpaddresses(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdaptersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceNetworkAdapters(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceNetworks(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationStacksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceOrchestrationStacks(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpaddressesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionIpaddresses(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdaptersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionNetworkAdapters(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionNetworks(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationStacksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionOrchestrationStacks(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionSecurityGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionServiceInstances(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionServiceOfferings(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlansCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionServicePlans(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionSubnets(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionVms(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegionVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegionVolumes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SourceRegion object
         * @summary List SourceRegion
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceRegions(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceRegionsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceRegions(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceSecurityGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceServiceInstanceNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstanceNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceServiceInstanceNodes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceServiceInstances(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventories for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceServiceInventories(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInventoriesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceServiceInventories(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceServiceOfferingNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceServiceOfferingNodes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceServiceOfferings(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlansCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceServicePlans(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SourceRegion object
         * @summary List SourceRegions for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceSourceRegions(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceRegionsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceSourceRegions(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceSubnets(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subscription object
         * @summary List Subscriptions for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceSubscriptions(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceSubscriptions(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceVms(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of VolumeType object
         * @summary List VolumeTypes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceVolumeTypes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeTypesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceVolumeTypes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSourceVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSourceVolumes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Source object
         * @summary List Source
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSources(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourcesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSources(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubnetIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpaddressesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubnetIpaddresses(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubnetNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdaptersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubnetNetworkAdapters(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubnetTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubnetTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnet
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubnets(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubnets(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpaddressesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionIpaddresses(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdaptersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionNetworkAdapters(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionNetworks(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationStacksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionOrchestrationStacks(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionSecurityGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstancesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionServiceInstances(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionServiceOfferings(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlansCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionServicePlans(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionSubnets(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionVms(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptionVolumes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subscription object
         * @summary List Subscription
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptions(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listSubscriptions(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagContainerGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImages for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagContainerImages(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImagesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagContainerImages(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNodes for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagContainerNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNodesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagContainerNodes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProjects for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagContainerProjects(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerProjectsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagContainerProjects(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplatesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagContainerTemplates(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpaddressesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagIpaddresses(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdaptersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagNetworkAdapters(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagNetworks(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagSecurityGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventories for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagServiceInventories(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInventoriesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagServiceInventories(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagServiceOfferings(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagSubnets(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTagVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTagVms(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tag
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTags(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTags(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Task object
         * @summary List Task
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listTasks(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVmNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdaptersCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVmNetworkAdapters(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVmSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVmSecurityGroups(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVmTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVmTags(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of VolumeAttachment object
         * @summary List VolumeAttachments for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVmVolumeAttachments(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeAttachmentsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVmVolumeAttachments(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVmVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVmVolumes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vm
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVms(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVms(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of VolumeAttachment object
         * @summary List VolumeAttachment
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumeAttachments(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeAttachmentsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVolumeAttachments(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for VolumeType
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumeTypeVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVolumeTypeVolumes(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of VolumeType object
         * @summary List VolumeType
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumeTypes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeTypesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVolumeTypes(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Volume
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumeVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmsCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVolumeVms(id, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of Volume object
         * @summary List Volume
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVolumes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesCollection>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).listVolumes(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {OrderParametersServiceOffering} orderParametersServiceOffering Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderServiceOffering(id: string, orderParametersServiceOffering: OrderParametersServiceOffering, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).orderServiceOffering(id, orderParametersServiceOffering, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {OrderParametersServicePlan} orderParametersServicePlan Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderServicePlan(id: string, orderParametersServicePlan: OrderParametersServicePlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).orderServicePlan(id, orderParametersServicePlan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGraphQL(graphQLRequest: GraphQLRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphQLResponse>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).postGraphQL(graphQLRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Cluster object
         * @summary Show an existing Cluster
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showCluster(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showCluster(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Container object
         * @summary Show an existing Container
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showContainer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Container>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showContainer(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerGroup object
         * @summary Show an existing ContainerGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showContainerGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerGroup>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showContainerGroup(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerImage object
         * @summary Show an existing ContainerImage
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showContainerImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImage>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showContainerImage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerNode object
         * @summary Show an existing ContainerNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showContainerNode(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerNode>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showContainerNode(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerProject object
         * @summary Show an existing ContainerProject
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showContainerProject(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerProject>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showContainerProject(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerResourceQuota object
         * @summary Show an existing ContainerResourceQuota
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showContainerResourceQuota(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResourceQuota>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showContainerResourceQuota(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ContainerTemplate object
         * @summary Show an existing ContainerTemplate
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showContainerTemplate(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerTemplate>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showContainerTemplate(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Datastore object
         * @summary Show an existing Datastore
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDatastore(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Datastore>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showDatastore(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Flavor object
         * @summary Show an existing Flavor
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showFlavor(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flavor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showFlavor(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Host object
         * @summary Show an existing Host
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHost(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Host>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showHost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Ipaddress object
         * @summary Show an existing Ipaddre
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showIpaddress(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ipaddress>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showIpaddress(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Network object
         * @summary Show an existing Network
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showNetwork(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showNetwork(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a NetworkAdapter object
         * @summary Show an existing NetworkAdapter
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showNetworkAdapter(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdapter>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showNetworkAdapter(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a OrchestrationStack object
         * @summary Show an existing OrchestrationStack
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showOrchestrationStack(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrchestrationStack>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showOrchestrationStack(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a SecurityGroup object
         * @summary Show an existing SecurityGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showSecurityGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroup>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showSecurityGroup(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceInstance object
         * @summary Show an existing ServiceInstance
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServiceInstance(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstance>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showServiceInstance(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceInstanceNode object
         * @summary Show an existing ServiceInstanceNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServiceInstanceNode(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstanceNode>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showServiceInstanceNode(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceInventory object
         * @summary Show an existing ServiceInventory
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServiceInventory(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInventory>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showServiceInventory(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceOffering object
         * @summary Show an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServiceOffering(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOffering>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showServiceOffering(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceOfferingIcon object
         * @summary Show an existing ServiceOfferingIcon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServiceOfferingIcon(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingIcon>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showServiceOfferingIcon(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceOfferingIcon IconData
         * @summary Show an existing ServiceOfferingIcon IconData
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServiceOfferingIconIconData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showServiceOfferingIconIconData(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServiceOfferingNode object
         * @summary Show an existing ServiceOfferingNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServiceOfferingNode(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceOfferingNode>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showServiceOfferingNode(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a ServicePlan object
         * @summary Show an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showServicePlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePlan>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showServicePlan(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Source object
         * @summary Show an existing Source
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showSource(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showSource(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a SourceRegion object
         * @summary Show an existing SourceRegion
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showSourceRegion(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceRegion>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showSourceRegion(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Subnet object
         * @summary Show an existing Subnet
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showSubnet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subnet>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showSubnet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Subscription object
         * @summary Show an existing Subscription
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showSubscription(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showSubscription(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Tag object
         * @summary Show an existing Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showTag(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showTag(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Task object
         * @summary Show an existing Task
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showTask(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showTask(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Vm object
         * @summary Show an existing Vm
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showVm(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showVm(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Volume object
         * @summary Show an existing Volume
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showVolume(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showVolume(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a VolumeAttachment object
         * @summary Show an existing VolumeAttachment
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showVolumeAttachment(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeAttachment>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showVolumeAttachment(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a VolumeType object
         * @summary Show an existing VolumeType
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showVolumeType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumeType>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).showVolumeType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a Task object
         * @summary Update an existing Task
         * @param {string} id ID of the resource
         * @param {Task} task Task attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: string, task: Task, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).updateTask(id, task, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a Task id
         * @summary Invokes computing of ServiceInventories for given ServiceOffering
         * @param {string} id ID of the resource
         * @param {AppliedInventoriesParametersServicePlan} appliedInventoriesParametersServicePlan Parameters defining input data for computing inventorie
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedInventoriesForServiceOffering(id: string, appliedInventoriesParametersServicePlan: AppliedInventoriesParametersServicePlan, options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).appliedInventoriesForServiceOffering(id, appliedInventoriesParametersServicePlan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).getDocumentation(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Host object
         * @summary List Hosts for Cluster
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusterHosts(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<HostsCollection> {
            return DefaultApiFp(configuration).listClusterHosts(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Cluster object
         * @summary List Cluster
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ClustersCollection> {
            return DefaultApiFp(configuration).listClusters(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Container object
         * @summary List Containers for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupContainers(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainersCollection> {
            return DefaultApiFp(configuration).listContainerGroupContainers(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroupTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listContainerGroupTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroup
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerGroups(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerGroupsCollection> {
            return DefaultApiFp(configuration).listContainerGroups(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerImage
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImageTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listContainerImageTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImage
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerImages(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerImagesCollection> {
            return DefaultApiFp(configuration).listContainerImages(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerGroupsCollection> {
            return DefaultApiFp(configuration).listContainerNodeContainerGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerNode
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodeTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listContainerNodeTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerNodesCollection> {
            return DefaultApiFp(configuration).listContainerNodes(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerGroupsCollection> {
            return DefaultApiFp(configuration).listContainerProjectContainerGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerResourceQuota object
         * @summary List ContainerResourceQuota for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerResourceQuota(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerResourceQuotaCollection> {
            return DefaultApiFp(configuration).listContainerProjectContainerResourceQuota(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerTemplatesCollection> {
            return DefaultApiFp(configuration).listContainerProjectContainerTemplates(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerProject
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjectTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listContainerProjectTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProject
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerProjects(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerProjectsCollection> {
            return DefaultApiFp(configuration).listContainerProjects(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerResourceQuota object
         * @summary List ContainerResourceQuota
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerResourceQuota(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerResourceQuotaCollection> {
            return DefaultApiFp(configuration).listContainerResourceQuota(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ContainerTemplate
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplateTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listContainerTemplateTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplate
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerTemplates(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerTemplatesCollection> {
            return DefaultApiFp(configuration).listContainerTemplates(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Container object
         * @summary List Container
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainersCollection> {
            return DefaultApiFp(configuration).listContainers(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Datastore object
         * @summary List Datastore
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatastores(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<DatastoresCollection> {
            return DefaultApiFp(configuration).listDatastores(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Flavor object
         * @summary List Flavor
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFlavors(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<FlavorsCollection> {
            return DefaultApiFp(configuration).listFlavors(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Host object
         * @summary List Host
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHosts(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<HostsCollection> {
            return DefaultApiFp(configuration).listHosts(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Ipaddre
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIpaddressTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listIpaddressTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresse
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIpaddresses(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<IpaddressesCollection> {
            return DefaultApiFp(configuration).listIpaddresses(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for NetworkAdapter
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkAdapterIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<IpaddressesCollection> {
            return DefaultApiFp(configuration).listNetworkAdapterIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for NetworkAdapter
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkAdapterTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listNetworkAdapterTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapter
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkAdapters(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworkAdaptersCollection> {
            return DefaultApiFp(configuration).listNetworkAdapters(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Network
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubnetsCollection> {
            return DefaultApiFp(configuration).listNetworkSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Network
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworkTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listNetworkTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Network object
         * @summary List Network
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNetworks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworksCollection> {
            return DefaultApiFp(configuration).listNetworks(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<IpaddressesCollection> {
            return DefaultApiFp(configuration).listOrchestrationStackIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworkAdaptersCollection> {
            return DefaultApiFp(configuration).listOrchestrationStackNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworksCollection> {
            return DefaultApiFp(configuration).listOrchestrationStackNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SecurityGroupsCollection> {
            return DefaultApiFp(configuration).listOrchestrationStackSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubnetsCollection> {
            return DefaultApiFp(configuration).listOrchestrationStackSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VmsCollection> {
            return DefaultApiFp(configuration).listOrchestrationStackVms(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for OrchestrationStack
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStackVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumesCollection> {
            return DefaultApiFp(configuration).listOrchestrationStackVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStack
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrchestrationStacks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<OrchestrationStacksCollection> {
            return DefaultApiFp(configuration).listOrchestrationStacks(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for SecurityGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurityGroupTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listSecurityGroupTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for SecurityGroup
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurityGroupVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VmsCollection> {
            return DefaultApiFp(configuration).listSecurityGroupVms(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroup
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSecurityGroups(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SecurityGroupsCollection> {
            return DefaultApiFp(configuration).listSecurityGroups(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstanceNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstanceNodesCollection> {
            return DefaultApiFp(configuration).listServiceInstanceNodes(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNodes for ServiceInstance
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstanceServiceInstanceNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstanceNodesCollection> {
            return DefaultApiFp(configuration).listServiceInstanceServiceInstanceNodes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstance
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInstances(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstancesCollection> {
            return DefaultApiFp(configuration).listServiceInstances(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventorie
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInventories(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInventoriesCollection> {
            return DefaultApiFp(configuration).listServiceInventories(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ServiceInventory
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceInventoryTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listServiceInventoryTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOfferingIcon object
         * @summary List ServiceOfferingIcon
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingIcons(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingIconsCollection> {
            return DefaultApiFp(configuration).listServiceOfferingIcons(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNode
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingNodesCollection> {
            return DefaultApiFp(configuration).listServiceOfferingNodes(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstancesCollection> {
            return DefaultApiFp(configuration).listServiceOfferingServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNodes for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServiceOfferingNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingNodesCollection> {
            return DefaultApiFp(configuration).listServiceOfferingServiceOfferingNodes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServicePlansCollection> {
            return DefaultApiFp(configuration).listServiceOfferingServicePlans(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for ServiceOffering
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferingTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listServiceOfferingTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOffering
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServiceOfferings(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingsCollection> {
            return DefaultApiFp(configuration).listServiceOfferings(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for ServicePlan
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlanServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstancesCollection> {
            return DefaultApiFp(configuration).listServicePlanServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlan
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePlans(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServicePlansCollection> {
            return DefaultApiFp(configuration).listServicePlans(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Availability object
         * @summary List Availabilities for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceAvailabilities(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<AvailabilitiesCollection> {
            return DefaultApiFp(configuration).listSourceAvailabilities(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Cluster object
         * @summary List Clusters for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceClusters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ClustersCollection> {
            return DefaultApiFp(configuration).listSourceClusters(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerGroupsCollection> {
            return DefaultApiFp(configuration).listSourceContainerGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImages for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerImages(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerImagesCollection> {
            return DefaultApiFp(configuration).listSourceContainerImages(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerNodesCollection> {
            return DefaultApiFp(configuration).listSourceContainerNodes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProjects for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerProjects(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerProjectsCollection> {
            return DefaultApiFp(configuration).listSourceContainerProjects(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerTemplatesCollection> {
            return DefaultApiFp(configuration).listSourceContainerTemplates(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Container object
         * @summary List Containers for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceContainers(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainersCollection> {
            return DefaultApiFp(configuration).listSourceContainers(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Datastore object
         * @summary List Datastores for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceDatastores(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<DatastoresCollection> {
            return DefaultApiFp(configuration).listSourceDatastores(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Host object
         * @summary List Hosts for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceHosts(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<HostsCollection> {
            return DefaultApiFp(configuration).listSourceHosts(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<IpaddressesCollection> {
            return DefaultApiFp(configuration).listSourceIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworkAdaptersCollection> {
            return DefaultApiFp(configuration).listSourceNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworksCollection> {
            return DefaultApiFp(configuration).listSourceNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<OrchestrationStacksCollection> {
            return DefaultApiFp(configuration).listSourceOrchestrationStacks(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<IpaddressesCollection> {
            return DefaultApiFp(configuration).listSourceRegionIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworkAdaptersCollection> {
            return DefaultApiFp(configuration).listSourceRegionNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworksCollection> {
            return DefaultApiFp(configuration).listSourceRegionNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<OrchestrationStacksCollection> {
            return DefaultApiFp(configuration).listSourceRegionOrchestrationStacks(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SecurityGroupsCollection> {
            return DefaultApiFp(configuration).listSourceRegionSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstancesCollection> {
            return DefaultApiFp(configuration).listSourceRegionServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingsCollection> {
            return DefaultApiFp(configuration).listSourceRegionServiceOfferings(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServicePlansCollection> {
            return DefaultApiFp(configuration).listSourceRegionServicePlans(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubnetsCollection> {
            return DefaultApiFp(configuration).listSourceRegionSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VmsCollection> {
            return DefaultApiFp(configuration).listSourceRegionVms(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for SourceRegion
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegionVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumesCollection> {
            return DefaultApiFp(configuration).listSourceRegionVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SourceRegion object
         * @summary List SourceRegion
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceRegions(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SourceRegionsCollection> {
            return DefaultApiFp(configuration).listSourceRegions(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SecurityGroupsCollection> {
            return DefaultApiFp(configuration).listSourceSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstanceNode object
         * @summary List ServiceInstanceNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInstanceNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstanceNodesCollection> {
            return DefaultApiFp(configuration).listSourceServiceInstanceNodes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstancesCollection> {
            return DefaultApiFp(configuration).listSourceServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventories for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceInventories(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInventoriesCollection> {
            return DefaultApiFp(configuration).listSourceServiceInventories(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOfferingNode object
         * @summary List ServiceOfferingNodes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceOfferingNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingNodesCollection> {
            return DefaultApiFp(configuration).listSourceServiceOfferingNodes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingsCollection> {
            return DefaultApiFp(configuration).listSourceServiceOfferings(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServicePlansCollection> {
            return DefaultApiFp(configuration).listSourceServicePlans(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SourceRegion object
         * @summary List SourceRegions for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSourceRegions(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SourceRegionsCollection> {
            return DefaultApiFp(configuration).listSourceSourceRegions(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubnetsCollection> {
            return DefaultApiFp(configuration).listSourceSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subscription object
         * @summary List Subscriptions for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceSubscriptions(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubscriptionsCollection> {
            return DefaultApiFp(configuration).listSourceSubscriptions(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VmsCollection> {
            return DefaultApiFp(configuration).listSourceVms(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of VolumeType object
         * @summary List VolumeTypes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumeTypes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumeTypesCollection> {
            return DefaultApiFp(configuration).listSourceVolumeTypes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Source
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSourceVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumesCollection> {
            return DefaultApiFp(configuration).listSourceVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Source object
         * @summary List Source
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSources(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SourcesCollection> {
            return DefaultApiFp(configuration).listSources(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubnetIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<IpaddressesCollection> {
            return DefaultApiFp(configuration).listSubnetIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubnetNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworkAdaptersCollection> {
            return DefaultApiFp(configuration).listSubnetNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Subnet
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubnetTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listSubnetTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnet
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubnets(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubnetsCollection> {
            return DefaultApiFp(configuration).listSubnets(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<IpaddressesCollection> {
            return DefaultApiFp(configuration).listSubscriptionIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworkAdaptersCollection> {
            return DefaultApiFp(configuration).listSubscriptionNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworksCollection> {
            return DefaultApiFp(configuration).listSubscriptionNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of OrchestrationStack object
         * @summary List OrchestrationStacks for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<OrchestrationStacksCollection> {
            return DefaultApiFp(configuration).listSubscriptionOrchestrationStacks(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SecurityGroupsCollection> {
            return DefaultApiFp(configuration).listSubscriptionSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInstance object
         * @summary List ServiceInstances for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInstancesCollection> {
            return DefaultApiFp(configuration).listSubscriptionServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingsCollection> {
            return DefaultApiFp(configuration).listSubscriptionServiceOfferings(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServicePlan object
         * @summary List ServicePlans for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServicePlansCollection> {
            return DefaultApiFp(configuration).listSubscriptionServicePlans(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubnetsCollection> {
            return DefaultApiFp(configuration).listSubscriptionSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VmsCollection> {
            return DefaultApiFp(configuration).listSubscriptionVms(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Subscription
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumesCollection> {
            return DefaultApiFp(configuration).listSubscriptionVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subscription object
         * @summary List Subscription
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubscriptionsCollection> {
            return DefaultApiFp(configuration).listSubscriptions(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerGroup object
         * @summary List ContainerGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerGroupsCollection> {
            return DefaultApiFp(configuration).listTagContainerGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerImage object
         * @summary List ContainerImages for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerImages(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerImagesCollection> {
            return DefaultApiFp(configuration).listTagContainerImages(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerNode object
         * @summary List ContainerNodes for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerNodesCollection> {
            return DefaultApiFp(configuration).listTagContainerNodes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerProject object
         * @summary List ContainerProjects for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerProjects(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerProjectsCollection> {
            return DefaultApiFp(configuration).listTagContainerProjects(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ContainerTemplate object
         * @summary List ContainerTemplates for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ContainerTemplatesCollection> {
            return DefaultApiFp(configuration).listTagContainerTemplates(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Ipaddress object
         * @summary List Ipaddresses for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<IpaddressesCollection> {
            return DefaultApiFp(configuration).listTagIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworkAdaptersCollection> {
            return DefaultApiFp(configuration).listTagNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Network object
         * @summary List Networks for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworksCollection> {
            return DefaultApiFp(configuration).listTagNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SecurityGroupsCollection> {
            return DefaultApiFp(configuration).listTagSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceInventory object
         * @summary List ServiceInventories for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagServiceInventories(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceInventoriesCollection> {
            return DefaultApiFp(configuration).listTagServiceInventories(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of ServiceOffering object
         * @summary List ServiceOfferings for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<ServiceOfferingsCollection> {
            return DefaultApiFp(configuration).listTagServiceOfferings(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Subnet object
         * @summary List Subnets for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SubnetsCollection> {
            return DefaultApiFp(configuration).listTagSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Tag
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTagVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VmsCollection> {
            return DefaultApiFp(configuration).listTagVms(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tag
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTags(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listTags(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Task object
         * @summary List Task
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TasksCollection> {
            return DefaultApiFp(configuration).listTasks(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of NetworkAdapter object
         * @summary List NetworkAdapters for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<NetworkAdaptersCollection> {
            return DefaultApiFp(configuration).listVmNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of SecurityGroup object
         * @summary List SecurityGroups for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<SecurityGroupsCollection> {
            return DefaultApiFp(configuration).listVmSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Tag object
         * @summary List Tags for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<TagsCollection> {
            return DefaultApiFp(configuration).listVmTags(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of VolumeAttachment object
         * @summary List VolumeAttachments for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumeAttachments(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumeAttachmentsCollection> {
            return DefaultApiFp(configuration).listVmVolumeAttachments(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for Vm
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVmVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumesCollection> {
            return DefaultApiFp(configuration).listVmVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Vm object
         * @summary List Vm
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVms(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VmsCollection> {
            return DefaultApiFp(configuration).listVms(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of VolumeAttachment object
         * @summary List VolumeAttachment
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeAttachments(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumeAttachmentsCollection> {
            return DefaultApiFp(configuration).listVolumeAttachments(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Volume object
         * @summary List Volumes for VolumeType
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypeVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumesCollection> {
            return DefaultApiFp(configuration).listVolumeTypeVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of VolumeType object
         * @summary List VolumeType
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeTypes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumeTypesCollection> {
            return DefaultApiFp(configuration).listVolumeTypes(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Vm object
         * @summary List Vms for Volume
         * @param {string} id ID of the resource
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumeVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VmsCollection> {
            return DefaultApiFp(configuration).listVolumeVms(id, limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of Volume object
         * @summary List Volume
         * @param {number} [limit] The numbers of items to return per page.
         * @param {number} [offset] The number of items to skip before starting to collect the result set.
         * @param {object} [filter] Filter for querying collections.
         * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVolumes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any): AxiosPromise<VolumesCollection> {
            return DefaultApiFp(configuration).listVolumes(limit, offset, filter, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {OrderParametersServiceOffering} orderParametersServiceOffering Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderServiceOffering(id: string, orderParametersServiceOffering: OrderParametersServiceOffering, options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).orderServiceOffering(id, orderParametersServiceOffering, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Task id
         * @summary Order an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {OrderParametersServicePlan} orderParametersServicePlan Order parameters defining the service and provider control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderServicePlan(id: string, orderParametersServicePlan: OrderParametersServicePlan, options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).orderServicePlan(id, orderParametersServicePlan, options).then((request) => request(axios, basePath));
        },
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphQL(graphQLRequest: GraphQLRequest, options?: any): AxiosPromise<GraphQLResponse> {
            return DefaultApiFp(configuration).postGraphQL(graphQLRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Cluster object
         * @summary Show an existing Cluster
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showCluster(id: string, options?: any): AxiosPromise<Cluster> {
            return DefaultApiFp(configuration).showCluster(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Container object
         * @summary Show an existing Container
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainer(id: string, options?: any): AxiosPromise<Container> {
            return DefaultApiFp(configuration).showContainer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ContainerGroup object
         * @summary Show an existing ContainerGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerGroup(id: string, options?: any): AxiosPromise<ContainerGroup> {
            return DefaultApiFp(configuration).showContainerGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ContainerImage object
         * @summary Show an existing ContainerImage
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerImage(id: string, options?: any): AxiosPromise<ContainerImage> {
            return DefaultApiFp(configuration).showContainerImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ContainerNode object
         * @summary Show an existing ContainerNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerNode(id: string, options?: any): AxiosPromise<ContainerNode> {
            return DefaultApiFp(configuration).showContainerNode(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ContainerProject object
         * @summary Show an existing ContainerProject
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerProject(id: string, options?: any): AxiosPromise<ContainerProject> {
            return DefaultApiFp(configuration).showContainerProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ContainerResourceQuota object
         * @summary Show an existing ContainerResourceQuota
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerResourceQuota(id: string, options?: any): AxiosPromise<ContainerResourceQuota> {
            return DefaultApiFp(configuration).showContainerResourceQuota(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ContainerTemplate object
         * @summary Show an existing ContainerTemplate
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showContainerTemplate(id: string, options?: any): AxiosPromise<ContainerTemplate> {
            return DefaultApiFp(configuration).showContainerTemplate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Datastore object
         * @summary Show an existing Datastore
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDatastore(id: string, options?: any): AxiosPromise<Datastore> {
            return DefaultApiFp(configuration).showDatastore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Flavor object
         * @summary Show an existing Flavor
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showFlavor(id: string, options?: any): AxiosPromise<Flavor> {
            return DefaultApiFp(configuration).showFlavor(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Host object
         * @summary Show an existing Host
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHost(id: string, options?: any): AxiosPromise<Host> {
            return DefaultApiFp(configuration).showHost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Ipaddress object
         * @summary Show an existing Ipaddre
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showIpaddress(id: string, options?: any): AxiosPromise<Ipaddress> {
            return DefaultApiFp(configuration).showIpaddress(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Network object
         * @summary Show an existing Network
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showNetwork(id: string, options?: any): AxiosPromise<Network> {
            return DefaultApiFp(configuration).showNetwork(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a NetworkAdapter object
         * @summary Show an existing NetworkAdapter
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showNetworkAdapter(id: string, options?: any): AxiosPromise<NetworkAdapter> {
            return DefaultApiFp(configuration).showNetworkAdapter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a OrchestrationStack object
         * @summary Show an existing OrchestrationStack
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showOrchestrationStack(id: string, options?: any): AxiosPromise<OrchestrationStack> {
            return DefaultApiFp(configuration).showOrchestrationStack(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a SecurityGroup object
         * @summary Show an existing SecurityGroup
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSecurityGroup(id: string, options?: any): AxiosPromise<SecurityGroup> {
            return DefaultApiFp(configuration).showSecurityGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ServiceInstance object
         * @summary Show an existing ServiceInstance
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInstance(id: string, options?: any): AxiosPromise<ServiceInstance> {
            return DefaultApiFp(configuration).showServiceInstance(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ServiceInstanceNode object
         * @summary Show an existing ServiceInstanceNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInstanceNode(id: string, options?: any): AxiosPromise<ServiceInstanceNode> {
            return DefaultApiFp(configuration).showServiceInstanceNode(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ServiceInventory object
         * @summary Show an existing ServiceInventory
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceInventory(id: string, options?: any): AxiosPromise<ServiceInventory> {
            return DefaultApiFp(configuration).showServiceInventory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ServiceOffering object
         * @summary Show an existing ServiceOffering
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOffering(id: string, options?: any): AxiosPromise<ServiceOffering> {
            return DefaultApiFp(configuration).showServiceOffering(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ServiceOfferingIcon object
         * @summary Show an existing ServiceOfferingIcon
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIcon(id: string, options?: any): AxiosPromise<ServiceOfferingIcon> {
            return DefaultApiFp(configuration).showServiceOfferingIcon(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ServiceOfferingIcon IconData
         * @summary Show an existing ServiceOfferingIcon IconData
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingIconIconData(id: string, options?: any): AxiosPromise<any> {
            return DefaultApiFp(configuration).showServiceOfferingIconIconData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ServiceOfferingNode object
         * @summary Show an existing ServiceOfferingNode
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServiceOfferingNode(id: string, options?: any): AxiosPromise<ServiceOfferingNode> {
            return DefaultApiFp(configuration).showServiceOfferingNode(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ServicePlan object
         * @summary Show an existing ServicePlan
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showServicePlan(id: string, options?: any): AxiosPromise<ServicePlan> {
            return DefaultApiFp(configuration).showServicePlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Source object
         * @summary Show an existing Source
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSource(id: string, options?: any): AxiosPromise<Source> {
            return DefaultApiFp(configuration).showSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a SourceRegion object
         * @summary Show an existing SourceRegion
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSourceRegion(id: string, options?: any): AxiosPromise<SourceRegion> {
            return DefaultApiFp(configuration).showSourceRegion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Subnet object
         * @summary Show an existing Subnet
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSubnet(id: string, options?: any): AxiosPromise<Subnet> {
            return DefaultApiFp(configuration).showSubnet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Subscription object
         * @summary Show an existing Subscription
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showSubscription(id: string, options?: any): AxiosPromise<Subscription> {
            return DefaultApiFp(configuration).showSubscription(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Tag object
         * @summary Show an existing Tag
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTag(id: string, options?: any): AxiosPromise<Tag> {
            return DefaultApiFp(configuration).showTag(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Task object
         * @summary Show an existing Task
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTask(id: string, options?: any): AxiosPromise<Task> {
            return DefaultApiFp(configuration).showTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Vm object
         * @summary Show an existing Vm
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVm(id: string, options?: any): AxiosPromise<Vm> {
            return DefaultApiFp(configuration).showVm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Volume object
         * @summary Show an existing Volume
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolume(id: string, options?: any): AxiosPromise<Volume> {
            return DefaultApiFp(configuration).showVolume(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a VolumeAttachment object
         * @summary Show an existing VolumeAttachment
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeAttachment(id: string, options?: any): AxiosPromise<VolumeAttachment> {
            return DefaultApiFp(configuration).showVolumeAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a VolumeType object
         * @summary Show an existing VolumeType
         * @param {string} id ID of the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showVolumeType(id: string, options?: any): AxiosPromise<VolumeType> {
            return DefaultApiFp(configuration).showVolumeType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Task object
         * @summary Update an existing Task
         * @param {string} id ID of the resource
         * @param {Task} task Task attributes to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, task: Task, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).updateTask(id, task, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Returns a Task id
     * @summary Invokes computing of ServiceInventories for given ServiceOffering
     * @param {string} id ID of the resource
     * @param {AppliedInventoriesParametersServicePlan} appliedInventoriesParametersServicePlan Parameters defining input data for computing inventorie
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appliedInventoriesForServiceOffering(id: string, appliedInventoriesParametersServicePlan: AppliedInventoriesParametersServicePlan, options?: any) {
        return DefaultApiFp(this.configuration).appliedInventoriesForServiceOffering(id, appliedInventoriesParametersServicePlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return this API document in JSON format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentation(options?: any) {
        return DefaultApiFp(this.configuration).getDocumentation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Host object
     * @summary List Hosts for Cluster
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listClusterHosts(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listClusterHosts(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Cluster object
     * @summary List Cluster
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listClusters(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listClusters(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Container object
     * @summary List Containers for ContainerGroup
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerGroupContainers(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerGroupContainers(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for ContainerGroup
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerGroupTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerGroupTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerGroup object
     * @summary List ContainerGroup
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerGroups(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerGroups(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for ContainerImage
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerImageTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerImageTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerImage object
     * @summary List ContainerImage
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerImages(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerImages(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerGroup object
     * @summary List ContainerGroups for ContainerNode
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerNodeContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerNodeContainerGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for ContainerNode
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerNodeTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerNodeTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerNode object
     * @summary List ContainerNode
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerNodes(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerGroup object
     * @summary List ContainerGroups for ContainerProject
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjectContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjectContainerGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerResourceQuota object
     * @summary List ContainerResourceQuota for ContainerProject
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjectContainerResourceQuota(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjectContainerResourceQuota(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerTemplate object
     * @summary List ContainerTemplates for ContainerProject
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjectContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjectContainerTemplates(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for ContainerProject
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjectTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjectTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerProject object
     * @summary List ContainerProject
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerProjects(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerProjects(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerResourceQuota object
     * @summary List ContainerResourceQuota
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerResourceQuota(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerResourceQuota(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for ContainerTemplate
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerTemplateTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerTemplateTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerTemplate object
     * @summary List ContainerTemplate
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainerTemplates(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainerTemplates(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Container object
     * @summary List Container
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listContainers(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listContainers(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Datastore object
     * @summary List Datastore
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listDatastores(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listDatastores(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Flavor object
     * @summary List Flavor
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listFlavors(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listFlavors(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Host object
     * @summary List Host
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listHosts(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listHosts(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for Ipaddre
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIpaddressTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listIpaddressTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Ipaddress object
     * @summary List Ipaddresse
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIpaddresses(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listIpaddresses(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Ipaddress object
     * @summary List Ipaddresses for NetworkAdapter
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNetworkAdapterIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listNetworkAdapterIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for NetworkAdapter
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNetworkAdapterTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listNetworkAdapterTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of NetworkAdapter object
     * @summary List NetworkAdapter
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNetworkAdapters(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listNetworkAdapters(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subnet object
     * @summary List Subnets for Network
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNetworkSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listNetworkSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for Network
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNetworkTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listNetworkTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Network object
     * @summary List Network
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listNetworks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listNetworks(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Ipaddress object
     * @summary List Ipaddresses for OrchestrationStack
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStackIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStackIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of NetworkAdapter object
     * @summary List NetworkAdapters for OrchestrationStack
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStackNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStackNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Network object
     * @summary List Networks for OrchestrationStack
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStackNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStackNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SecurityGroup object
     * @summary List SecurityGroups for OrchestrationStack
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStackSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStackSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subnet object
     * @summary List Subnets for OrchestrationStack
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStackSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStackSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Vm object
     * @summary List Vms for OrchestrationStack
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStackVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStackVms(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Volume object
     * @summary List Volumes for OrchestrationStack
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStackVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStackVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of OrchestrationStack object
     * @summary List OrchestrationStack
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listOrchestrationStacks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listOrchestrationStacks(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for SecurityGroup
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSecurityGroupTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSecurityGroupTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Vm object
     * @summary List Vms for SecurityGroup
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSecurityGroupVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSecurityGroupVms(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SecurityGroup object
     * @summary List SecurityGroup
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSecurityGroups(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSecurityGroups(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstanceNode object
     * @summary List ServiceInstanceNode
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceInstanceNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceInstanceNodes(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstanceNode object
     * @summary List ServiceInstanceNodes for ServiceInstance
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceInstanceServiceInstanceNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceInstanceServiceInstanceNodes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstance object
     * @summary List ServiceInstance
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceInstances(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceInstances(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInventory object
     * @summary List ServiceInventorie
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceInventories(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceInventories(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for ServiceInventory
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceInventoryTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceInventoryTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOfferingIcon object
     * @summary List ServiceOfferingIcon
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingIcons(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingIcons(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOfferingNode object
     * @summary List ServiceOfferingNode
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingNodes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingNodes(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstance object
     * @summary List ServiceInstances for ServiceOffering
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOfferingNode object
     * @summary List ServiceOfferingNodes for ServiceOffering
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingServiceOfferingNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingServiceOfferingNodes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServicePlan object
     * @summary List ServicePlans for ServiceOffering
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingServicePlans(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for ServiceOffering
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferingTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferingTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOffering object
     * @summary List ServiceOffering
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServiceOfferings(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServiceOfferings(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstance object
     * @summary List ServiceInstances for ServicePlan
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServicePlanServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServicePlanServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServicePlan object
     * @summary List ServicePlan
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listServicePlans(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listServicePlans(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Availability object
     * @summary List Availabilities for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceAvailabilities(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceAvailabilities(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Cluster object
     * @summary List Clusters for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceClusters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceClusters(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerGroup object
     * @summary List ContainerGroups for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerImage object
     * @summary List ContainerImages for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerImages(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerImages(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerNode object
     * @summary List ContainerNodes for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerNodes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerProject object
     * @summary List ContainerProjects for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerProjects(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerProjects(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerTemplate object
     * @summary List ContainerTemplates for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainerTemplates(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Container object
     * @summary List Containers for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceContainers(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceContainers(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Datastore object
     * @summary List Datastores for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceDatastores(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceDatastores(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Host object
     * @summary List Hosts for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceHosts(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceHosts(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Ipaddress object
     * @summary List Ipaddresses for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of NetworkAdapter object
     * @summary List NetworkAdapters for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Network object
     * @summary List Networks for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of OrchestrationStack object
     * @summary List OrchestrationStacks for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceOrchestrationStacks(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Ipaddress object
     * @summary List Ipaddresses for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of NetworkAdapter object
     * @summary List NetworkAdapters for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Network object
     * @summary List Networks for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of OrchestrationStack object
     * @summary List OrchestrationStacks for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionOrchestrationStacks(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SecurityGroup object
     * @summary List SecurityGroups for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstance object
     * @summary List ServiceInstances for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOffering object
     * @summary List ServiceOfferings for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionServiceOfferings(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServicePlan object
     * @summary List ServicePlans for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionServicePlans(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subnet object
     * @summary List Subnets for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Vm object
     * @summary List Vms for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionVms(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Volume object
     * @summary List Volumes for SourceRegion
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegionVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegionVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SourceRegion object
     * @summary List SourceRegion
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceRegions(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceRegions(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SecurityGroup object
     * @summary List SecurityGroups for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstanceNode object
     * @summary List ServiceInstanceNodes for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServiceInstanceNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServiceInstanceNodes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstance object
     * @summary List ServiceInstances for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInventory object
     * @summary List ServiceInventories for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServiceInventories(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServiceInventories(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOfferingNode object
     * @summary List ServiceOfferingNodes for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServiceOfferingNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServiceOfferingNodes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOffering object
     * @summary List ServiceOfferings for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServiceOfferings(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServicePlan object
     * @summary List ServicePlans for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceServicePlans(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SourceRegion object
     * @summary List SourceRegions for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceSourceRegions(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceSourceRegions(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subnet object
     * @summary List Subnets for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subscription object
     * @summary List Subscriptions for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceSubscriptions(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceSubscriptions(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Vm object
     * @summary List Vms for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceVms(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of VolumeType object
     * @summary List VolumeTypes for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceVolumeTypes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceVolumeTypes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Volume object
     * @summary List Volumes for Source
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSourceVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSourceVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Source object
     * @summary List Source
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSources(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSources(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Ipaddress object
     * @summary List Ipaddresses for Subnet
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubnetIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubnetIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of NetworkAdapter object
     * @summary List NetworkAdapters for Subnet
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubnetNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubnetNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for Subnet
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubnetTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubnetTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subnet object
     * @summary List Subnet
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubnets(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubnets(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Ipaddress object
     * @summary List Ipaddresses for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of NetworkAdapter object
     * @summary List NetworkAdapters for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Network object
     * @summary List Networks for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of OrchestrationStack object
     * @summary List OrchestrationStacks for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionOrchestrationStacks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionOrchestrationStacks(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SecurityGroup object
     * @summary List SecurityGroups for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInstance object
     * @summary List ServiceInstances for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionServiceInstances(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionServiceInstances(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOffering object
     * @summary List ServiceOfferings for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionServiceOfferings(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServicePlan object
     * @summary List ServicePlans for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionServicePlans(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionServicePlans(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subnet object
     * @summary List Subnets for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Vm object
     * @summary List Vms for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionVms(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Volume object
     * @summary List Volumes for Subscription
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptionVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptionVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subscription object
     * @summary List Subscription
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSubscriptions(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listSubscriptions(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerGroup object
     * @summary List ContainerGroups for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerImage object
     * @summary List ContainerImages for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerImages(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerImages(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerNode object
     * @summary List ContainerNodes for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerNodes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerNodes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerProject object
     * @summary List ContainerProjects for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerProjects(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerProjects(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ContainerTemplate object
     * @summary List ContainerTemplates for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagContainerTemplates(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagContainerTemplates(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Ipaddress object
     * @summary List Ipaddresses for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagIpaddresses(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagIpaddresses(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of NetworkAdapter object
     * @summary List NetworkAdapters for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Network object
     * @summary List Networks for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagNetworks(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagNetworks(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SecurityGroup object
     * @summary List SecurityGroups for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceInventory object
     * @summary List ServiceInventories for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagServiceInventories(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagServiceInventories(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of ServiceOffering object
     * @summary List ServiceOfferings for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagServiceOfferings(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagServiceOfferings(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Subnet object
     * @summary List Subnets for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagSubnets(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagSubnets(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Vm object
     * @summary List Vms for Tag
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTagVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTagVms(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tag
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTags(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTags(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Task object
     * @summary List Task
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTasks(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listTasks(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of NetworkAdapter object
     * @summary List NetworkAdapters for Vm
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVmNetworkAdapters(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVmNetworkAdapters(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of SecurityGroup object
     * @summary List SecurityGroups for Vm
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVmSecurityGroups(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVmSecurityGroups(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Tag object
     * @summary List Tags for Vm
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVmTags(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVmTags(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of VolumeAttachment object
     * @summary List VolumeAttachments for Vm
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVmVolumeAttachments(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVmVolumeAttachments(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Volume object
     * @summary List Volumes for Vm
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVmVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVmVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Vm object
     * @summary List Vm
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVms(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVms(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of VolumeAttachment object
     * @summary List VolumeAttachment
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVolumeAttachments(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVolumeAttachments(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Volume object
     * @summary List Volumes for VolumeType
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVolumeTypeVolumes(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVolumeTypeVolumes(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of VolumeType object
     * @summary List VolumeType
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVolumeTypes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVolumeTypes(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Vm object
     * @summary List Vms for Volume
     * @param {string} id ID of the resource
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVolumeVms(id: string, limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVolumeVms(id, limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of Volume object
     * @summary List Volume
     * @param {number} [limit] The numbers of items to return per page.
     * @param {number} [offset] The number of items to skip before starting to collect the result set.
     * @param {object} [filter] Filter for querying collections.
     * @param {string | Array<string>} [sortBy] The list of attribute and order to sort the result set by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listVolumes(limit?: number, offset?: number, filter?: object, sortBy?: string | Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).listVolumes(limit, offset, filter, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Task id
     * @summary Order an existing ServiceOffering
     * @param {string} id ID of the resource
     * @param {OrderParametersServiceOffering} orderParametersServiceOffering Order parameters defining the service and provider control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderServiceOffering(id: string, orderParametersServiceOffering: OrderParametersServiceOffering, options?: any) {
        return DefaultApiFp(this.configuration).orderServiceOffering(id, orderParametersServiceOffering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Task id
     * @summary Order an existing ServicePlan
     * @param {string} id ID of the resource
     * @param {OrderParametersServicePlan} orderParametersServicePlan Order parameters defining the service and provider control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderServicePlan(id: string, orderParametersServicePlan: OrderParametersServicePlan, options?: any) {
        return DefaultApiFp(this.configuration).orderServicePlan(id, orderParametersServicePlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Performs a GraphQL Query
     * @summary Perform a GraphQL Query
     * @param {GraphQLRequest} graphQLRequest GraphQL Query Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGraphQL(graphQLRequest: GraphQLRequest, options?: any) {
        return DefaultApiFp(this.configuration).postGraphQL(graphQLRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Cluster object
     * @summary Show an existing Cluster
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showCluster(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showCluster(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Container object
     * @summary Show an existing Container
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainer(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ContainerGroup object
     * @summary Show an existing ContainerGroup
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerGroup(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ContainerImage object
     * @summary Show an existing ContainerImage
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerImage(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ContainerNode object
     * @summary Show an existing ContainerNode
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerNode(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerNode(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ContainerProject object
     * @summary Show an existing ContainerProject
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerProject(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerProject(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ContainerResourceQuota object
     * @summary Show an existing ContainerResourceQuota
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerResourceQuota(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerResourceQuota(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ContainerTemplate object
     * @summary Show an existing ContainerTemplate
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showContainerTemplate(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showContainerTemplate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Datastore object
     * @summary Show an existing Datastore
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showDatastore(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showDatastore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Flavor object
     * @summary Show an existing Flavor
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showFlavor(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showFlavor(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Host object
     * @summary Show an existing Host
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showHost(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showHost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Ipaddress object
     * @summary Show an existing Ipaddre
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showIpaddress(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showIpaddress(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Network object
     * @summary Show an existing Network
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showNetwork(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showNetwork(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a NetworkAdapter object
     * @summary Show an existing NetworkAdapter
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showNetworkAdapter(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showNetworkAdapter(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a OrchestrationStack object
     * @summary Show an existing OrchestrationStack
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showOrchestrationStack(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showOrchestrationStack(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a SecurityGroup object
     * @summary Show an existing SecurityGroup
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showSecurityGroup(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showSecurityGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ServiceInstance object
     * @summary Show an existing ServiceInstance
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceInstance(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceInstance(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ServiceInstanceNode object
     * @summary Show an existing ServiceInstanceNode
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceInstanceNode(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceInstanceNode(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ServiceInventory object
     * @summary Show an existing ServiceInventory
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceInventory(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceInventory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ServiceOffering object
     * @summary Show an existing ServiceOffering
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceOffering(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceOffering(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ServiceOfferingIcon object
     * @summary Show an existing ServiceOfferingIcon
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceOfferingIcon(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceOfferingIcon(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ServiceOfferingIcon IconData
     * @summary Show an existing ServiceOfferingIcon IconData
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceOfferingIconIconData(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceOfferingIconIconData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ServiceOfferingNode object
     * @summary Show an existing ServiceOfferingNode
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServiceOfferingNode(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServiceOfferingNode(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ServicePlan object
     * @summary Show an existing ServicePlan
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showServicePlan(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showServicePlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Source object
     * @summary Show an existing Source
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showSource(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a SourceRegion object
     * @summary Show an existing SourceRegion
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showSourceRegion(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showSourceRegion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Subnet object
     * @summary Show an existing Subnet
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showSubnet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showSubnet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Subscription object
     * @summary Show an existing Subscription
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showSubscription(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showSubscription(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Tag object
     * @summary Show an existing Tag
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showTag(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showTag(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Task object
     * @summary Show an existing Task
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showTask(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Vm object
     * @summary Show an existing Vm
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showVm(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showVm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Volume object
     * @summary Show an existing Volume
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showVolume(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showVolume(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a VolumeAttachment object
     * @summary Show an existing VolumeAttachment
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showVolumeAttachment(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showVolumeAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a VolumeType object
     * @summary Show an existing VolumeType
     * @param {string} id ID of the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public showVolumeType(id: string, options?: any) {
        return DefaultApiFp(this.configuration).showVolumeType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Task object
     * @summary Update an existing Task
     * @param {string} id ID of the resource
     * @param {Task} task Task attributes to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateTask(id: string, task: Task, options?: any) {
        return DefaultApiFp(this.configuration).updateTask(id, task, options).then((request) => request(this.axios, this.basePath));
    }

}


