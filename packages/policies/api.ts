/* tslint:disable */
/* eslint-disable */
/**
 * Policies
 * The API for Policies
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Fact
 */
export interface Fact {
    /**
     *
     * @type {number}
     * @memberof Fact
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Fact
     */
    'name'?: string;
    /**
     *
     * @type {FactType}
     * @memberof Fact
     */
    'type'?: FactType;
}
/**
 *
 * @export
 * @enum {string}
 */

export const FactType = {
    String: 'STRING',
    Boolean: 'BOOLEAN',
    List: 'LIST',
    Int: 'INT'
} as const;

export type FactType = typeof FactType[keyof typeof FactType];


/**
 * A single history item for a fired trigger on a host
 * @export
 * @interface HistoryItem
 */
export interface HistoryItem {
    /**
     * Fire time (since the epoch)
     * @type {number}
     * @memberof HistoryItem
     */
    'ctime'?: number;
    /**
     * Host id
     * @type {string}
     * @memberof HistoryItem
     */
    'id'?: string;
    /**
     * Host name
     * @type {string}
     * @memberof HistoryItem
     */
    'hostName'?: string;
}
/**
 *
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     *
     * @type {number}
     * @memberof Meta
     */
    'count'?: number;
}
/**
 * Reason for failure
 * @export
 * @interface Msg
 */
export interface Msg {
    /**
     *
     * @type {string}
     * @memberof Msg
     */
    'msg'?: string;
}
/**
 *
 * @export
 * @interface PagedResponseOfHistoryItem
 */
export interface PagedResponseOfHistoryItem {
    /**
     *
     * @type {Meta}
     * @memberof PagedResponseOfHistoryItem
     */
    'meta'?: Meta;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof PagedResponseOfHistoryItem
     */
    'links'?: { [key: string]: string; };
    /**
     *
     * @type {Array<HistoryItem>}
     * @memberof PagedResponseOfHistoryItem
     */
    'data'?: Array<HistoryItem>;
}
/**
 *
 * @export
 * @interface PagedResponseOfPolicy
 */
export interface PagedResponseOfPolicy {
    /**
     *
     * @type {Meta}
     * @memberof PagedResponseOfPolicy
     */
    'meta'?: Meta;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof PagedResponseOfPolicy
     */
    'links'?: { [key: string]: string; };
    /**
     *
     * @type {Array<Policy>}
     * @memberof PagedResponseOfPolicy
     */
    'data'?: Array<Policy>;
}
/**
 *
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    'id'?: string;
    /**
     * Name of the rule. Must be unique per customer organization.
     * @type {string}
     * @memberof Policy
     */
    'name': string;
    /**
     * A short description of the policy.
     * @type {string}
     * @memberof Policy
     */
    'description'?: string;
    /**
     *
     * @type {boolean}
     * @memberof Policy
     */
    'isEnabled'?: boolean;
    /**
     * Condition string.
     * @type {string}
     * @memberof Policy
     */
    'conditions': string;
    /**
     * String describing actions separated by \';\' when the policy is evaluated to true.Allowed values is \'notification\'
     * @type {string}
     * @memberof Policy
     */
    'actions'?: string;
    /**
     * Last update time in a form like \'2020-01-24 12:19:56.718\', output only
     * @type {string}
     * @memberof Policy
     */
    'mtime'?: string;
    /**
     * Create time in a form like \'2020-01-24 12:19:56.718\', output only
     * @type {string}
     * @memberof Policy
     */
    'ctime'?: string;
    /**
     *
     * @type {number}
     * @memberof Policy
     */
    'lastTriggered'?: number;
}
/**
 *
 * @export
 * @interface UserPreferences
 */
export interface UserPreferences {
    /**
     *
     * @type {boolean}
     * @memberof UserPreferences
     */
    'instant_email'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof UserPreferences
     */
    'daily_email'?: boolean;
}

/**
 * BasePathFillerServiceApi - axios parameter creator
 * @export
 */
export const BasePathFillerServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Just a filler to have a defined return code for the base path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasePathFillerServiceApi - functional programming interface
 * @export
 */
export const BasePathFillerServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasePathFillerServiceApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Just a filler to have a defined return code for the base path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BasePathFillerServiceApi - factory interface
 * @export
 */
export const BasePathFillerServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasePathFillerServiceApiFp(configuration)
    return {
        /**
         *
         * @summary Just a filler to have a defined return code for the base path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: any): AxiosPromise<void> {
            return localVarFp.get(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasePathFillerServiceApi - object-oriented interface
 * @export
 * @class BasePathFillerServiceApi
 * @extends {BaseAPI}
 */
export class BasePathFillerServiceApi extends BaseAPI {
    /**
     *
     * @summary Just a filler to have a defined return code for the base path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasePathFillerServiceApi
     */
    public get(options?: AxiosRequestConfig) {
        return BasePathFillerServiceApiFp(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactServiceApi - axios parameter creator
 * @export
 */
export const FactServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Retrieve a list of fact (keys) along with their data types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFacts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/facts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactServiceApi - functional programming interface
 * @export
 */
export const FactServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactServiceApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Retrieve a list of fact (keys) along with their data types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFacts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFacts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FactServiceApi - factory interface
 * @export
 */
export const FactServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactServiceApiFp(configuration)
    return {
        /**
         *
         * @summary Retrieve a list of fact (keys) along with their data types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFacts(options?: any): AxiosPromise<Array<Fact>> {
            return localVarFp.getFacts(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactServiceApi - object-oriented interface
 * @export
 * @class FactServiceApi
 * @extends {BaseAPI}
 */
export class FactServiceApi extends BaseAPI {
    /**
     *
     * @summary Retrieve a list of fact (keys) along with their data types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactServiceApi
     */
    public getFacts(options?: AxiosRequestConfig) {
        return FactServiceApiFp(this.configuration).getFacts(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PolicyCrudServiceApi - axios parameter creator
 * @export
 */
export const PolicyCrudServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete a single policy for a customer by its id
         * @param {string} id UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoliciesById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePoliciesById', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoliciesIds: async (requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all policies for a given account
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropDescription] Operations used with the filter
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropName] Operations used with the filter
         * @param {string} [filterDescription] Filtering policies by the description depending on the Filter operator used.
         * @param {'true' | 'false'} [filterIsEnabled] Filtering policies by the is_enabled field.Defaults to true if no operand is given.
         * @param {string} [filterName] Filtering policies by the name depending on the Filter operator used.
         * @param {number} [limit] Number of items per page, if not specified uses 50. -1 can be used to specify an unlimited page, when specified it ignores the offset
         * @param {number} [offset] Page number, starts 0, if not specified uses 0.
         * @param {'name' | 'description' | 'is_enabled' | 'mtime' | 'last_triggered'} [sortColumn] Column to sort the results by
         * @param {'asc' | 'desc'} [sortDirection] Sort direction used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies: async (filteropDescription?: 'equal' | 'like' | 'ilike' | 'not_equal', filteropName?: 'equal' | 'like' | 'ilike' | 'not_equal', filterDescription?: string, filterIsEnabled?: 'true' | 'false', filterName?: string, limit?: number, offset?: number, sortColumn?: 'name' | 'description' | 'is_enabled' | 'mtime' | 'last_triggered', sortDirection?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filteropDescription !== undefined) {
                localVarQueryParameter['filter:op[description]'] = filteropDescription;
            }

            if (filteropName !== undefined) {
                localVarQueryParameter['filter:op[name]'] = filteropName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (filterIsEnabled !== undefined) {
                localVarQueryParameter['filter[is_enabled]'] = filterIsEnabled;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortColumn !== undefined) {
                localVarQueryParameter['sortColumn'] = sortColumn;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a single policy for a customer by its id
         * @param {string} id UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoliciesById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPoliciesById', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve the trigger history of a single policy
         * @param {string} id UUID of the policy
         * @param {'equal' | 'not_equal' | 'like'} [filteropId] Operations used with the name filter
         * @param {'equal' | 'like' | 'not_equal'} [filteropName] Operations used with the name filter
         * @param {string} [filterId] Filtering history entries by the id depending on the Filter operator used.
         * @param {string} [filterName] Filtering history entries by the host name depending on the Filter operator used.
         * @param {number} [limit] Number of items per page, if not specified uses 50. Maximum value is 200.
         * @param {number} [offset] Page number, starts 0, if not specified uses 0.
         * @param {'hostName' | 'ctime'} [sortColumn] Column to sort the results by
         * @param {'asc' | 'desc'} [sortDirection] Sort direction used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoliciesByIdHistoryTrigger: async (id: string, filteropId?: 'equal' | 'not_equal' | 'like', filteropName?: 'equal' | 'like' | 'not_equal', filterId?: string, filterName?: string, limit?: number, offset?: number, sortColumn?: 'hostName' | 'ctime', sortDirection?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPoliciesByIdHistoryTrigger', 'id', id)
            const localVarPath = `/policies/{id}/history/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filteropId !== undefined) {
                localVarQueryParameter['filter:op[id]'] = filteropId;
            }

            if (filteropName !== undefined) {
                localVarQueryParameter['filter:op[name]'] = filteropName;
            }

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortColumn !== undefined) {
                localVarQueryParameter['sortColumn'] = sortColumn;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return all policy ids for a given account after applying the filters
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropDescription] Operations used with the filter
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropName] Operations used with the filter
         * @param {string} [filterDescription] Filtering policies by the description depending on the Filter operator used.
         * @param {'true' | 'false'} [filterIsEnabled] Filtering policies by the is_enabled field.Defaults to true if no operand is given.
         * @param {string} [filterName] Filtering policies by the name depending on the Filter operator used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoliciesIds: async (filteropDescription?: 'equal' | 'like' | 'ilike' | 'not_equal', filteropName?: 'equal' | 'like' | 'ilike' | 'not_equal', filterDescription?: string, filterIsEnabled?: 'true' | 'false', filterName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filteropDescription !== undefined) {
                localVarQueryParameter['filter:op[description]'] = filteropDescription;
            }

            if (filteropName !== undefined) {
                localVarQueryParameter['filter:op[name]'] = filteropName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (filterIsEnabled !== undefined) {
                localVarQueryParameter['filter[is_enabled]'] = filterIsEnabled;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validate (and possibly persist) a passed policy for the given account
         * @param {boolean} [alsoStore] If passed and set to true, the passed policy is also persisted (if it is valid)
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPolicies: async (alsoStore?: boolean, policy?: Policy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (alsoStore !== undefined) {
                localVarQueryParameter['alsoStore'] = alsoStore;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Enable/disable a policy
         * @param {string} id ID of the Policy
         * @param {boolean} [enabled] Should the policy be enabled (true) or disabled (false, default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPoliciesByIdEnabled: async (id: string, enabled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postPoliciesByIdEnabled', 'id', id)
            const localVarPath = `/policies/{id}/enabled`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Enable/disable policies identified by list of uuid in body
         * @param {boolean} [enabled]
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPoliciesIdsEnabled: async (enabled?: boolean, requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/ids/enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validates a Policy condition
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPoliciesValidate: async (policy?: Policy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validates the Policy.name and verifies if it is unique.
         * @param {string} body
         * @param {string} [id] UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPoliciesValidateName: async (body: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postPoliciesValidateName', 'body', body)
            const localVarPath = `/policies/validate-name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a single policy for a customer by its id
         * @param {string} policyId
         * @param {boolean} [dry]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPoliciesByPolicyId: async (policyId: string, dry?: boolean, policy?: Policy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('putPoliciesByPolicyId', 'policyId', policyId)
            const localVarPath = `/policies/{policyId}`
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dry !== undefined) {
                localVarQueryParameter['dry'] = dry;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyCrudServiceApi - functional programming interface
 * @export
 */
export const PolicyCrudServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyCrudServiceApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Delete a single policy for a customer by its id
         * @param {string} id UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePoliciesById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePoliciesById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePoliciesIds(requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePoliciesIds(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Return all policies for a given account
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropDescription] Operations used with the filter
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropName] Operations used with the filter
         * @param {string} [filterDescription] Filtering policies by the description depending on the Filter operator used.
         * @param {'true' | 'false'} [filterIsEnabled] Filtering policies by the is_enabled field.Defaults to true if no operand is given.
         * @param {string} [filterName] Filtering policies by the name depending on the Filter operator used.
         * @param {number} [limit] Number of items per page, if not specified uses 50. -1 can be used to specify an unlimited page, when specified it ignores the offset
         * @param {number} [offset] Page number, starts 0, if not specified uses 0.
         * @param {'name' | 'description' | 'is_enabled' | 'mtime' | 'last_triggered'} [sortColumn] Column to sort the results by
         * @param {'asc' | 'desc'} [sortDirection] Sort direction used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicies(filteropDescription?: 'equal' | 'like' | 'ilike' | 'not_equal', filteropName?: 'equal' | 'like' | 'ilike' | 'not_equal', filterDescription?: string, filterIsEnabled?: 'true' | 'false', filterName?: string, limit?: number, offset?: number, sortColumn?: 'name' | 'description' | 'is_enabled' | 'mtime' | 'last_triggered', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponseOfPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(filteropDescription, filteropName, filterDescription, filterIsEnabled, filterName, limit, offset, sortColumn, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Retrieve a single policy for a customer by its id
         * @param {string} id UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoliciesById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoliciesById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Retrieve the trigger history of a single policy
         * @param {string} id UUID of the policy
         * @param {'equal' | 'not_equal' | 'like'} [filteropId] Operations used with the name filter
         * @param {'equal' | 'like' | 'not_equal'} [filteropName] Operations used with the name filter
         * @param {string} [filterId] Filtering history entries by the id depending on the Filter operator used.
         * @param {string} [filterName] Filtering history entries by the host name depending on the Filter operator used.
         * @param {number} [limit] Number of items per page, if not specified uses 50. Maximum value is 200.
         * @param {number} [offset] Page number, starts 0, if not specified uses 0.
         * @param {'hostName' | 'ctime'} [sortColumn] Column to sort the results by
         * @param {'asc' | 'desc'} [sortDirection] Sort direction used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoliciesByIdHistoryTrigger(id: string, filteropId?: 'equal' | 'not_equal' | 'like', filteropName?: 'equal' | 'like' | 'not_equal', filterId?: string, filterName?: string, limit?: number, offset?: number, sortColumn?: 'hostName' | 'ctime', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedResponseOfHistoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoliciesByIdHistoryTrigger(id, filteropId, filteropName, filterId, filterName, limit, offset, sortColumn, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Return all policy ids for a given account after applying the filters
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropDescription] Operations used with the filter
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropName] Operations used with the filter
         * @param {string} [filterDescription] Filtering policies by the description depending on the Filter operator used.
         * @param {'true' | 'false'} [filterIsEnabled] Filtering policies by the is_enabled field.Defaults to true if no operand is given.
         * @param {string} [filterName] Filtering policies by the name depending on the Filter operator used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoliciesIds(filteropDescription?: 'equal' | 'like' | 'ilike' | 'not_equal', filteropName?: 'equal' | 'like' | 'ilike' | 'not_equal', filterDescription?: string, filterIsEnabled?: 'true' | 'false', filterName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoliciesIds(filteropDescription, filteropName, filterDescription, filterIsEnabled, filterName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Validate (and possibly persist) a passed policy for the given account
         * @param {boolean} [alsoStore] If passed and set to true, the passed policy is also persisted (if it is valid)
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPolicies(alsoStore?: boolean, policy?: Policy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPolicies(alsoStore, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Enable/disable a policy
         * @param {string} id ID of the Policy
         * @param {boolean} [enabled] Should the policy be enabled (true) or disabled (false, default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPoliciesByIdEnabled(id: string, enabled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPoliciesByIdEnabled(id, enabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Enable/disable policies identified by list of uuid in body
         * @param {boolean} [enabled]
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPoliciesIdsEnabled(enabled?: boolean, requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPoliciesIdsEnabled(enabled, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Validates a Policy condition
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPoliciesValidate(policy?: Policy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPoliciesValidate(policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Validates the Policy.name and verifies if it is unique.
         * @param {string} body
         * @param {string} [id] UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPoliciesValidateName(body: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Msg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPoliciesValidateName(body, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a single policy for a customer by its id
         * @param {string} policyId
         * @param {boolean} [dry]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPoliciesByPolicyId(policyId: string, dry?: boolean, policy?: Policy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPoliciesByPolicyId(policyId, dry, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolicyCrudServiceApi - factory interface
 * @export
 */
export const PolicyCrudServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyCrudServiceApiFp(configuration)
    return {
        /**
         *
         * @summary Delete a single policy for a customer by its id
         * @param {string} id UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoliciesById(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePoliciesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoliciesIds(requestBody?: Array<string>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.deletePoliciesIds(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all policies for a given account
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropDescription] Operations used with the filter
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropName] Operations used with the filter
         * @param {string} [filterDescription] Filtering policies by the description depending on the Filter operator used.
         * @param {'true' | 'false'} [filterIsEnabled] Filtering policies by the is_enabled field.Defaults to true if no operand is given.
         * @param {string} [filterName] Filtering policies by the name depending on the Filter operator used.
         * @param {number} [limit] Number of items per page, if not specified uses 50. -1 can be used to specify an unlimited page, when specified it ignores the offset
         * @param {number} [offset] Page number, starts 0, if not specified uses 0.
         * @param {'name' | 'description' | 'is_enabled' | 'mtime' | 'last_triggered'} [sortColumn] Column to sort the results by
         * @param {'asc' | 'desc'} [sortDirection] Sort direction used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(filteropDescription?: 'equal' | 'like' | 'ilike' | 'not_equal', filteropName?: 'equal' | 'like' | 'ilike' | 'not_equal', filterDescription?: string, filterIsEnabled?: 'true' | 'false', filterName?: string, limit?: number, offset?: number, sortColumn?: 'name' | 'description' | 'is_enabled' | 'mtime' | 'last_triggered', sortDirection?: 'asc' | 'desc', options?: any): AxiosPromise<PagedResponseOfPolicy> {
            return localVarFp.getPolicies(filteropDescription, filteropName, filterDescription, filterIsEnabled, filterName, limit, offset, sortColumn, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a single policy for a customer by its id
         * @param {string} id UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoliciesById(id: string, options?: any): AxiosPromise<Policy> {
            return localVarFp.getPoliciesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve the trigger history of a single policy
         * @param {string} id UUID of the policy
         * @param {'equal' | 'not_equal' | 'like'} [filteropId] Operations used with the name filter
         * @param {'equal' | 'like' | 'not_equal'} [filteropName] Operations used with the name filter
         * @param {string} [filterId] Filtering history entries by the id depending on the Filter operator used.
         * @param {string} [filterName] Filtering history entries by the host name depending on the Filter operator used.
         * @param {number} [limit] Number of items per page, if not specified uses 50. Maximum value is 200.
         * @param {number} [offset] Page number, starts 0, if not specified uses 0.
         * @param {'hostName' | 'ctime'} [sortColumn] Column to sort the results by
         * @param {'asc' | 'desc'} [sortDirection] Sort direction used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoliciesByIdHistoryTrigger(id: string, filteropId?: 'equal' | 'not_equal' | 'like', filteropName?: 'equal' | 'like' | 'not_equal', filterId?: string, filterName?: string, limit?: number, offset?: number, sortColumn?: 'hostName' | 'ctime', sortDirection?: 'asc' | 'desc', options?: any): AxiosPromise<PagedResponseOfHistoryItem> {
            return localVarFp.getPoliciesByIdHistoryTrigger(id, filteropId, filteropName, filterId, filterName, limit, offset, sortColumn, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return all policy ids for a given account after applying the filters
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropDescription] Operations used with the filter
         * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropName] Operations used with the filter
         * @param {string} [filterDescription] Filtering policies by the description depending on the Filter operator used.
         * @param {'true' | 'false'} [filterIsEnabled] Filtering policies by the is_enabled field.Defaults to true if no operand is given.
         * @param {string} [filterName] Filtering policies by the name depending on the Filter operator used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoliciesIds(filteropDescription?: 'equal' | 'like' | 'ilike' | 'not_equal', filteropName?: 'equal' | 'like' | 'ilike' | 'not_equal', filterDescription?: string, filterIsEnabled?: 'true' | 'false', filterName?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getPoliciesIds(filteropDescription, filteropName, filterDescription, filterIsEnabled, filterName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validate (and possibly persist) a passed policy for the given account
         * @param {boolean} [alsoStore] If passed and set to true, the passed policy is also persisted (if it is valid)
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPolicies(alsoStore?: boolean, policy?: Policy, options?: any): AxiosPromise<void> {
            return localVarFp.postPolicies(alsoStore, policy, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Enable/disable a policy
         * @param {string} id ID of the Policy
         * @param {boolean} [enabled] Should the policy be enabled (true) or disabled (false, default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPoliciesByIdEnabled(id: string, enabled?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.postPoliciesByIdEnabled(id, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Enable/disable policies identified by list of uuid in body
         * @param {boolean} [enabled]
         * @param {Array<string>} [requestBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPoliciesIdsEnabled(enabled?: boolean, requestBody?: Array<string>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.postPoliciesIdsEnabled(enabled, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validates a Policy condition
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPoliciesValidate(policy?: Policy, options?: any): AxiosPromise<Msg> {
            return localVarFp.postPoliciesValidate(policy, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validates the Policy.name and verifies if it is unique.
         * @param {string} body
         * @param {string} [id] UUID of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPoliciesValidateName(body: string, id?: string, options?: any): AxiosPromise<Msg> {
            return localVarFp.postPoliciesValidateName(body, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a single policy for a customer by its id
         * @param {string} policyId
         * @param {boolean} [dry]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPoliciesByPolicyId(policyId: string, dry?: boolean, policy?: Policy, options?: any): AxiosPromise<Policy> {
            return localVarFp.putPoliciesByPolicyId(policyId, dry, policy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyCrudServiceApi - object-oriented interface
 * @export
 * @class PolicyCrudServiceApi
 * @extends {BaseAPI}
 */
export class PolicyCrudServiceApi extends BaseAPI {
    /**
     *
     * @summary Delete a single policy for a customer by its id
     * @param {string} id UUID of the policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public deletePoliciesById(id: string, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).deletePoliciesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete policies for a customer by the ids passed in the body. Result will be a list of deleted UUIDs
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public deletePoliciesIds(requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).deletePoliciesIds(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all policies for a given account
     * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropDescription] Operations used with the filter
     * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropName] Operations used with the filter
     * @param {string} [filterDescription] Filtering policies by the description depending on the Filter operator used.
     * @param {'true' | 'false'} [filterIsEnabled] Filtering policies by the is_enabled field.Defaults to true if no operand is given.
     * @param {string} [filterName] Filtering policies by the name depending on the Filter operator used.
     * @param {number} [limit] Number of items per page, if not specified uses 50. -1 can be used to specify an unlimited page, when specified it ignores the offset
     * @param {number} [offset] Page number, starts 0, if not specified uses 0.
     * @param {'name' | 'description' | 'is_enabled' | 'mtime' | 'last_triggered'} [sortColumn] Column to sort the results by
     * @param {'asc' | 'desc'} [sortDirection] Sort direction used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public getPolicies(filteropDescription?: 'equal' | 'like' | 'ilike' | 'not_equal', filteropName?: 'equal' | 'like' | 'ilike' | 'not_equal', filterDescription?: string, filterIsEnabled?: 'true' | 'false', filterName?: string, limit?: number, offset?: number, sortColumn?: 'name' | 'description' | 'is_enabled' | 'mtime' | 'last_triggered', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).getPolicies(filteropDescription, filteropName, filterDescription, filterIsEnabled, filterName, limit, offset, sortColumn, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Retrieve a single policy for a customer by its id
     * @param {string} id UUID of the policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public getPoliciesById(id: string, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).getPoliciesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Retrieve the trigger history of a single policy
     * @param {string} id UUID of the policy
     * @param {'equal' | 'not_equal' | 'like'} [filteropId] Operations used with the name filter
     * @param {'equal' | 'like' | 'not_equal'} [filteropName] Operations used with the name filter
     * @param {string} [filterId] Filtering history entries by the id depending on the Filter operator used.
     * @param {string} [filterName] Filtering history entries by the host name depending on the Filter operator used.
     * @param {number} [limit] Number of items per page, if not specified uses 50. Maximum value is 200.
     * @param {number} [offset] Page number, starts 0, if not specified uses 0.
     * @param {'hostName' | 'ctime'} [sortColumn] Column to sort the results by
     * @param {'asc' | 'desc'} [sortDirection] Sort direction used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public getPoliciesByIdHistoryTrigger(id: string, filteropId?: 'equal' | 'not_equal' | 'like', filteropName?: 'equal' | 'like' | 'not_equal', filterId?: string, filterName?: string, limit?: number, offset?: number, sortColumn?: 'hostName' | 'ctime', sortDirection?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).getPoliciesByIdHistoryTrigger(id, filteropId, filteropName, filterId, filterName, limit, offset, sortColumn, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Return all policy ids for a given account after applying the filters
     * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropDescription] Operations used with the filter
     * @param {'equal' | 'like' | 'ilike' | 'not_equal'} [filteropName] Operations used with the filter
     * @param {string} [filterDescription] Filtering policies by the description depending on the Filter operator used.
     * @param {'true' | 'false'} [filterIsEnabled] Filtering policies by the is_enabled field.Defaults to true if no operand is given.
     * @param {string} [filterName] Filtering policies by the name depending on the Filter operator used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public getPoliciesIds(filteropDescription?: 'equal' | 'like' | 'ilike' | 'not_equal', filteropName?: 'equal' | 'like' | 'ilike' | 'not_equal', filterDescription?: string, filterIsEnabled?: 'true' | 'false', filterName?: string, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).getPoliciesIds(filteropDescription, filteropName, filterDescription, filterIsEnabled, filterName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Validate (and possibly persist) a passed policy for the given account
     * @param {boolean} [alsoStore] If passed and set to true, the passed policy is also persisted (if it is valid)
     * @param {Policy} [policy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public postPolicies(alsoStore?: boolean, policy?: Policy, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).postPolicies(alsoStore, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Enable/disable a policy
     * @param {string} id ID of the Policy
     * @param {boolean} [enabled] Should the policy be enabled (true) or disabled (false, default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public postPoliciesByIdEnabled(id: string, enabled?: boolean, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).postPoliciesByIdEnabled(id, enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Enable/disable policies identified by list of uuid in body
     * @param {boolean} [enabled]
     * @param {Array<string>} [requestBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public postPoliciesIdsEnabled(enabled?: boolean, requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).postPoliciesIdsEnabled(enabled, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Validates a Policy condition
     * @param {Policy} [policy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public postPoliciesValidate(policy?: Policy, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).postPoliciesValidate(policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Validates the Policy.name and verifies if it is unique.
     * @param {string} body
     * @param {string} [id] UUID of the policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public postPoliciesValidateName(body: string, id?: string, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).postPoliciesValidateName(body, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a single policy for a customer by its id
     * @param {string} policyId
     * @param {boolean} [dry]
     * @param {Policy} [policy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyCrudServiceApi
     */
    public putPoliciesByPolicyId(policyId: string, dry?: boolean, policy?: Policy, options?: AxiosRequestConfig) {
        return PolicyCrudServiceApiFp(this.configuration).putPoliciesByPolicyId(policyId, dry, policy, options).then((request) => request(this.axios, this.basePath));
    }
}


