// tslint:disable
/**
 * Vulnerability Engine Manager
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AffectedSystemsIdsOut
 */
export interface AffectedSystemsIdsOut {
    /**
     *
     * @type {string | Array<string>}
     * @memberof AffectedSystemsIdsOut
     */
    data: string | Array<string>;
    /**
     *
     * @type {Links}
     * @memberof AffectedSystemsIdsOut
     */
    links: Links;
    /**
     *
     * @type {MetaAffectedSystems}
     * @memberof AffectedSystemsIdsOut
     */
    meta: MetaAffectedSystems;
}
/**
 *
 * @export
 * @interface AffectedSystemsOut
 */
export interface AffectedSystemsOut {
    /**
     *
     * @type {string | Array<object>}
     * @memberof AffectedSystemsOut
     */
    data: string | Array<object>;
    /**
     *
     * @type {Links}
     * @memberof AffectedSystemsOut
     */
    links: Links;
    /**
     *
     * @type {MetaAffectedSystems}
     * @memberof AffectedSystemsOut
     */
    meta: MetaAffectedSystems;
}
/**
 *
 * @export
 * @interface BulkChangeOut
 */
export interface BulkChangeOut {
    /**
     * List of updated objects/updated object IDs.
     * @type {Array<string>}
     * @memberof BulkChangeOut
     */
    updated: Array<string>;
}
/**
 *
 * @export
 * @interface BusinessRiskListOut
 */
export interface BusinessRiskListOut {
    /**
     * List of available business risk/business_risk_id pairs.
     * @type {Array<BusinessRiskListOutData>}
     * @memberof BusinessRiskListOut
     */
    data: Array<BusinessRiskListOutData>;
    /**
     *
     * @type {BusinessRiskListOutMeta}
     * @memberof BusinessRiskListOut
     */
    meta: BusinessRiskListOutMeta;
}
/**
 *
 * @export
 * @interface BusinessRiskListOutData
 */
export interface BusinessRiskListOutData {
    /**
     * Internal business_risk_id.
     * @type {number}
     * @memberof BusinessRiskListOutData
     */
    id: number;
    /**
     * Represenation of internal business_risk_id.
     * @type {string}
     * @memberof BusinessRiskListOutData
     */
    name: string;
}
/**
 *
 * @export
 * @interface BusinessRiskListOutMeta
 */
export interface BusinessRiskListOutMeta {
    /**
     * Total number of available business risk/business_risk_id pairs.
     * @type {number}
     * @memberof BusinessRiskListOutMeta
     */
    total_items: number;
}
/**
 *
 * @export
 * @interface CveDetailOut
 */
export interface CveDetailOut {
    /**
     *
     * @type {CveDetailOutData}
     * @memberof CveDetailOut
     */
    data?: CveDetailOutData;
}
/**
 *
 * @export
 * @interface CveDetailOutData
 */
export interface CveDetailOutData {
    /**
     * CVE id.
     * @type {string}
     * @memberof CveDetailOutData
     */
    id: string;
    /**
     * Type of the record.
     * @type {string}
     * @memberof CveDetailOutData
     */
    type: string;
    /**
     * If show_advisories_details=true shows access to patch service else null
     * @type {boolean}
     * @memberof CveDetailOutData
     */
    patch_access: boolean | null;
    /**
     *
     * @type {CveDetailOutDataAttributes}
     * @memberof CveDetailOutData
     */
    attributes: CveDetailOutDataAttributes;
}
/**
 *
 * @export
 * @interface CveDetailOutDataAttributes
 */
export interface CveDetailOutDataAttributes {
    /**
     * Business risk of the vulnerability.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    business_risk: string;
    /**
     * Internal ID of the vulnerability business risk.
     * @type {number}
     * @memberof CveDetailOutDataAttributes
     */
    business_risk_id: number;
    /**
     * Complementary text to the business risk.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    business_risk_text: string | null;
    /**
     * cvss2 metrics of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    cvss2_metrics: string | null;
    /**
     * String representation of cvss2 score of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    cvss2_score: string | null;
    /**
     * cvss3 metrics of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    cvss3_metrics: string | null;
    /**
     * String representation of cvss3 score of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    cvss3_score: string | null;
    /**
     * Description of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    description: string;
    /**
     * String representation of ISO-8601 formatted date of last modification of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    modified_date: string | null;
    /**
     * Red Hat security impact of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    impact: string;
    /**
     * String representation of ISO-8601 formatted date of first public disclosure of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    public_date: string | null;
    /**
     * Additional resource about the CVE, provided by Red Hat.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    redhat_url: string | null;
    /**
     *
     * @type {Array<InsightsRule>}
     * @memberof CveDetailOutDataAttributes
     */
    rules: Array<InsightsRule>;
    /**
     * Additional resources about the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    secondary_url: string | null;
    /**
     * Status of the vulnerability.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    status: string;
    /**
     * Internal ID of the vulnerability status.
     * @type {number}
     * @memberof CveDetailOutDataAttributes
     */
    status_id: number;
    /**
     * Complementary text to the status.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    status_text: string | null;
    /**
     * Synopsis of the CVE.
     * @type {string}
     * @memberof CveDetailOutDataAttributes
     */
    synopsis: string;
    /**
     * Counts of systems with given status type.
     * @type {object}
     * @memberof CveDetailOutDataAttributes
     */
    systems_status_detail: object;
    /**
     * How many systems-CVE pairs have different status than CVE-level.
     * @type {number}
     * @memberof CveDetailOutDataAttributes
     */
    systems_status_divergent: number;
    /**
     * List of advisory names or detailed advisory information
     * @type {Array<string | object>}
     * @memberof CveDetailOutDataAttributes
     */
    advisories_list: Array<string | object> | null;
}
/**
 * @type CveOrList
 * @export
 */
export type CveOrList = Array<string> | string;

/**
 *
 * @export
 * @interface CveRiskIn
 */
export interface CveRiskIn {
    /**
     *
     * @type {CveOrList}
     * @memberof CveRiskIn
     */
    cve: CveOrList;
    /**
     * Business risk ID to be set, obtained by GET method.
     * @type {number}
     * @memberof CveRiskIn
     */
    business_risk_id?: number;
    /**
     * Complementary text to the business risk.
     * @type {string}
     * @memberof CveRiskIn
     */
    business_risk_text?: string | null;
}
/**
 *
 * @export
 * @interface CveStatusIn
 */
export interface CveStatusIn {
    /**
     *
     * @type {CveOrList}
     * @memberof CveStatusIn
     */
    cve: CveOrList;
    /**
     * Status ID to be set, obtained by GET method.
     * @type {number}
     * @memberof CveStatusIn
     */
    status_id?: number;
    /**
     * Complementary text to the status.
     * @type {string}
     * @memberof CveStatusIn
     */
    status_text?: string | null;
}
/**
 *
 * @export
 * @interface Errors
 */
export interface Errors {
    /**
     *
     * @type {Array<ErrorsErrors>}
     * @memberof Errors
     */
    errors: Array<ErrorsErrors>;
}
/**
 *
 * @export
 * @interface ErrorsErrors
 */
export interface ErrorsErrors {
    /**
     * Error detail.
     * @type {string}
     * @memberof ErrorsErrors
     */
    detail: string;
    /**
     * String representation of HTTP status code.
     * @type {string}
     * @memberof ErrorsErrors
     */
    status: string;
}
/**
 *
 * @export
 * @interface ExecutiveReport
 */
export interface ExecutiveReport {
    /**
     * Total number of systems managed by vulnerability application.
     * @type {number}
     * @memberof ExecutiveReport
     */
    system_count: number;
    /**
     * Number of unique CVEs discovered on the managed systems.
     * @type {number}
     * @memberof ExecutiveReport
     */
    cves_total: number;
    /**
     *
     * @type {ExecutiveReportCvesBySeverity}
     * @memberof ExecutiveReport
     */
    cves_by_severity: ExecutiveReportCvesBySeverity;
    /**
     *
     * @type {ExecutiveReportRecentCves}
     * @memberof ExecutiveReport
     */
    recent_cves: ExecutiveReportRecentCves;
    /**
     *
     * @type {Array<ExecutiveReportTopCves>}
     * @memberof ExecutiveReport
     */
    top_cves?: Array<ExecutiveReportTopCves>;
}
/**
 * Number of CVEs discovered on the managed systems, divided into buckets based on their CVSSv3 score (CVSSv2 is used when CVSSv3 is not available).
 * @export
 * @interface ExecutiveReportCvesBySeverity
 */
export interface ExecutiveReportCvesBySeverity {
    /**
     *
     * @type {ExecutiveReportCvesBySeverity0to39}
     * @memberof ExecutiveReportCvesBySeverity
     */
    _0to3_9: ExecutiveReportCvesBySeverity0to39;
    /**
     *
     * @type {ExecutiveReportCvesBySeverity4to79}
     * @memberof ExecutiveReportCvesBySeverity
     */
    _4to7_9: ExecutiveReportCvesBySeverity4to79;
    /**
     *
     * @type {ExecutiveReportCvesBySeverity8to10}
     * @memberof ExecutiveReportCvesBySeverity
     */
    _8to10: ExecutiveReportCvesBySeverity8to10;
    /**
     *
     * @type {ExecutiveReportCvesBySeverityNa}
     * @memberof ExecutiveReportCvesBySeverity
     */
    na: ExecutiveReportCvesBySeverityNa;
}
/**
 *
 * @export
 * @interface ExecutiveReportCvesBySeverity0to39
 */
export interface ExecutiveReportCvesBySeverity0to39 {
    /**
     * Number of CVEs with CVSS score lower than 4.
     * @type {number}
     * @memberof ExecutiveReportCvesBySeverity0to39
     */
    count: number;
    /**
     * Percentage of CVEs with CVSS score lower than 4.
     * @type {number}
     * @memberof ExecutiveReportCvesBySeverity0to39
     */
    percentage: number;
}
/**
 *
 * @export
 * @interface ExecutiveReportCvesBySeverity4to79
 */
export interface ExecutiveReportCvesBySeverity4to79 {
    /**
     * Number of CVEs with CVSS score higher or equal to 4 and lower then 8.
     * @type {number}
     * @memberof ExecutiveReportCvesBySeverity4to79
     */
    count: number;
    /**
     * Percentage of CVEs with CVSS score higher or equal to 4 and lower then 8.
     * @type {number}
     * @memberof ExecutiveReportCvesBySeverity4to79
     */
    percentage: number;
}
/**
 *
 * @export
 * @interface ExecutiveReportCvesBySeverity8to10
 */
export interface ExecutiveReportCvesBySeverity8to10 {
    /**
     * Number of CVEs with CVSS score higher or equal to 8.
     * @type {number}
     * @memberof ExecutiveReportCvesBySeverity8to10
     */
    count: number;
    /**
     * Percentage of CVEs with CVSS score higher or equal to 8.
     * @type {number}
     * @memberof ExecutiveReportCvesBySeverity8to10
     */
    percentage: number;
}
/**
 *
 * @export
 * @interface ExecutiveReportCvesBySeverityNa
 */
export interface ExecutiveReportCvesBySeverityNa {
    /**
     * Number of CVEs with N/A CVSS score.
     * @type {number}
     * @memberof ExecutiveReportCvesBySeverityNa
     */
    count: number;
    /**
     * Percentage of CVEs with N/A CVSS score.
     * @type {number}
     * @memberof ExecutiveReportCvesBySeverityNa
     */
    percentage: number;
}
/**
 * Number of recently published CVEs identified on managed systems
 * @export
 * @interface ExecutiveReportRecentCves
 */
export interface ExecutiveReportRecentCves {
    /**
     * Number of CVEs identified on managed systems published in last 7 days.
     * @type {number}
     * @memberof ExecutiveReportRecentCves
     */
    last7days: number;
    /**
     * Number of CVEs identified on managed systems published in last 30 days.
     * @type {number}
     * @memberof ExecutiveReportRecentCves
     */
    last30days: number;
    /**
     * Number of CVEs identified on managed systems published in last 90 days.
     * @type {number}
     * @memberof ExecutiveReportRecentCves
     */
    last90days: number;
}
/**
 *
 * @export
 * @interface ExecutiveReportTopCves
 */
export interface ExecutiveReportTopCves {
    /**
     * CVE synopsis
     * @type {string}
     * @memberof ExecutiveReportTopCves
     */
    synopsis: string;
    /**
     * String representation of cvss2 score of the CVE.
     * @type {string}
     * @memberof ExecutiveReportTopCves
     */
    cvss2_score: string | null;
    /**
     * String representation of cvss3 score of the CVE.
     * @type {string}
     * @memberof ExecutiveReportTopCves
     */
    cvss3_score: string | null;
    /**
     * Description of the CVE.
     * @type {string}
     * @memberof ExecutiveReportTopCves
     */
    description: string;
    /**
     * Systems affected by the CVE.
     * @type {number}
     * @memberof ExecutiveReportTopCves
     */
    systems_affected: number;
}
/**
 *
 * @export
 * @interface InsightsRule
 */
export interface InsightsRule {
    /**
     * ID(s) of associated security rule(s).
     * @type {string}
     * @memberof InsightsRule
     */
    rule_id: string;
    /**
     * Description of the rule.
     * @type {string}
     * @memberof InsightsRule
     */
    description: string | null;
    /**
     * Summary of the rule.
     * @type {string}
     * @memberof InsightsRule
     */
    summary: string | null;
    /**
     * Generic information about the rule.
     * @type {string}
     * @memberof InsightsRule
     */
    generic: string | null;
    /**
     * Indicator whter reboot is required to mitigate vulnerability.
     * @type {boolean}
     * @memberof InsightsRule
     */
    reboot_required: boolean | null;
    /**
     * Number of available Ansible playbooks for remediation/mitigation.
     * @type {number}
     * @memberof InsightsRule
     */
    playbook_count: number | null;
    /**
     * Indicates how likely remediation can change environment on the remediatied system.
     * @type {number}
     * @memberof InsightsRule
     */
    change_risk: number | null;
    /**
     * ID of associated Red Hat knowledgebase article.
     * @type {number}
     * @memberof InsightsRule
     */
    kbase_node_id: number | null;
    /**
     * List of CVEs associated with the rule.
     * @type {Array<string>}
     * @memberof InsightsRule
     */
    associated_cves: Array<string>;
    /**
     * Shows rules impact number from 1 to 4
     * @type {number}
     * @memberof InsightsRule
     */
    rule_impact: number | null;
}
/**
 * @type InventoryIdOrList
 * @export
 */
export type InventoryIdOrList = Array<string> | string;

/**
 *
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * Link to first page.
     * @type {string}
     * @memberof Links
     */
    first: string;
    /**
     * Link to last page.
     * @type {string}
     * @memberof Links
     */
    last: string;
    /**
     * Link to next page.
     * @type {string}
     * @memberof Links
     */
    next: string | null;
    /**
     * Link to next page.
     * @type {string}
     * @memberof Links
     */
    previous: string | null;
}
/**
 *
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * Full text filter
     * @type {string}
     * @memberof Meta
     */
    filter: string | null;
    /**
     * Maximum number of paginated results.
     * @type {number}
     * @memberof Meta
     */
    limit: number;
    /**
     * First record of paginated response.
     * @type {number}
     * @memberof Meta
     */
    offset: number;
    /**
     * Page number of paginated response.
     * @type {number}
     * @memberof Meta
     */
    page: number;
    /**
     * Number of records per page of paginated response.
     * @type {number}
     * @memberof Meta
     */
    page_size: number;
    /**
     * Total number of pages of paginated response.
     * @type {number}
     * @memberof Meta
     */
    pages: number;
    /**
     * Sorting filter.
     * @type {string}
     * @memberof Meta
     */
    sort: string | null;
    /**
     * Total number of records.
     * @type {number}
     * @memberof Meta
     */
    total_items: number;
    /**
     * Format of the output data, either JSON (default) or CSV.
     * @type {string}
     * @memberof Meta
     */
    data_format: string;
}
/**
 *
 * @export
 * @interface MetaAffectedSystems
 */
export interface MetaAffectedSystems {
    /**
     * Full text filter
     * @type {string}
     * @memberof MetaAffectedSystems
     */
    filter: string | null;
    /**
     * Maximum number of paginated results.
     * @type {number}
     * @memberof MetaAffectedSystems
     */
    limit: number;
    /**
     * First record of paginated response.
     * @type {number}
     * @memberof MetaAffectedSystems
     */
    offset: number;
    /**
     * Page number of paginated response.
     * @type {number}
     * @memberof MetaAffectedSystems
     */
    page: number;
    /**
     * Number of records per page of paginated response.
     * @type {number}
     * @memberof MetaAffectedSystems
     */
    page_size: number;
    /**
     * Total number of pages of paginated response.
     * @type {number}
     * @memberof MetaAffectedSystems
     */
    pages: number;
    /**
     * Sorting filter.
     * @type {string}
     * @memberof MetaAffectedSystems
     */
    sort: string | null;
    /**
     * Total number of records.
     * @type {number}
     * @memberof MetaAffectedSystems
     */
    total_items: number;
    /**
     * Format of the output data, either JSON (default) or CSV.
     * @type {string}
     * @memberof MetaAffectedSystems
     */
    data_format: string;
    /**
     * Filer based on CVE status ID.
     * @type {string}
     * @memberof MetaAffectedSystems
     */
    status_id: string | null;
    /**
     * Filters security rules by its error key.
     * @type {string}
     * @memberof MetaAffectedSystems
     */
    rule_key: string | null;
    /**
     * Filter based on presence of security rule
     * @type {string}
     * @memberof MetaAffectedSystems
     */
    rule_presence: string | null;
    /**
     * If show_advisories=true shows access to patch service else null
     * @type {boolean}
     * @memberof MetaAffectedSystems
     */
    patch_access: boolean | null;
}
/**
 *
 * @export
 * @interface MetaAffectedSystemsAllOf
 */
export interface MetaAffectedSystemsAllOf {
    /**
     * Filer based on CVE status ID.
     * @type {string}
     * @memberof MetaAffectedSystemsAllOf
     */
    status_id: string | null;
    /**
     * Filters security rules by its error key.
     * @type {string}
     * @memberof MetaAffectedSystemsAllOf
     */
    rule_key: string | null;
    /**
     * Filter based on presence of security rule
     * @type {string}
     * @memberof MetaAffectedSystemsAllOf
     */
    rule_presence: string | null;
    /**
     * If show_advisories=true shows access to patch service else null
     * @type {boolean}
     * @memberof MetaAffectedSystemsAllOf
     */
    patch_access: boolean | null;
}
/**
 *
 * @export
 * @interface MetaCves
 */
export interface MetaCves {
    /**
     * Full text filter
     * @type {string}
     * @memberof MetaCves
     */
    filter: string | null;
    /**
     * Maximum number of paginated results.
     * @type {number}
     * @memberof MetaCves
     */
    limit: number;
    /**
     * First record of paginated response.
     * @type {number}
     * @memberof MetaCves
     */
    offset: number;
    /**
     * Page number of paginated response.
     * @type {number}
     * @memberof MetaCves
     */
    page: number;
    /**
     * Number of records per page of paginated response.
     * @type {number}
     * @memberof MetaCves
     */
    page_size: number;
    /**
     * Total number of pages of paginated response.
     * @type {number}
     * @memberof MetaCves
     */
    pages: number;
    /**
     * Sorting filter.
     * @type {string}
     * @memberof MetaCves
     */
    sort: string | null;
    /**
     * Total number of records.
     * @type {number}
     * @memberof MetaCves
     */
    total_items: number;
    /**
     * Format of the output data, either JSON (default) or CSV.
     * @type {string}
     * @memberof MetaCves
     */
    data_format: string;
    /**
     * Filter based on business risk IDs.
     * @type {string}
     * @memberof MetaCves
     */
    business_risk_id: string | null;
    /**
     * Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @type {number}
     * @memberof MetaCves
     */
    cvss_from: number | null;
    /**
     * Filter based on cvss score, up to the value.
     * @type {number}
     * @memberof MetaCves
     */
    cvss_to: number | null;
    /**
     * Filter CVEs based on their published date, starting from the date.
     * @type {string}
     * @memberof MetaCves
     */
    public_from: string | null;
    /**
     * Filter CVEs based on their published date, up to the date.
     * @type {string}
     * @memberof MetaCves
     */
    public_to: string | null;
    /**
     * Filter based on impact IDs.
     * @type {string}
     * @memberof MetaCves
     */
    impact: string | null;
    /**
     * Filer based on CVE status ID.
     * @type {string}
     * @memberof MetaCves
     */
    status_id: string | null;
    /**
     * Filter based on presence of security rule
     * @type {string}
     * @memberof MetaCves
     */
    rule_presence: string | null;
    /**
     * Filter based on presence of security_rule - deprecated
     * @type {boolean}
     * @memberof MetaCves
     */
    security_rule: boolean | null;
    /**
     * If show_advisories=true shows access to patch service else null
     * @type {boolean}
     * @memberof MetaCves
     */
    patch_access: boolean | null;
}
/**
 *
 * @export
 * @interface MetaCvesAllOf
 */
export interface MetaCvesAllOf {
    /**
     * Filter based on business risk IDs.
     * @type {string}
     * @memberof MetaCvesAllOf
     */
    business_risk_id: string | null;
    /**
     * Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @type {number}
     * @memberof MetaCvesAllOf
     */
    cvss_from: number | null;
    /**
     * Filter based on cvss score, up to the value.
     * @type {number}
     * @memberof MetaCvesAllOf
     */
    cvss_to: number | null;
    /**
     * Filter CVEs based on their published date, starting from the date.
     * @type {string}
     * @memberof MetaCvesAllOf
     */
    public_from: string | null;
    /**
     * Filter CVEs based on their published date, up to the date.
     * @type {string}
     * @memberof MetaCvesAllOf
     */
    public_to: string | null;
    /**
     * Filter based on impact IDs.
     * @type {string}
     * @memberof MetaCvesAllOf
     */
    impact: string | null;
    /**
     * Filer based on CVE status ID.
     * @type {string}
     * @memberof MetaCvesAllOf
     */
    status_id: string | null;
    /**
     * Filter based on presence of security rule
     * @type {string}
     * @memberof MetaCvesAllOf
     */
    rule_presence: string | null;
    /**
     * Filter based on presence of security_rule - deprecated
     * @type {boolean}
     * @memberof MetaCvesAllOf
     */
    security_rule: boolean | null;
    /**
     * If show_advisories=true shows access to patch service else null
     * @type {boolean}
     * @memberof MetaCvesAllOf
     */
    patch_access: boolean | null;
}
/**
 *
 * @export
 * @interface MetaCvesSystems
 */
export interface MetaCvesSystems {
    /**
     * Full text filter
     * @type {string}
     * @memberof MetaCvesSystems
     */
    filter: string | null;
    /**
     * Maximum number of paginated results.
     * @type {number}
     * @memberof MetaCvesSystems
     */
    limit: number;
    /**
     * First record of paginated response.
     * @type {number}
     * @memberof MetaCvesSystems
     */
    offset: number;
    /**
     * Page number of paginated response.
     * @type {number}
     * @memberof MetaCvesSystems
     */
    page: number;
    /**
     * Number of records per page of paginated response.
     * @type {number}
     * @memberof MetaCvesSystems
     */
    page_size: number;
    /**
     * Total number of pages of paginated response.
     * @type {number}
     * @memberof MetaCvesSystems
     */
    pages: number;
    /**
     * Sorting filter.
     * @type {string}
     * @memberof MetaCvesSystems
     */
    sort: string | null;
    /**
     * Total number of records.
     * @type {number}
     * @memberof MetaCvesSystems
     */
    total_items: number;
    /**
     * Format of the output data, either JSON (default) or CSV.
     * @type {string}
     * @memberof MetaCvesSystems
     */
    data_format: string;
    /**
     * Filter based on business risk IDs.
     * @type {string}
     * @memberof MetaCvesSystems
     */
    business_risk_id: string | null;
    /**
     * Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @type {number}
     * @memberof MetaCvesSystems
     */
    cvss_from: number | null;
    /**
     * Filter based on cvss score, up to the value.
     * @type {number}
     * @memberof MetaCvesSystems
     */
    cvss_to: number | null;
    /**
     * Filter CVEs based on their published date, starting from the date.
     * @type {string}
     * @memberof MetaCvesSystems
     */
    public_from: string | null;
    /**
     * Filter CVEs based on their published date, up to the date.
     * @type {string}
     * @memberof MetaCvesSystems
     */
    public_to: string | null;
    /**
     * Filter based on impact IDs.
     * @type {string}
     * @memberof MetaCvesSystems
     */
    impact: string | null;
    /**
     * Filer based on CVE status ID.
     * @type {string}
     * @memberof MetaCvesSystems
     */
    status_id: string | null;
    /**
     * Filter based on presence of security rule
     * @type {string}
     * @memberof MetaCvesSystems
     */
    rule_presence: string | null;
    /**
     * Filter based on presence of security_rule - deprecated
     * @type {boolean}
     * @memberof MetaCvesSystems
     */
    security_rule: boolean | null;
    /**
     * If show_advisories=true shows access to patch service else null
     * @type {boolean}
     * @memberof MetaCvesSystems
     */
    patch_access: boolean | null;
    /**
     * If given system was opted out.
     * @type {boolean}
     * @memberof MetaCvesSystems
     */
    opt_out: boolean;
}
/**
 *
 * @export
 * @interface MetaCvesSystemsAllOf
 */
export interface MetaCvesSystemsAllOf {
    /**
     * If given system was opted out.
     * @type {boolean}
     * @memberof MetaCvesSystemsAllOf
     */
    opt_out: boolean;
}
/**
 *
 * @export
 * @interface MetaSystems
 */
export interface MetaSystems {
    /**
     * Full text filter
     * @type {string}
     * @memberof MetaSystems
     */
    filter: string | null;
    /**
     * Maximum number of paginated results.
     * @type {number}
     * @memberof MetaSystems
     */
    limit: number;
    /**
     * First record of paginated response.
     * @type {number}
     * @memberof MetaSystems
     */
    offset: number;
    /**
     * Page number of paginated response.
     * @type {number}
     * @memberof MetaSystems
     */
    page: number;
    /**
     * Number of records per page of paginated response.
     * @type {number}
     * @memberof MetaSystems
     */
    page_size: number;
    /**
     * Total number of pages of paginated response.
     * @type {number}
     * @memberof MetaSystems
     */
    pages: number;
    /**
     * Sorting filter.
     * @type {string}
     * @memberof MetaSystems
     */
    sort: string | null;
    /**
     * Total number of records.
     * @type {number}
     * @memberof MetaSystems
     */
    total_items: number;
    /**
     * Format of the output data, either JSON (default) or CSV.
     * @type {string}
     * @memberof MetaSystems
     */
    data_format: string;
    /**
     * Whether the filter to show opted out systems is active or not. If not set, defaults to hiding opted out systems.
     * @type {boolean}
     * @memberof MetaSystems
     */
    opt_out: boolean | null;
    /**
     * Display setting of opted out systems.
     * @type {string}
     * @memberof MetaSystems
     */
    excluded: string | null;
}
/**
 *
 * @export
 * @interface MetaSystemsAllOf
 */
export interface MetaSystemsAllOf {
    /**
     * Whether the filter to show opted out systems is active or not. If not set, defaults to hiding opted out systems.
     * @type {boolean}
     * @memberof MetaSystemsAllOf
     */
    opt_out: boolean | null;
    /**
     * Display setting of opted out systems.
     * @type {string}
     * @memberof MetaSystemsAllOf
     */
    excluded: string | null;
}
/**
 *
 * @export
 * @interface MetaVulnerabilitiesOut
 */
export interface MetaVulnerabilitiesOut {
    /**
     * Full text filter
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    filter: string | null;
    /**
     * Maximum number of paginated results.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    limit: number;
    /**
     * First record of paginated response.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    offset: number;
    /**
     * Page number of paginated response.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    page: number;
    /**
     * Number of records per page of paginated response.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    page_size: number;
    /**
     * Total number of pages of paginated response.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    pages: number;
    /**
     * Sorting filter.
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    sort: string | null;
    /**
     * Total number of records.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    total_items: number;
    /**
     * Format of the output data, either JSON (default) or CSV.
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    data_format: string;
    /**
     * Description of CVE showing preferences
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    affecting: string | null;
    /**
     * Filter based on business risk IDs.
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    business_risk_id: string | null;
    /**
     * Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    cvss_from: number | null;
    /**
     * Filter based on cvss score, up to the value.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    cvss_to: number | null;
    /**
     * Show all known vulnerabilities, regardless of number of affected systems.
     * @type {boolean}
     * @memberof MetaVulnerabilitiesOut
     */
    show_all: boolean | null;
    /**
     * Filter CVEs based on their published date, starting from the date.
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    public_from: string | null;
    /**
     * Filter CVEs based on their published date, up to the date.
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    public_to: string | null;
    /**
     * Filter based on impact IDs.
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    impact: string | null;
    /**
     * Total number of systems managed by vulnerability application.
     * @type {number}
     * @memberof MetaVulnerabilitiesOut
     */
    system_count?: number;
    /**
     * Filter based on presence of security rule
     * @type {string}
     * @memberof MetaVulnerabilitiesOut
     */
    rule_presence: string | null;
    /**
     * Filter based on presence of security rule - deprecated
     * @type {boolean}
     * @memberof MetaVulnerabilitiesOut
     */
    security_rule: boolean | null;
}
/**
 *
 * @export
 * @interface MetaVulnerabilitiesOutAllOf
 */
export interface MetaVulnerabilitiesOutAllOf {
    /**
     * Description of CVE showing preferences
     * @type {string}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    affecting: string | null;
    /**
     * Filter based on business risk IDs.
     * @type {string}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    business_risk_id: string | null;
    /**
     * Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @type {number}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    cvss_from: number | null;
    /**
     * Filter based on cvss score, up to the value.
     * @type {number}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    cvss_to: number | null;
    /**
     * Show all known vulnerabilities, regardless of number of affected systems.
     * @type {boolean}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    show_all: boolean | null;
    /**
     * Filter CVEs based on their published date, starting from the date.
     * @type {string}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    public_from: string | null;
    /**
     * Filter CVEs based on their published date, up to the date.
     * @type {string}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    public_to: string | null;
    /**
     * Filter based on impact IDs.
     * @type {string}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    impact: string | null;
    /**
     * Total number of systems managed by vulnerability application.
     * @type {number}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    system_count?: number;
    /**
     * Filter based on presence of security rule
     * @type {string}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    rule_presence: string | null;
    /**
     * Filter based on presence of security rule - deprecated
     * @type {boolean}
     * @memberof MetaVulnerabilitiesOutAllOf
     */
    security_rule: boolean | null;
}
/**
 *
 * @export
 * @interface OptOutIn
 */
export interface OptOutIn {
    /**
     *
     * @type {InventoryIdOrList}
     * @memberof OptOutIn
     */
    inventory_id: InventoryIdOrList;
    /**
     * Opt out setting to be set.
     * @type {boolean}
     * @memberof OptOutIn
     */
    opt_out: boolean;
}
/**
 *
 * @export
 * @interface PlaybookTemplate
 */
export interface PlaybookTemplate {
    /**
     *
     * @type {Array<PlaybookTemplateData>}
     * @memberof PlaybookTemplate
     */
    data?: Array<PlaybookTemplateData>;
}
/**
 *
 * @export
 * @interface PlaybookTemplateData
 */
export interface PlaybookTemplateData {
    /**
     * Playbook template description.
     * @type {string}
     * @memberof PlaybookTemplateData
     */
    description: string;
    /**
     * Actual playbook template.
     * @type {string}
     * @memberof PlaybookTemplateData
     */
    play: string;
    /**
     * Revision of the playbook template.
     * @type {string}
     * @memberof PlaybookTemplateData
     */
    version: string;
}
/**
 *
 * @export
 * @interface StatusIn
 */
export interface StatusIn {
    /**
     *
     * @type {InventoryIdOrList}
     * @memberof StatusIn
     */
    inventory_id?: InventoryIdOrList;
    /**
     *
     * @type {CveOrList}
     * @memberof StatusIn
     */
    cve: CveOrList;
    /**
     * Status ID to be set, obtained by GET method. If not specified, global CVE status is set.
     * @type {number}
     * @memberof StatusIn
     */
    status_id?: number;
    /**
     * Complementary text to the status.
     * @type {string}
     * @memberof StatusIn
     */
    status_text?: string | null;
}
/**
 *
 * @export
 * @interface StatusListOut
 */
export interface StatusListOut {
    /**
     * List of available status/status_id pairs.
     * @type {Array<StatusListOutData>}
     * @memberof StatusListOut
     */
    data: Array<StatusListOutData>;
    /**
     *
     * @type {StatusListOutMeta}
     * @memberof StatusListOut
     */
    meta: StatusListOutMeta;
}
/**
 *
 * @export
 * @interface StatusListOutData
 */
export interface StatusListOutData {
    /**
     * Internal status_id.
     * @type {number}
     * @memberof StatusListOutData
     */
    id: number;
    /**
     * Represenation of internal status_id.
     * @type {string}
     * @memberof StatusListOutData
     */
    name: string;
}
/**
 *
 * @export
 * @interface StatusListOutMeta
 */
export interface StatusListOutMeta {
    /**
     * Total number of available status/status_id pairs.
     * @type {number}
     * @memberof StatusListOutMeta
     */
    total_items: number;
}
/**
 *
 * @export
 * @interface StatusOut
 */
export interface StatusOut {
    /**
     * List of updated objects/updated object IDs.
     * @type {Array<StatusOutUpdated>}
     * @memberof StatusOut
     */
    updated: Array<StatusOutUpdated>;
}
/**
 *
 * @export
 * @interface StatusOutUpdated
 */
export interface StatusOutUpdated {
    /**
     *
     * @type {string}
     * @memberof StatusOutUpdated
     */
    inventory_id: string;
    /**
     *
     * @type {string}
     * @memberof StatusOutUpdated
     */
    cve: string;
}
/**
 *
 * @export
 * @interface SystemCvesIdsOut
 */
export interface SystemCvesIdsOut {
    /**
     *
     * @type {string | Array<string>}
     * @memberof SystemCvesIdsOut
     */
    data: string | Array<string>;
    /**
     *
     * @type {Links}
     * @memberof SystemCvesIdsOut
     */
    links: Links;
    /**
     *
     * @type {MetaCves}
     * @memberof SystemCvesIdsOut
     */
    meta: MetaCves;
}
/**
 *
 * @export
 * @interface SystemCvesOut
 */
export interface SystemCvesOut {
    /**
     *
     * @type {string | Array<object>}
     * @memberof SystemCvesOut
     */
    data: string | Array<object>;
    /**
     *
     * @type {Links}
     * @memberof SystemCvesOut
     */
    links: Links;
    /**
     *
     * @type {MetaCves}
     * @memberof SystemCvesOut
     */
    meta: MetaCves;
}
/**
 *
 * @export
 * @interface SystemDetailsOut
 */
export interface SystemDetailsOut {
    /**
     *
     * @type {SystemDetailsOutData}
     * @memberof SystemDetailsOut
     */
    data: SystemDetailsOutData;
}
/**
 *
 * @export
 * @interface SystemDetailsOutData
 */
export interface SystemDetailsOutData {
    /**
     * Date of last evaluation.
     * @type {string}
     * @memberof SystemDetailsOutData
     */
    last_evaluation: string | null;
    /**
     * Date of last security rules evaluation.
     * @type {string}
     * @memberof SystemDetailsOutData
     */
    rules_evaluation: string | null;
    /**
     * System opt out status.
     * @type {boolean}
     * @memberof SystemDetailsOutData
     */
    opt_out: boolean;
    /**
     * Date of the latest upload of archive.
     * @type {string}
     * @memberof SystemDetailsOutData
     */
    last_upload: string | null;
    /**
     * System stale status.
     * @type {boolean}
     * @memberof SystemDetailsOutData
     */
    stale?: boolean;
    /**
     * Date of the lastest upload of archive taken from Inventory syndicated data.
     * @type {string}
     * @memberof SystemDetailsOutData
     */
    updated?: string | null;
    /**
     *
     * @type {Array<SystemDetailsOutDataTags>}
     * @memberof SystemDetailsOutData
     */
    tags: Array<SystemDetailsOutDataTags>;
}
/**
 *
 * @export
 * @interface SystemDetailsOutDataTags
 */
export interface SystemDetailsOutDataTags {
    /**
     * Namespace of single tag.
     * @type {string}
     * @memberof SystemDetailsOutDataTags
     */
    namespace: string | null;
    /**
     * Key of the single tag.
     * @type {string}
     * @memberof SystemDetailsOutDataTags
     */
    key: string;
    /**
     * Value of the single tag.
     * @type {string}
     * @memberof SystemDetailsOutDataTags
     */
    value: string | null;
}
/**
 *
 * @export
 * @interface SystemIdsOut
 */
export interface SystemIdsOut {
    /**
     *
     * @type {string | Array<object>}
     * @memberof SystemIdsOut
     */
    data: string | Array<object>;
    /**
     *
     * @type {Links}
     * @memberof SystemIdsOut
     */
    links: Links;
    /**
     *
     * @type {MetaSystems}
     * @memberof SystemIdsOut
     */
    meta: MetaSystems;
}
/**
 *
 * @export
 * @interface SystemListOut
 */
export interface SystemListOut {
    /**
     *
     * @type {string | Array<object>}
     * @memberof SystemListOut
     */
    data: string | Array<object>;
    /**
     *
     * @type {Links}
     * @memberof SystemListOut
     */
    links: Links;
    /**
     *
     * @type {MetaSystems}
     * @memberof SystemListOut
     */
    meta: MetaSystems;
}
/**
 *
 * @export
 * @interface VersionOut
 */
export interface VersionOut {
    /**
     * Version of application.
     * @type {string}
     * @memberof VersionOut
     */
    application_version: string;
    /**
     * Version of database schema.
     * @type {string | number}
     * @memberof VersionOut
     */
    database_version: string | number;
}
/**
 *
 * @export
 * @interface VulnerabilitiesIdsOut
 */
export interface VulnerabilitiesIdsOut {
    /**
     *
     * @type {string | Array<string>}
     * @memberof VulnerabilitiesIdsOut
     */
    data: string | Array<string>;
    /**
     *
     * @type {Links}
     * @memberof VulnerabilitiesIdsOut
     */
    links: Links;
    /**
     *
     * @type {MetaVulnerabilitiesOut}
     * @memberof VulnerabilitiesIdsOut
     */
    meta: MetaVulnerabilitiesOut;
}
/**
 *
 * @export
 * @interface VulnerabilitiesOut
 */
export interface VulnerabilitiesOut {
    /**
     *
     * @type {string | Array<object>}
     * @memberof VulnerabilitiesOut
     */
    data: string | Array<object>;
    /**
     *
     * @type {Links}
     * @memberof VulnerabilitiesOut
     */
    links: Links;
    /**
     *
     * @type {MetaVulnerabilitiesOut}
     * @memberof VulnerabilitiesOut
     */
    meta: MetaVulnerabilitiesOut;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes system from database.
         * @summary Delete system.
         * @param {string} inventoryId Inventory ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSystem: async (inventoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            if (inventoryId === null || inventoryId === undefined) {
                throw new RequiredError('inventoryId','Required parameter inventoryId was null or undefined when calling deleteSystem.');
            }
            const localVarPath = `/systems/{inventory_id}`
                .replace(`{${"inventory_id"}}`, encodeURIComponent(String(inventoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report of affected systems for a given CVE.
         * @summary Affected systems for a given CVE.
         * @param {string} cveId CVE id.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [ruleKey] Filters security rules by its error key.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {string} [securityRule] Filter by presence (boolean) or name (string) of security rule - Deprecated, will get obsolete, use rule_key and rule_presence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffectedSystemsByCve: async (cveId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, statusId?: string, dataFormat?: string, uuid?: string, ruleKey?: Array<string>, rulePresence?: Array<boolean>, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, showAdvisories?: boolean, advisory?: string, securityRule?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cveId' is not null or undefined
            if (cveId === null || cveId === undefined) {
                throw new RequiredError('cveId','Required parameter cveId was null or undefined when calling getAffectedSystemsByCve.');
            }
            const localVarPath = `/cves/{cve_id}/affected_systems`
                .replace(`{${"cve_id"}}`, encodeURIComponent(String(cveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (statusId !== undefined) {
                localVarQueryParameter['status_id'] = statusId;
            }

            if (dataFormat !== undefined) {
                localVarQueryParameter['data_format'] = dataFormat;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (ruleKey) {
                localVarQueryParameter['rule_key'] = ruleKey;
            }

            if (rulePresence) {
                localVarQueryParameter['rule_presence'] = rulePresence;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (sapSids) {
                localVarQueryParameter['sap_sids'] = sapSids;
            }

            if (sapSystem !== undefined) {
                localVarQueryParameter['sap_system'] = sapSystem;
            }

            if (showAdvisories !== undefined) {
                localVarQueryParameter['show_advisories'] = showAdvisories;
            }

            if (advisory !== undefined) {
                localVarQueryParameter['advisory'] = advisory;
            }

            if (securityRule !== undefined) {
                localVarQueryParameter['security_rule'] = securityRule;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Report of IDs of affected systems for a given CVE.
         * @summary IDs of affected systems for a given CVE.
         * @param {string} cveId CVE id.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [ruleKey] Filters security rules by its error key.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {string} [securityRule] Filter by presence (boolean) or name (string) of security rule - Deprecated, will get obsolete, use rule_key and rule_presence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffectedSystemsIdsByCve: async (cveId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, statusId?: string, dataFormat?: string, uuid?: string, ruleKey?: Array<string>, rulePresence?: Array<boolean>, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, showAdvisories?: boolean, advisory?: string, securityRule?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cveId' is not null or undefined
            if (cveId === null || cveId === undefined) {
                throw new RequiredError('cveId','Required parameter cveId was null or undefined when calling getAffectedSystemsIdsByCve.');
            }
            const localVarPath = `/cves/{cve_id}/affected_systems/ids`
                .replace(`{${"cve_id"}}`, encodeURIComponent(String(cveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (statusId !== undefined) {
                localVarQueryParameter['status_id'] = statusId;
            }

            if (dataFormat !== undefined) {
                localVarQueryParameter['data_format'] = dataFormat;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (ruleKey) {
                localVarQueryParameter['rule_key'] = ruleKey;
            }

            if (rulePresence) {
                localVarQueryParameter['rule_presence'] = rulePresence;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (sapSids) {
                localVarQueryParameter['sap_sids'] = sapSids;
            }

            if (sapSystem !== undefined) {
                localVarQueryParameter['sap_system'] = sapSystem;
            }

            if (showAdvisories !== undefined) {
                localVarQueryParameter['show_advisories'] = showAdvisories;
            }

            if (advisory !== undefined) {
                localVarQueryParameter['advisory'] = advisory;
            }

            if (securityRule !== undefined) {
                localVarQueryParameter['security_rule'] = securityRule;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks database availability and API response threshold time.
         * @summary Health status of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/apistatus`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns available business risk and business_risk_id pairs where business_risk_id is internal ID of the business risk.
         * @summary Available business risk/business_risk_id pairs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessRiskList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/business_risk`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all information about given CVE.
         * @summary Details of a CVE.
         * @param {string} cveId CVE id.
         * @param {boolean} [showAdvisoriesDetails] If true shows detailed advisory information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveDetails: async (cveId: string, showAdvisoriesDetails?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cveId' is not null or undefined
            if (cveId === null || cveId === undefined) {
                throw new RequiredError('cveId','Required parameter cveId was null or undefined when calling getCveDetails.');
            }
            const localVarPath = `/cves/{cve_id}`
                .replace(`{${"cve_id"}}`, encodeURIComponent(String(cveId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (showAdvisoriesDetails !== undefined) {
                localVarQueryParameter['show_advisories_details'] = showAdvisoriesDetails;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows IDs of all CVEs the system is exposed to.
         * @summary CVE IDs report for a system.
         * @param {string} inventoryId Inventory ID.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveIdsBySystem: async (inventoryId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, statusId?: string, dataFormat?: string, businessRiskId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            if (inventoryId === null || inventoryId === undefined) {
                throw new RequiredError('inventoryId','Required parameter inventoryId was null or undefined when calling getCveIdsBySystem.');
            }
            const localVarPath = `/systems/{inventory_id}/cves/ids`
                .replace(`{${"inventory_id"}}`, encodeURIComponent(String(inventoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (cvssFrom !== undefined) {
                localVarQueryParameter['cvss_from'] = cvssFrom;
            }

            if (cvssTo !== undefined) {
                localVarQueryParameter['cvss_to'] = cvssTo;
            }

            if (publicFrom !== undefined) {
                localVarQueryParameter['public_from'] = publicFrom;
            }

            if (publicTo !== undefined) {
                localVarQueryParameter['public_to'] = publicTo;
            }

            if (impact !== undefined) {
                localVarQueryParameter['impact'] = impact;
            }

            if (statusId !== undefined) {
                localVarQueryParameter['status_id'] = statusId;
            }

            if (dataFormat !== undefined) {
                localVarQueryParameter['data_format'] = dataFormat;
            }

            if (businessRiskId !== undefined) {
                localVarQueryParameter['business_risk_id'] = businessRiskId;
            }

            if (securityRule !== undefined) {
                localVarQueryParameter['security_rule'] = securityRule;
            }

            if (rulePresence) {
                localVarQueryParameter['rule_presence'] = rulePresence;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Overview of vulnerabilities IDs across whole host inventory.
         * @summary Vulnerabilities IDs overview.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAll] Show all known vulnerabilities IDs, regardless of number of affected systems. If combined with new affecting option, resets to default behavior.
         * @param {Array<boolean>} [affecting] Comma seprated string with bools. First boolean controls displaying CVEs with at least one system affected. Second one toggles CVEs with no systems affected. Defaults to showing only CVEs with at least one system affected. If combined with (deprecated) show_all option, resets to default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveIdsList: async (filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, dataFormat?: string, businessRiskId?: string, statusId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAll?: boolean, affecting?: Array<boolean>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/vulnerabilities/cves/ids`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (cvssFrom !== undefined) {
                localVarQueryParameter['cvss_from'] = cvssFrom;
            }

            if (cvssTo !== undefined) {
                localVarQueryParameter['cvss_to'] = cvssTo;
            }

            if (publicFrom !== undefined) {
                localVarQueryParameter['public_from'] = publicFrom;
            }

            if (publicTo !== undefined) {
                localVarQueryParameter['public_to'] = publicTo;
            }

            if (impact !== undefined) {
                localVarQueryParameter['impact'] = impact;
            }

            if (dataFormat !== undefined) {
                localVarQueryParameter['data_format'] = dataFormat;
            }

            if (businessRiskId !== undefined) {
                localVarQueryParameter['business_risk_id'] = businessRiskId;
            }

            if (statusId !== undefined) {
                localVarQueryParameter['status_id'] = statusId;
            }

            if (securityRule !== undefined) {
                localVarQueryParameter['security_rule'] = securityRule;
            }

            if (rulePresence) {
                localVarQueryParameter['rule_presence'] = rulePresence;
            }

            if (showAll !== undefined) {
                localVarQueryParameter['show_all'] = showAll;
            }

            if (affecting) {
                localVarQueryParameter['affecting'] = affecting;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Overview of vulnerabilities across whole host inventory.
         * @summary Vulnerabilities overview.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAll] Show all known vulnerabilities, regardless of number of affected systems. If combined with new affecting option, resets to default behavior.
         * @param {Array<boolean>} [affecting] Comma seprated string with bools. First boolean controls displaying CVEs with at least one system affected. Second one toggles CVEs with no systems affected. Defaults to showing only CVEs with at least one system affected. If combined with (deprecated) show_all option, resets to default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveList: async (filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, dataFormat?: string, businessRiskId?: string, statusId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAll?: boolean, affecting?: Array<boolean>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/vulnerabilities/cves`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (cvssFrom !== undefined) {
                localVarQueryParameter['cvss_from'] = cvssFrom;
            }

            if (cvssTo !== undefined) {
                localVarQueryParameter['cvss_to'] = cvssTo;
            }

            if (publicFrom !== undefined) {
                localVarQueryParameter['public_from'] = publicFrom;
            }

            if (publicTo !== undefined) {
                localVarQueryParameter['public_to'] = publicTo;
            }

            if (impact !== undefined) {
                localVarQueryParameter['impact'] = impact;
            }

            if (dataFormat !== undefined) {
                localVarQueryParameter['data_format'] = dataFormat;
            }

            if (businessRiskId !== undefined) {
                localVarQueryParameter['business_risk_id'] = businessRiskId;
            }

            if (statusId !== undefined) {
                localVarQueryParameter['status_id'] = statusId;
            }

            if (securityRule !== undefined) {
                localVarQueryParameter['security_rule'] = securityRule;
            }

            if (rulePresence) {
                localVarQueryParameter['rule_presence'] = rulePresence;
            }

            if (showAll !== undefined) {
                localVarQueryParameter['show_all'] = showAll;
            }

            if (affecting) {
                localVarQueryParameter['affecting'] = affecting;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows detailed information about all CVEs the system is exposed to.
         * @summary CVE report for a system.
         * @param {string} inventoryId Inventory ID.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveListBySystem: async (inventoryId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, statusId?: string, dataFormat?: string, businessRiskId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAdvisories?: boolean, advisory?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            if (inventoryId === null || inventoryId === undefined) {
                throw new RequiredError('inventoryId','Required parameter inventoryId was null or undefined when calling getCveListBySystem.');
            }
            const localVarPath = `/systems/{inventory_id}/cves`
                .replace(`{${"inventory_id"}}`, encodeURIComponent(String(inventoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (cvssFrom !== undefined) {
                localVarQueryParameter['cvss_from'] = cvssFrom;
            }

            if (cvssTo !== undefined) {
                localVarQueryParameter['cvss_to'] = cvssTo;
            }

            if (publicFrom !== undefined) {
                localVarQueryParameter['public_from'] = publicFrom;
            }

            if (publicTo !== undefined) {
                localVarQueryParameter['public_to'] = publicTo;
            }

            if (impact !== undefined) {
                localVarQueryParameter['impact'] = impact;
            }

            if (statusId !== undefined) {
                localVarQueryParameter['status_id'] = statusId;
            }

            if (dataFormat !== undefined) {
                localVarQueryParameter['data_format'] = dataFormat;
            }

            if (businessRiskId !== undefined) {
                localVarQueryParameter['business_risk_id'] = businessRiskId;
            }

            if (securityRule !== undefined) {
                localVarQueryParameter['security_rule'] = securityRule;
            }

            if (rulePresence) {
                localVarQueryParameter['rule_presence'] = rulePresence;
            }

            if (showAdvisories !== undefined) {
                localVarQueryParameter['show_advisories'] = showAdvisories;
            }

            if (advisory !== undefined) {
                localVarQueryParameter['advisory'] = advisory;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns top level overview of vulnerabilities affecting given account.
         * @summary Top level overview of vulnerabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutiveReport: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/report/executive`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return Ansible playbook template for given rule id.
         * @summary Playbook template for CVEs with security rules.
         * @param {string} ruleId Insights security rule ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybookTemplate: async (ruleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling getPlaybookTemplate.');
            }
            const localVarPath = `/playbooks/templates/{rule_id}`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns available status and status_id pairs where status_id is internal ID of the status.
         * @summary Available status/status_id pairs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides details of a system, e.g. it\'s opt out status.
         * @summary System details.
         * @param {string} inventoryId Inventory ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemDetails: async (inventoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            if (inventoryId === null || inventoryId === undefined) {
                throw new RequiredError('inventoryId','Required parameter inventoryId was null or undefined when calling getSystemDetails.');
            }
            const localVarPath = `/systems/{inventory_id}`
                .replace(`{${"inventory_id"}}`, encodeURIComponent(String(inventoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List systems IDs visible to logged in account.
         * @summary List systems IDs along with additional info about opt out state of the system.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {boolean} [stale] If set to true, shows stale systems. If not set defaults to false.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [optOut] If set to true, shows systems which have been opted out from vulnerability application. If not set defaults to false. If combined with new excluded option produces undefined default behavior.
         * @param {Array<boolean>} [excluded] Comma seprated string with bools. First boolean controls displaying systems which are not excluded. Second one toggles displaying of systems excluded from vulnerability analysis. Defaults to showing only those systems which are not excluded. If combined with (deprecated) opt_out option produces undefined behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemsIds: async (filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, dataFormat?: string, stale?: boolean, uuid?: string, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, optOut?: boolean, excluded?: Array<boolean>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/systems/ids`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dataFormat !== undefined) {
                localVarQueryParameter['data_format'] = dataFormat;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (sapSids) {
                localVarQueryParameter['sap_sids'] = sapSids;
            }

            if (sapSystem !== undefined) {
                localVarQueryParameter['sap_system'] = sapSystem;
            }

            if (optOut !== undefined) {
                localVarQueryParameter['opt_out'] = optOut;
            }

            if (excluded) {
                localVarQueryParameter['excluded'] = excluded;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List systems visible to logged in account with basic information related to vulnerabilities.
         * @summary List systems.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {boolean} [stale] If set to true, shows stale systems. If not set defaults to false.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [optOut] If set to true, shows systems which have been opted out from vulnerability application. If not set defaults to false. If combined with new excluded option produces undefined behavior.
         * @param {Array<boolean>} [excluded] Comma seprated string with bools. First boolean controls displaying systems which are not excluded. Second one toggles displaying of systems excluded from vulnerability analysis. Defaults to showing only those systems which are not excluded. If combined with (deprecated) opt_out option produces undefined behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemsList: async (filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, dataFormat?: string, stale?: boolean, uuid?: string, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, optOut?: boolean, excluded?: Array<boolean>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/systems`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dataFormat !== undefined) {
                localVarQueryParameter['data_format'] = dataFormat;
            }

            if (stale !== undefined) {
                localVarQueryParameter['stale'] = stale;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (sapSids) {
                localVarQueryParameter['sap_sids'] = sapSids;
            }

            if (sapSystem !== undefined) {
                localVarQueryParameter['sap_system'] = sapSystem;
            }

            if (optOut !== undefined) {
                localVarQueryParameter['opt_out'] = optOut;
            }

            if (excluded) {
                localVarQueryParameter['excluded'] = excluded;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application version.
         * @summary Application version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets business risk for a CVE.
         * @summary Set business risk for a CVE.
         * @param {CveRiskIn} cveRiskIn Values to be set. At least one of the \&quot;business_risk_id\&quot; or \&quot;business_risk_text\&quot; parameters is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCveBusinessRisk: async (cveRiskIn: CveRiskIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cveRiskIn' is not null or undefined
            if (cveRiskIn === null || cveRiskIn === undefined) {
                throw new RequiredError('cveRiskIn','Required parameter cveRiskIn was null or undefined when calling setCveBusinessRisk.');
            }
            const localVarPath = `/cves/business_risk`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof cveRiskIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cveRiskIn !== undefined ? cveRiskIn : {}) : (cveRiskIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets status for a CVE.
         * @summary Set status for a CVE.
         * @param {CveStatusIn} cveStatusIn Values to be set. At least one of the \&quot;status_id\&quot; or \&quot;status_text\&quot; parameters is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCveStatus: async (cveStatusIn: CveStatusIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cveStatusIn' is not null or undefined
            if (cveStatusIn === null || cveStatusIn === undefined) {
                throw new RequiredError('cveStatusIn','Required parameter cveStatusIn was null or undefined when calling setCveStatus.');
            }
            const localVarPath = `/cves/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof cveStatusIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cveStatusIn !== undefined ? cveStatusIn : {}) : (cveStatusIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets status for given hosts and CVEs.
         * @summary Set status for system vulnerabilities.
         * @param {StatusIn} statusIn Values to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStatus: async (statusIn: StatusIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'statusIn' is not null or undefined
            if (statusIn === null || statusIn === undefined) {
                throw new RequiredError('statusIn','Required parameter statusIn was null or undefined when calling setStatus.');
            }
            const localVarPath = `/status`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof statusIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(statusIn !== undefined ? statusIn : {}) : (statusIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Opts in/out a systems. Opted out system is not shown and manageable by the vulnerability application.
         * @summary Opt in/out a system to/from vulnerability application.
         * @param {string} inventoryId Inventory ID.
         * @param {boolean} value opt_out setting of the host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSystemOptOut: async (inventoryId: string, value: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            if (inventoryId === null || inventoryId === undefined) {
                throw new RequiredError('inventoryId','Required parameter inventoryId was null or undefined when calling setSystemOptOut.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling setSystemOptOut.');
            }
            const localVarPath = `/systems/{inventory_id}/opt_out`
                .replace(`{${"inventory_id"}}`, encodeURIComponent(String(inventoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Opts in/out a systems. Opted out system is not shown and manageable by the vulnerability application.
         * @summary Opt in/out a system to/from vulnerability application.
         * @param {OptOutIn} optOutIn Values to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSystemsOptOut: async (optOutIn: OptOutIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'optOutIn' is not null or undefined
            if (optOutIn === null || optOutIn === undefined) {
                throw new RequiredError('optOutIn','Required parameter optOutIn was null or undefined when calling setSystemsOptOut.');
            }
            const localVarPath = `/systems/opt_out`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof optOutIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(optOutIn !== undefined ? optOutIn : {}) : (optOutIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes system from database.
         * @summary Delete system.
         * @param {string} inventoryId Inventory ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSystem(inventoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteSystem(inventoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Report of affected systems for a given CVE.
         * @summary Affected systems for a given CVE.
         * @param {string} cveId CVE id.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [ruleKey] Filters security rules by its error key.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {string} [securityRule] Filter by presence (boolean) or name (string) of security rule - Deprecated, will get obsolete, use rule_key and rule_presence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffectedSystemsByCve(cveId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, statusId?: string, dataFormat?: string, uuid?: string, ruleKey?: Array<string>, rulePresence?: Array<boolean>, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, showAdvisories?: boolean, advisory?: string, securityRule?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffectedSystemsOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getAffectedSystemsByCve(cveId, filter, limit, offset, page, pageSize, sort, statusId, dataFormat, uuid, ruleKey, rulePresence, tags, sapSids, sapSystem, showAdvisories, advisory, securityRule, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Report of IDs of affected systems for a given CVE.
         * @summary IDs of affected systems for a given CVE.
         * @param {string} cveId CVE id.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [ruleKey] Filters security rules by its error key.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {string} [securityRule] Filter by presence (boolean) or name (string) of security rule - Deprecated, will get obsolete, use rule_key and rule_presence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffectedSystemsIdsByCve(cveId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, statusId?: string, dataFormat?: string, uuid?: string, ruleKey?: Array<string>, rulePresence?: Array<boolean>, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, showAdvisories?: boolean, advisory?: string, securityRule?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffectedSystemsIdsOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getAffectedSystemsIdsByCve(cveId, filter, limit, offset, page, pageSize, sort, statusId, dataFormat, uuid, ruleKey, rulePresence, tags, sapSids, sapSystem, showAdvisories, advisory, securityRule, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Checks database availability and API response threshold time.
         * @summary Health status of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getApiStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns available business risk and business_risk_id pairs where business_risk_id is internal ID of the business risk.
         * @summary Available business risk/business_risk_id pairs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessRiskList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessRiskListOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getBusinessRiskList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show all information about given CVE.
         * @summary Details of a CVE.
         * @param {string} cveId CVE id.
         * @param {boolean} [showAdvisoriesDetails] If true shows detailed advisory information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCveDetails(cveId: string, showAdvisoriesDetails?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CveDetailOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getCveDetails(cveId, showAdvisoriesDetails, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Shows IDs of all CVEs the system is exposed to.
         * @summary CVE IDs report for a system.
         * @param {string} inventoryId Inventory ID.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCveIdsBySystem(inventoryId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, statusId?: string, dataFormat?: string, businessRiskId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemCvesIdsOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getCveIdsBySystem(inventoryId, filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, statusId, dataFormat, businessRiskId, securityRule, rulePresence, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Overview of vulnerabilities IDs across whole host inventory.
         * @summary Vulnerabilities IDs overview.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAll] Show all known vulnerabilities IDs, regardless of number of affected systems. If combined with new affecting option, resets to default behavior.
         * @param {Array<boolean>} [affecting] Comma seprated string with bools. First boolean controls displaying CVEs with at least one system affected. Second one toggles CVEs with no systems affected. Defaults to showing only CVEs with at least one system affected. If combined with (deprecated) show_all option, resets to default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCveIdsList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, dataFormat?: string, businessRiskId?: string, statusId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAll?: boolean, affecting?: Array<boolean>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VulnerabilitiesIdsOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getCveIdsList(filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, dataFormat, businessRiskId, statusId, securityRule, rulePresence, showAll, affecting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Overview of vulnerabilities across whole host inventory.
         * @summary Vulnerabilities overview.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAll] Show all known vulnerabilities, regardless of number of affected systems. If combined with new affecting option, resets to default behavior.
         * @param {Array<boolean>} [affecting] Comma seprated string with bools. First boolean controls displaying CVEs with at least one system affected. Second one toggles CVEs with no systems affected. Defaults to showing only CVEs with at least one system affected. If combined with (deprecated) show_all option, resets to default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCveList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, dataFormat?: string, businessRiskId?: string, statusId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAll?: boolean, affecting?: Array<boolean>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VulnerabilitiesOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getCveList(filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, dataFormat, businessRiskId, statusId, securityRule, rulePresence, showAll, affecting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Shows detailed information about all CVEs the system is exposed to.
         * @summary CVE report for a system.
         * @param {string} inventoryId Inventory ID.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCveListBySystem(inventoryId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, statusId?: string, dataFormat?: string, businessRiskId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAdvisories?: boolean, advisory?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemCvesOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getCveListBySystem(inventoryId, filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, statusId, dataFormat, businessRiskId, securityRule, rulePresence, showAdvisories, advisory, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns top level overview of vulnerabilities affecting given account.
         * @summary Top level overview of vulnerabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutiveReport(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutiveReport>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getExecutiveReport(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return Ansible playbook template for given rule id.
         * @summary Playbook template for CVEs with security rules.
         * @param {string} ruleId Insights security rule ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaybookTemplate(ruleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybookTemplate>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getPlaybookTemplate(ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns available status and status_id pairs where status_id is internal ID of the status.
         * @summary Available status/status_id pairs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusListOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getStatusList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides details of a system, e.g. it\'s opt out status.
         * @summary System details.
         * @param {string} inventoryId Inventory ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemDetails(inventoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemDetailsOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getSystemDetails(inventoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List systems IDs visible to logged in account.
         * @summary List systems IDs along with additional info about opt out state of the system.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {boolean} [stale] If set to true, shows stale systems. If not set defaults to false.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [optOut] If set to true, shows systems which have been opted out from vulnerability application. If not set defaults to false. If combined with new excluded option produces undefined default behavior.
         * @param {Array<boolean>} [excluded] Comma seprated string with bools. First boolean controls displaying systems which are not excluded. Second one toggles displaying of systems excluded from vulnerability analysis. Defaults to showing only those systems which are not excluded. If combined with (deprecated) opt_out option produces undefined behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemsIds(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, dataFormat?: string, stale?: boolean, uuid?: string, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, optOut?: boolean, excluded?: Array<boolean>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemIdsOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getSystemsIds(filter, limit, offset, page, pageSize, sort, dataFormat, stale, uuid, tags, sapSids, sapSystem, optOut, excluded, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List systems visible to logged in account with basic information related to vulnerabilities.
         * @summary List systems.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {boolean} [stale] If set to true, shows stale systems. If not set defaults to false.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [optOut] If set to true, shows systems which have been opted out from vulnerability application. If not set defaults to false. If combined with new excluded option produces undefined behavior.
         * @param {Array<boolean>} [excluded] Comma seprated string with bools. First boolean controls displaying systems which are not excluded. Second one toggles displaying of systems excluded from vulnerability analysis. Defaults to showing only those systems which are not excluded. If combined with (deprecated) opt_out option produces undefined behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemsList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, dataFormat?: string, stale?: boolean, uuid?: string, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, optOut?: boolean, excluded?: Array<boolean>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemListOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getSystemsList(filter, limit, offset, page, pageSize, sort, dataFormat, stale, uuid, tags, sapSids, sapSystem, optOut, excluded, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get application version.
         * @summary Application version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getVersion(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets business risk for a CVE.
         * @summary Set business risk for a CVE.
         * @param {CveRiskIn} cveRiskIn Values to be set. At least one of the \&quot;business_risk_id\&quot; or \&quot;business_risk_text\&quot; parameters is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCveBusinessRisk(cveRiskIn: CveRiskIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkChangeOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).setCveBusinessRisk(cveRiskIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets status for a CVE.
         * @summary Set status for a CVE.
         * @param {CveStatusIn} cveStatusIn Values to be set. At least one of the \&quot;status_id\&quot; or \&quot;status_text\&quot; parameters is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCveStatus(cveStatusIn: CveStatusIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkChangeOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).setCveStatus(cveStatusIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets status for given hosts and CVEs.
         * @summary Set status for system vulnerabilities.
         * @param {StatusIn} statusIn Values to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStatus(statusIn: StatusIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).setStatus(statusIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Opts in/out a systems. Opted out system is not shown and manageable by the vulnerability application.
         * @summary Opt in/out a system to/from vulnerability application.
         * @param {string} inventoryId Inventory ID.
         * @param {boolean} value opt_out setting of the host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSystemOptOut(inventoryId: string, value: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).setSystemOptOut(inventoryId, value, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Opts in/out a systems. Opted out system is not shown and manageable by the vulnerability application.
         * @summary Opt in/out a system to/from vulnerability application.
         * @param {OptOutIn} optOutIn Values to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSystemsOptOut(optOutIn: OptOutIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkChangeOut>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).setSystemsOptOut(optOutIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes system from database.
         * @summary Delete system.
         * @param {string} inventoryId Inventory ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSystem(inventoryId: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteSystem(inventoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Report of affected systems for a given CVE.
         * @summary Affected systems for a given CVE.
         * @param {string} cveId CVE id.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [ruleKey] Filters security rules by its error key.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {string} [securityRule] Filter by presence (boolean) or name (string) of security rule - Deprecated, will get obsolete, use rule_key and rule_presence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffectedSystemsByCve(cveId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, statusId?: string, dataFormat?: string, uuid?: string, ruleKey?: Array<string>, rulePresence?: Array<boolean>, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, showAdvisories?: boolean, advisory?: string, securityRule?: string, options?: any): AxiosPromise<AffectedSystemsOut> {
            return DefaultApiFp(configuration).getAffectedSystemsByCve(cveId, filter, limit, offset, page, pageSize, sort, statusId, dataFormat, uuid, ruleKey, rulePresence, tags, sapSids, sapSystem, showAdvisories, advisory, securityRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Report of IDs of affected systems for a given CVE.
         * @summary IDs of affected systems for a given CVE.
         * @param {string} cveId CVE id.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [ruleKey] Filters security rules by its error key.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {string} [securityRule] Filter by presence (boolean) or name (string) of security rule - Deprecated, will get obsolete, use rule_key and rule_presence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffectedSystemsIdsByCve(cveId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, statusId?: string, dataFormat?: string, uuid?: string, ruleKey?: Array<string>, rulePresence?: Array<boolean>, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, showAdvisories?: boolean, advisory?: string, securityRule?: string, options?: any): AxiosPromise<AffectedSystemsIdsOut> {
            return DefaultApiFp(configuration).getAffectedSystemsIdsByCve(cveId, filter, limit, offset, page, pageSize, sort, statusId, dataFormat, uuid, ruleKey, rulePresence, tags, sapSids, sapSystem, showAdvisories, advisory, securityRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks database availability and API response threshold time.
         * @summary Health status of application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiStatus(options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).getApiStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns available business risk and business_risk_id pairs where business_risk_id is internal ID of the business risk.
         * @summary Available business risk/business_risk_id pairs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessRiskList(options?: any): AxiosPromise<BusinessRiskListOut> {
            return DefaultApiFp(configuration).getBusinessRiskList(options).then((request) => request(axios, basePath));
        },
        /**
         * Show all information about given CVE.
         * @summary Details of a CVE.
         * @param {string} cveId CVE id.
         * @param {boolean} [showAdvisoriesDetails] If true shows detailed advisory information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveDetails(cveId: string, showAdvisoriesDetails?: boolean, options?: any): AxiosPromise<CveDetailOut> {
            return DefaultApiFp(configuration).getCveDetails(cveId, showAdvisoriesDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * Shows IDs of all CVEs the system is exposed to.
         * @summary CVE IDs report for a system.
         * @param {string} inventoryId Inventory ID.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveIdsBySystem(inventoryId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, statusId?: string, dataFormat?: string, businessRiskId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, options?: any): AxiosPromise<SystemCvesIdsOut> {
            return DefaultApiFp(configuration).getCveIdsBySystem(inventoryId, filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, statusId, dataFormat, businessRiskId, securityRule, rulePresence, options).then((request) => request(axios, basePath));
        },
        /**
         * Overview of vulnerabilities IDs across whole host inventory.
         * @summary Vulnerabilities IDs overview.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAll] Show all known vulnerabilities IDs, regardless of number of affected systems. If combined with new affecting option, resets to default behavior.
         * @param {Array<boolean>} [affecting] Comma seprated string with bools. First boolean controls displaying CVEs with at least one system affected. Second one toggles CVEs with no systems affected. Defaults to showing only CVEs with at least one system affected. If combined with (deprecated) show_all option, resets to default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveIdsList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, dataFormat?: string, businessRiskId?: string, statusId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAll?: boolean, affecting?: Array<boolean>, options?: any): AxiosPromise<VulnerabilitiesIdsOut> {
            return DefaultApiFp(configuration).getCveIdsList(filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, dataFormat, businessRiskId, statusId, securityRule, rulePresence, showAll, affecting, options).then((request) => request(axios, basePath));
        },
        /**
         * Overview of vulnerabilities across whole host inventory.
         * @summary Vulnerabilities overview.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAll] Show all known vulnerabilities, regardless of number of affected systems. If combined with new affecting option, resets to default behavior.
         * @param {Array<boolean>} [affecting] Comma seprated string with bools. First boolean controls displaying CVEs with at least one system affected. Second one toggles CVEs with no systems affected. Defaults to showing only CVEs with at least one system affected. If combined with (deprecated) show_all option, resets to default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, dataFormat?: string, businessRiskId?: string, statusId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAll?: boolean, affecting?: Array<boolean>, options?: any): AxiosPromise<VulnerabilitiesOut> {
            return DefaultApiFp(configuration).getCveList(filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, dataFormat, businessRiskId, statusId, securityRule, rulePresence, showAll, affecting, options).then((request) => request(axios, basePath));
        },
        /**
         * Shows detailed information about all CVEs the system is exposed to.
         * @summary CVE report for a system.
         * @param {string} inventoryId Inventory ID.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
         * @param {number} [cvssTo] Filter based on cvss score, up to the value.
         * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
         * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
         * @param {string} [impact] Filter based on impact IDs.
         * @param {string} [statusId] Filer based on CVE status ID.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {string} [businessRiskId] Filter based on business risk IDs.
         * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
         * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
         * @param {boolean} [showAdvisories] If true shows advisories list
         * @param {string} [advisory] filter by advisory name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCveListBySystem(inventoryId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, statusId?: string, dataFormat?: string, businessRiskId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAdvisories?: boolean, advisory?: string, options?: any): AxiosPromise<SystemCvesOut> {
            return DefaultApiFp(configuration).getCveListBySystem(inventoryId, filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, statusId, dataFormat, businessRiskId, securityRule, rulePresence, showAdvisories, advisory, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns top level overview of vulnerabilities affecting given account.
         * @summary Top level overview of vulnerabilities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutiveReport(options?: any): AxiosPromise<ExecutiveReport> {
            return DefaultApiFp(configuration).getExecutiveReport(options).then((request) => request(axios, basePath));
        },
        /**
         * Return Ansible playbook template for given rule id.
         * @summary Playbook template for CVEs with security rules.
         * @param {string} ruleId Insights security rule ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybookTemplate(ruleId: string, options?: any): AxiosPromise<PlaybookTemplate> {
            return DefaultApiFp(configuration).getPlaybookTemplate(ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns available status and status_id pairs where status_id is internal ID of the status.
         * @summary Available status/status_id pairs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusList(options?: any): AxiosPromise<StatusListOut> {
            return DefaultApiFp(configuration).getStatusList(options).then((request) => request(axios, basePath));
        },
        /**
         * Provides details of a system, e.g. it\'s opt out status.
         * @summary System details.
         * @param {string} inventoryId Inventory ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemDetails(inventoryId: string, options?: any): AxiosPromise<SystemDetailsOut> {
            return DefaultApiFp(configuration).getSystemDetails(inventoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List systems IDs visible to logged in account.
         * @summary List systems IDs along with additional info about opt out state of the system.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {boolean} [stale] If set to true, shows stale systems. If not set defaults to false.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [optOut] If set to true, shows systems which have been opted out from vulnerability application. If not set defaults to false. If combined with new excluded option produces undefined default behavior.
         * @param {Array<boolean>} [excluded] Comma seprated string with bools. First boolean controls displaying systems which are not excluded. Second one toggles displaying of systems excluded from vulnerability analysis. Defaults to showing only those systems which are not excluded. If combined with (deprecated) opt_out option produces undefined behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemsIds(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, dataFormat?: string, stale?: boolean, uuid?: string, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, optOut?: boolean, excluded?: Array<boolean>, options?: any): AxiosPromise<SystemIdsOut> {
            return DefaultApiFp(configuration).getSystemsIds(filter, limit, offset, page, pageSize, sort, dataFormat, stale, uuid, tags, sapSids, sapSystem, optOut, excluded, options).then((request) => request(axios, basePath));
        },
        /**
         * List systems visible to logged in account with basic information related to vulnerabilities.
         * @summary List systems.
         * @param {string} [filter] Full text filter for the display name of system.
         * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
         * @param {string} [sort] Sorting used for response.
         * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
         * @param {boolean} [stale] If set to true, shows stale systems. If not set defaults to false.
         * @param {string} [uuid] Filter based on UUID of inventory.
         * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
         * @param {Array<string>} [sapSids] List of SAP IDs to filter with
         * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
         * @param {boolean} [optOut] If set to true, shows systems which have been opted out from vulnerability application. If not set defaults to false. If combined with new excluded option produces undefined behavior.
         * @param {Array<boolean>} [excluded] Comma seprated string with bools. First boolean controls displaying systems which are not excluded. Second one toggles displaying of systems excluded from vulnerability analysis. Defaults to showing only those systems which are not excluded. If combined with (deprecated) opt_out option produces undefined behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemsList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, dataFormat?: string, stale?: boolean, uuid?: string, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, optOut?: boolean, excluded?: Array<boolean>, options?: any): AxiosPromise<SystemListOut> {
            return DefaultApiFp(configuration).getSystemsList(filter, limit, offset, page, pageSize, sort, dataFormat, stale, uuid, tags, sapSids, sapSystem, optOut, excluded, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application version.
         * @summary Application version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<VersionOut> {
            return DefaultApiFp(configuration).getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * Sets business risk for a CVE.
         * @summary Set business risk for a CVE.
         * @param {CveRiskIn} cveRiskIn Values to be set. At least one of the \&quot;business_risk_id\&quot; or \&quot;business_risk_text\&quot; parameters is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCveBusinessRisk(cveRiskIn: CveRiskIn, options?: any): AxiosPromise<BulkChangeOut> {
            return DefaultApiFp(configuration).setCveBusinessRisk(cveRiskIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets status for a CVE.
         * @summary Set status for a CVE.
         * @param {CveStatusIn} cveStatusIn Values to be set. At least one of the \&quot;status_id\&quot; or \&quot;status_text\&quot; parameters is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCveStatus(cveStatusIn: CveStatusIn, options?: any): AxiosPromise<BulkChangeOut> {
            return DefaultApiFp(configuration).setCveStatus(cveStatusIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets status for given hosts and CVEs.
         * @summary Set status for system vulnerabilities.
         * @param {StatusIn} statusIn Values to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStatus(statusIn: StatusIn, options?: any): AxiosPromise<StatusOut> {
            return DefaultApiFp(configuration).setStatus(statusIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Opts in/out a systems. Opted out system is not shown and manageable by the vulnerability application.
         * @summary Opt in/out a system to/from vulnerability application.
         * @param {string} inventoryId Inventory ID.
         * @param {boolean} value opt_out setting of the host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSystemOptOut(inventoryId: string, value: boolean, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).setSystemOptOut(inventoryId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * Opts in/out a systems. Opted out system is not shown and manageable by the vulnerability application.
         * @summary Opt in/out a system to/from vulnerability application.
         * @param {OptOutIn} optOutIn Values to be set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSystemsOptOut(optOutIn: OptOutIn, options?: any): AxiosPromise<BulkChangeOut> {
            return DefaultApiFp(configuration).setSystemsOptOut(optOutIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Deletes system from database.
     * @summary Delete system.
     * @param {string} inventoryId Inventory ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteSystem(inventoryId: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteSystem(inventoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report of affected systems for a given CVE.
     * @summary Affected systems for a given CVE.
     * @param {string} cveId CVE id.
     * @param {string} [filter] Full text filter for the display name of system.
     * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {string} [sort] Sorting used for response.
     * @param {string} [statusId] Filer based on CVE status ID.
     * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
     * @param {string} [uuid] Filter based on UUID of inventory.
     * @param {Array<string>} [ruleKey] Filters security rules by its error key.
     * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
     * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
     * @param {Array<string>} [sapSids] List of SAP IDs to filter with
     * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
     * @param {boolean} [showAdvisories] If true shows advisories list
     * @param {string} [advisory] filter by advisory name
     * @param {string} [securityRule] Filter by presence (boolean) or name (string) of security rule - Deprecated, will get obsolete, use rule_key and rule_presence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAffectedSystemsByCve(cveId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, statusId?: string, dataFormat?: string, uuid?: string, ruleKey?: Array<string>, rulePresence?: Array<boolean>, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, showAdvisories?: boolean, advisory?: string, securityRule?: string, options?: any) {
        return DefaultApiFp(this.configuration).getAffectedSystemsByCve(cveId, filter, limit, offset, page, pageSize, sort, statusId, dataFormat, uuid, ruleKey, rulePresence, tags, sapSids, sapSystem, showAdvisories, advisory, securityRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Report of IDs of affected systems for a given CVE.
     * @summary IDs of affected systems for a given CVE.
     * @param {string} cveId CVE id.
     * @param {string} [filter] Full text filter for the display name of system.
     * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {string} [sort] Sorting used for response.
     * @param {string} [statusId] Filer based on CVE status ID.
     * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
     * @param {string} [uuid] Filter based on UUID of inventory.
     * @param {Array<string>} [ruleKey] Filters security rules by its error key.
     * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
     * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
     * @param {Array<string>} [sapSids] List of SAP IDs to filter with
     * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
     * @param {boolean} [showAdvisories] If true shows advisories list
     * @param {string} [advisory] filter by advisory name
     * @param {string} [securityRule] Filter by presence (boolean) or name (string) of security rule - Deprecated, will get obsolete, use rule_key and rule_presence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAffectedSystemsIdsByCve(cveId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, statusId?: string, dataFormat?: string, uuid?: string, ruleKey?: Array<string>, rulePresence?: Array<boolean>, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, showAdvisories?: boolean, advisory?: string, securityRule?: string, options?: any) {
        return DefaultApiFp(this.configuration).getAffectedSystemsIdsByCve(cveId, filter, limit, offset, page, pageSize, sort, statusId, dataFormat, uuid, ruleKey, rulePresence, tags, sapSids, sapSystem, showAdvisories, advisory, securityRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks database availability and API response threshold time.
     * @summary Health status of application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApiStatus(options?: any) {
        return DefaultApiFp(this.configuration).getApiStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns available business risk and business_risk_id pairs where business_risk_id is internal ID of the business risk.
     * @summary Available business risk/business_risk_id pairs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBusinessRiskList(options?: any) {
        return DefaultApiFp(this.configuration).getBusinessRiskList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all information about given CVE.
     * @summary Details of a CVE.
     * @param {string} cveId CVE id.
     * @param {boolean} [showAdvisoriesDetails] If true shows detailed advisory information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCveDetails(cveId: string, showAdvisoriesDetails?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).getCveDetails(cveId, showAdvisoriesDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shows IDs of all CVEs the system is exposed to.
     * @summary CVE IDs report for a system.
     * @param {string} inventoryId Inventory ID.
     * @param {string} [filter] Full text filter for the display name of system.
     * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {string} [sort] Sorting used for response.
     * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @param {number} [cvssTo] Filter based on cvss score, up to the value.
     * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
     * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
     * @param {string} [impact] Filter based on impact IDs.
     * @param {string} [statusId] Filer based on CVE status ID.
     * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
     * @param {string} [businessRiskId] Filter based on business risk IDs.
     * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
     * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCveIdsBySystem(inventoryId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, statusId?: string, dataFormat?: string, businessRiskId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, options?: any) {
        return DefaultApiFp(this.configuration).getCveIdsBySystem(inventoryId, filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, statusId, dataFormat, businessRiskId, securityRule, rulePresence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Overview of vulnerabilities IDs across whole host inventory.
     * @summary Vulnerabilities IDs overview.
     * @param {string} [filter] Full text filter for the display name of system.
     * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {string} [sort] Sorting used for response.
     * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @param {number} [cvssTo] Filter based on cvss score, up to the value.
     * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
     * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
     * @param {string} [impact] Filter based on impact IDs.
     * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
     * @param {string} [businessRiskId] Filter based on business risk IDs.
     * @param {string} [statusId] Filer based on CVE status ID.
     * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
     * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
     * @param {boolean} [showAll] Show all known vulnerabilities IDs, regardless of number of affected systems. If combined with new affecting option, resets to default behavior.
     * @param {Array<boolean>} [affecting] Comma seprated string with bools. First boolean controls displaying CVEs with at least one system affected. Second one toggles CVEs with no systems affected. Defaults to showing only CVEs with at least one system affected. If combined with (deprecated) show_all option, resets to default behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCveIdsList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, dataFormat?: string, businessRiskId?: string, statusId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAll?: boolean, affecting?: Array<boolean>, options?: any) {
        return DefaultApiFp(this.configuration).getCveIdsList(filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, dataFormat, businessRiskId, statusId, securityRule, rulePresence, showAll, affecting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Overview of vulnerabilities across whole host inventory.
     * @summary Vulnerabilities overview.
     * @param {string} [filter] Full text filter for the display name of system.
     * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {string} [sort] Sorting used for response.
     * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @param {number} [cvssTo] Filter based on cvss score, up to the value.
     * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
     * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
     * @param {string} [impact] Filter based on impact IDs.
     * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
     * @param {string} [businessRiskId] Filter based on business risk IDs.
     * @param {string} [statusId] Filer based on CVE status ID.
     * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
     * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
     * @param {boolean} [showAll] Show all known vulnerabilities, regardless of number of affected systems. If combined with new affecting option, resets to default behavior.
     * @param {Array<boolean>} [affecting] Comma seprated string with bools. First boolean controls displaying CVEs with at least one system affected. Second one toggles CVEs with no systems affected. Defaults to showing only CVEs with at least one system affected. If combined with (deprecated) show_all option, resets to default behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCveList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, dataFormat?: string, businessRiskId?: string, statusId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAll?: boolean, affecting?: Array<boolean>, options?: any) {
        return DefaultApiFp(this.configuration).getCveList(filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, dataFormat, businessRiskId, statusId, securityRule, rulePresence, showAll, affecting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shows detailed information about all CVEs the system is exposed to.
     * @summary CVE report for a system.
     * @param {string} inventoryId Inventory ID.
     * @param {string} [filter] Full text filter for the display name of system.
     * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {string} [sort] Sorting used for response.
     * @param {number} [cvssFrom] Filter based on cvss score, starting from the value. Use -1 to include also CVEs with N/A cvss score.
     * @param {number} [cvssTo] Filter based on cvss score, up to the value.
     * @param {string} [publicFrom] Filter CVEs based on their published date, starting from the date.
     * @param {string} [publicTo] Filter CVEs based on their published date, up to the date.
     * @param {string} [impact] Filter based on impact IDs.
     * @param {string} [statusId] Filer based on CVE status ID.
     * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
     * @param {string} [businessRiskId] Filter based on business risk IDs.
     * @param {boolean} [securityRule] If true shows only CVEs with security rule associated, if false shows CVEs without rules. When not set shows all CVEs - Deprecated, will get obsolete, use rule_presence.
     * @param {Array<boolean>} [rulePresence] Comma seprated string with bools. If true shows only CVEs with security rule associated, if false shows CVEs without rules. true, false shows all.
     * @param {boolean} [showAdvisories] If true shows advisories list
     * @param {string} [advisory] filter by advisory name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCveListBySystem(inventoryId: string, filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, cvssFrom?: number, cvssTo?: number, publicFrom?: string, publicTo?: string, impact?: string, statusId?: string, dataFormat?: string, businessRiskId?: string, securityRule?: boolean, rulePresence?: Array<boolean>, showAdvisories?: boolean, advisory?: string, options?: any) {
        return DefaultApiFp(this.configuration).getCveListBySystem(inventoryId, filter, limit, offset, page, pageSize, sort, cvssFrom, cvssTo, publicFrom, publicTo, impact, statusId, dataFormat, businessRiskId, securityRule, rulePresence, showAdvisories, advisory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns top level overview of vulnerabilities affecting given account.
     * @summary Top level overview of vulnerabilities.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExecutiveReport(options?: any) {
        return DefaultApiFp(this.configuration).getExecutiveReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return Ansible playbook template for given rule id.
     * @summary Playbook template for CVEs with security rules.
     * @param {string} ruleId Insights security rule ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPlaybookTemplate(ruleId: string, options?: any) {
        return DefaultApiFp(this.configuration).getPlaybookTemplate(ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns available status and status_id pairs where status_id is internal ID of the status.
     * @summary Available status/status_id pairs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatusList(options?: any) {
        return DefaultApiFp(this.configuration).getStatusList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides details of a system, e.g. it\'s opt out status.
     * @summary System details.
     * @param {string} inventoryId Inventory ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSystemDetails(inventoryId: string, options?: any) {
        return DefaultApiFp(this.configuration).getSystemDetails(inventoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List systems IDs visible to logged in account.
     * @summary List systems IDs along with additional info about opt out state of the system.
     * @param {string} [filter] Full text filter for the display name of system.
     * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {string} [sort] Sorting used for response.
     * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
     * @param {boolean} [stale] If set to true, shows stale systems. If not set defaults to false.
     * @param {string} [uuid] Filter based on UUID of inventory.
     * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
     * @param {Array<string>} [sapSids] List of SAP IDs to filter with
     * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
     * @param {boolean} [optOut] If set to true, shows systems which have been opted out from vulnerability application. If not set defaults to false. If combined with new excluded option produces undefined default behavior.
     * @param {Array<boolean>} [excluded] Comma seprated string with bools. First boolean controls displaying systems which are not excluded. Second one toggles displaying of systems excluded from vulnerability analysis. Defaults to showing only those systems which are not excluded. If combined with (deprecated) opt_out option produces undefined behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSystemsIds(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, dataFormat?: string, stale?: boolean, uuid?: string, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, optOut?: boolean, excluded?: Array<boolean>, options?: any) {
        return DefaultApiFp(this.configuration).getSystemsIds(filter, limit, offset, page, pageSize, sort, dataFormat, stale, uuid, tags, sapSids, sapSystem, optOut, excluded, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List systems visible to logged in account with basic information related to vulnerabilities.
     * @summary List systems.
     * @param {string} [filter] Full text filter for the display name of system.
     * @param {number} [limit] Maximum number of records per page. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [offset] Offset of first record of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [page] Page number of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {number} [pageSize] Page size of paginated response. Limit/Offset pagination wins over page/page_size pagination.
     * @param {string} [sort] Sorting used for response.
     * @param {string} [dataFormat] Format of the output data, either JSON (default) or CSV.
     * @param {boolean} [stale] If set to true, shows stale systems. If not set defaults to false.
     * @param {string} [uuid] Filter based on UUID of inventory.
     * @param {Array<string>} [tags] Filter based on hosts tags. Tags needs to be in query format, that means &lt;namespace&gt;/&lt;key&gt;&#x3D;&lt;value&gt; or &lt;namespace&gt;/&lt;key&gt; if value is null. Characters \&#39;/\&#39;, \&#39;&#x3D;\&#39; in tag values needs to be escaped by url encoding.
     * @param {Array<string>} [sapSids] List of SAP IDs to filter with
     * @param {boolean} [sapSystem] Boolean value which shows systems managed by SAP.
     * @param {boolean} [optOut] If set to true, shows systems which have been opted out from vulnerability application. If not set defaults to false. If combined with new excluded option produces undefined behavior.
     * @param {Array<boolean>} [excluded] Comma seprated string with bools. First boolean controls displaying systems which are not excluded. Second one toggles displaying of systems excluded from vulnerability analysis. Defaults to showing only those systems which are not excluded. If combined with (deprecated) opt_out option produces undefined behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSystemsList(filter?: string, limit?: number, offset?: number, page?: number, pageSize?: number, sort?: string, dataFormat?: string, stale?: boolean, uuid?: string, tags?: Array<string>, sapSids?: Array<string>, sapSystem?: boolean, optOut?: boolean, excluded?: Array<boolean>, options?: any) {
        return DefaultApiFp(this.configuration).getSystemsList(filter, limit, offset, page, pageSize, sort, dataFormat, stale, uuid, tags, sapSids, sapSystem, optOut, excluded, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application version.
     * @summary Application version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVersion(options?: any) {
        return DefaultApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets business risk for a CVE.
     * @summary Set business risk for a CVE.
     * @param {CveRiskIn} cveRiskIn Values to be set. At least one of the \&quot;business_risk_id\&quot; or \&quot;business_risk_text\&quot; parameters is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setCveBusinessRisk(cveRiskIn: CveRiskIn, options?: any) {
        return DefaultApiFp(this.configuration).setCveBusinessRisk(cveRiskIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets status for a CVE.
     * @summary Set status for a CVE.
     * @param {CveStatusIn} cveStatusIn Values to be set. At least one of the \&quot;status_id\&quot; or \&quot;status_text\&quot; parameters is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setCveStatus(cveStatusIn: CveStatusIn, options?: any) {
        return DefaultApiFp(this.configuration).setCveStatus(cveStatusIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets status for given hosts and CVEs.
     * @summary Set status for system vulnerabilities.
     * @param {StatusIn} statusIn Values to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setStatus(statusIn: StatusIn, options?: any) {
        return DefaultApiFp(this.configuration).setStatus(statusIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Opts in/out a systems. Opted out system is not shown and manageable by the vulnerability application.
     * @summary Opt in/out a system to/from vulnerability application.
     * @param {string} inventoryId Inventory ID.
     * @param {boolean} value opt_out setting of the host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setSystemOptOut(inventoryId: string, value: boolean, options?: any) {
        return DefaultApiFp(this.configuration).setSystemOptOut(inventoryId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Opts in/out a systems. Opted out system is not shown and manageable by the vulnerability application.
     * @summary Opt in/out a system to/from vulnerability application.
     * @param {OptOutIn} optOutIn Values to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setSystemsOptOut(optOutIn: OptOutIn, options?: any) {
        return DefaultApiFp(this.configuration).setSystemsOptOut(optOutIn, options).then((request) => request(this.axios, this.basePath));
    }

}


