/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Services for RHEL Compliance API v2
 * UNDER DEVELOPMENT: This version of the API is not fully done and some parts of it might change! This is the API for Cloud Services for RHEL Compliance. You can find out more about Red Hat Cloud Services for RHEL at [https://console.redhat.com/](https://console.redhat.com/)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template condition
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AssignRulesRequest
 */
export interface AssignRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof AssignRulesRequest
     */
    'ids'?: any;
}
/**
 * 
 * @export
 * @interface CreatePolicy201Response
 */
export interface CreatePolicy201Response {
    /**
     * 
     * @type {CreatePolicy201ResponseData}
     * @memberof CreatePolicy201Response
     */
    'data'?: CreatePolicy201ResponseData;
}
/**
 * 
 * @export
 * @interface CreatePolicy201ResponseData
 */
export interface CreatePolicy201ResponseData {
    /**
     * 
     * @type {Policy}
     * @memberof CreatePolicy201ResponseData
     */
    'schema'?: Policy;
}
/**
 * 
 * @export
 * @interface Error
 */
export interface Errors {
    /**
     * 
     * @type {any}
     * @memberof Error
     */
    'errors': any;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Links {
    /**
     * Link to first page
     * @type {any}
     * @memberof Link
     */
    'first'?: any;
    /**
     * Link to last page
     * @type {any}
     * @memberof Link
     */
    'last'?: any;
    /**
     * Link to previous page
     * @type {any}
     * @memberof Link
     */
    'previous'?: any;
    /**
     * Link to next page
     * @type {any}
     * @memberof Link
     */
    'next'?: any;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Total number of item
     * @type {any}
     * @memberof Metadata
     */
    'total'?: any;
    /**
     * Number of items returned per page
     * @type {any}
     * @memberof Metadata
     */
    'limit'?: any;
    /**
     * Offset of the first item of paginated response
     * @type {any}
     * @memberof Metadata
     */
    'offset'?: any;
    /**
     * Attribute and direction the items are sorted by
     * @type {any}
     * @memberof Metadata
     */
    'sort_by'?: any;
    /**
     * Query string used to filter items by their attribute
     * @type {any}
     * @memberof Metadata
     */
    'filter'?: any;
}
/**
 * 
 * @export
 * @interface Policies200Response
 */
export interface Policies200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Policies200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Policies200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Policies200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {any}
     * @memberof Policy
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Policy
     */
    'type'?: PolicyTypeEnum;
    /**
     * Short title of the Policy
     * @type {any}
     * @memberof Policy
     */
    'title'?: any;
    /**
     * Longer description of the Policy
     * @type {any}
     * @memberof Policy
     */
    'description'?: any;
    /**
     * The Business Objective associated to the Policy
     * @type {any}
     * @memberof Policy
     */
    'business_objective'?: any;
    /**
     * The percentage above which the Policy meets compliance requirement
     * @type {any}
     * @memberof Policy
     */
    'compliance_threshold': any;
    /**
     * Identifier of the underlying Profile
     * @type {any}
     * @memberof Policy
     */
    'profile_id': any;
    /**
     * Major version of the Operating System that the Policy cover
     * @type {any}
     * @memberof Policy
     */
    'os_major_version'?: any;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof Policy
     */
    'ref_id'?: any;
    /**
     * Title of the associated Policy
     * @type {any}
     * @memberof Policy
     */
    'profile_title'?: any;
    /**
     * The number of Systems assigned to this Policy
     * @type {any}
     * @memberof Policy
     */
    'total_system_count'?: any;
}

export const PolicyTypeEnum = {
    Policy: 'policy'
} as const;

export type PolicyTypeEnum = typeof PolicyTypeEnum[keyof typeof PolicyTypeEnum];

/**
 * 
 * @export
 * @interface PolicyUpdate
 */
export interface PolicyUpdate {
    /**
     * Longer description of the Policy
     * @type {any}
     * @memberof PolicyUpdate
     */
    'description'?: any;
    /**
     * The Business Objective associated to the Policy
     * @type {any}
     * @memberof PolicyUpdate
     */
    'business_objective'?: any;
    /**
     * The percentage above which the Policy meets compliance requirement
     * @type {any}
     * @memberof PolicyUpdate
     */
    'compliance_threshold'?: any;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {any}
     * @memberof Profile
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Profile
     */
    'type'?: ProfileTypeEnum;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof Profile
     */
    'ref_id'?: any;
    /**
     * Short title of the Profile
     * @type {any}
     * @memberof Profile
     */
    'title'?: any;
    /**
     * Longer description of the Profile
     * @type {any}
     * @memberof Profile
     */
    'description'?: any;
    /**
     * Pair of keys and values for Value Definition customization
     * @type {any}
     * @memberof Profile
     */
    'value_overrides'?: any;
}

export const ProfileTypeEnum = {
    Profile: 'profile'
} as const;

export type ProfileTypeEnum = typeof ProfileTypeEnum[keyof typeof ProfileTypeEnum];

/**
 * 
 * @export
 * @interface Profile200Response
 */
export interface Profile200Response {
    /**
     * 
     * @type {Profile200ResponseData}
     * @memberof Profile200Response
     */
    'data'?: Profile200ResponseData;
}
/**
 * 
 * @export
 * @interface Profile200ResponseData
 */
export interface Profile200ResponseData {
    /**
     * 
     * @type {Profile}
     * @memberof Profile200ResponseData
     */
    'schema'?: Profile;
}
/**
 * 
 * @export
 * @interface Profiles200Response
 */
export interface Profiles200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Profiles200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Profiles200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Profiles200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * 
     * @type {any}
     * @memberof Report
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Report
     */
    'type'?: ReportTypeEnum;
    /**
     * Short title of the Report
     * @type {any}
     * @memberof Report
     */
    'title'?: any;
    /**
     * The Business Objective associated to the Policy
     * @type {any}
     * @memberof Report
     */
    'business_objective'?: any;
    /**
     * The percentage above which the Policy meets compliance requirement
     * @type {any}
     * @memberof Report
     */
    'compliance_threshold'?: any;
    /**
     * Major version of the Operating System that the Report cover
     * @type {any}
     * @memberof Report
     */
    'os_major_version'?: any;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof Report
     */
    'ref_id'?: any;
    /**
     * Title of the associated Profile
     * @type {any}
     * @memberof Report
     */
    'profile_title'?: any;
    /**
     * The number of Systems assigned to this Report
     * @type {any}
     * @memberof Report
     */
    'assigned_system_count'?: any;
    /**
     * The number of compliant Systems assigned to this Report
     * @type {any}
     * @memberof Report
     */
    'compliant_system_count'?: any;
    /**
     * Informs if the user has access to all the account\'s system
     * @type {any}
     * @memberof Report
     */
    'all_systems_exposed'?: any;
    /**
     * The number of unsupported Systems assigned to this Report
     * @type {any}
     * @memberof Report
     */
    'unsupported_system_count'?: any;
}

export const ReportTypeEnum = {
    Report: 'report'
} as const;

export type ReportTypeEnum = typeof ReportTypeEnum[keyof typeof ReportTypeEnum];

/**
 * 
 * @export
 * @interface Report200Response
 */
export interface Report200Response {
    /**
     * 
     * @type {Report200ResponseData}
     * @memberof Report200Response
     */
    'data'?: Report200ResponseData;
}
/**
 * 
 * @export
 * @interface Report200ResponseData
 */
export interface Report200ResponseData {
    /**
     * 
     * @type {Report}
     * @memberof Report200ResponseData
     */
    'schema'?: Report;
}
/**
 * 
 * @export
 * @interface Reports200Response
 */
export interface Reports200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Reports200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Reports200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Reports200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {any}
     * @memberof Rule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Rule
     */
    'type'?: RuleTypeEnum;
    /**
     * Identificator of the Rule
     * @type {any}
     * @memberof Rule
     */
    'ref_id'?: any;
    /**
     * Short title of the Rule
     * @type {any}
     * @memberof Rule
     */
    'title'?: any;
    /**
     * Rationale of the Rule
     * @type {any}
     * @memberof Rule
     */
    'rationale'?: any;
    /**
     * Longer description of the Rule
     * @type {any}
     * @memberof Rule
     */
    'description'?: any;
    /**
     * The original sorting precedence of the Rule in the Security Guide
     * @type {any}
     * @memberof Rule
     */
    'precedence'?: any;
    /**
     * The severity of the Rule
     * @type {any}
     * @memberof Rule
     */
    'severity'?: any;
    /**
     * The idenfitier of the remediation associated to this rule, only available under profiles.
     * @type {any}
     * @memberof Rule
     */
    'remediation_issue_id'?: any;
}

export const RuleTypeEnum = {
    Rule: 'rule'
} as const;

export type RuleTypeEnum = typeof RuleTypeEnum[keyof typeof RuleTypeEnum];

/**
 * 
 * @export
 * @interface Rule200Response
 */
export interface Rule200Response {
    /**
     * 
     * @type {Rule200ResponseData}
     * @memberof Rule200Response
     */
    'data'?: Rule200ResponseData;
}
/**
 * 
 * @export
 * @interface Rule200ResponseData
 */
export interface Rule200ResponseData {
    /**
     * 
     * @type {Rule}
     * @memberof Rule200ResponseData
     */
    'schema'?: Rule;
}
/**
 * 
 * @export
 * @interface RuleGroup
 */
export interface RuleGroup {
    /**
     * 
     * @type {any}
     * @memberof RuleGroup
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RuleGroup
     */
    'type'?: RuleGroupTypeEnum;
    /**
     * Identificator of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'ref_id'?: any;
    /**
     * Short title of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'title'?: any;
    /**
     * Rationale of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'rationale'?: any;
    /**
     * Longer description of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'description'?: any;
    /**
     * The original sorting precedence of the Rule Group in the Security Guide
     * @type {any}
     * @memberof RuleGroup
     */
    'precedence'?: any;
}

export const RuleGroupTypeEnum = {
    RuleGroup: 'rule_group'
} as const;

export type RuleGroupTypeEnum = typeof RuleGroupTypeEnum[keyof typeof RuleGroupTypeEnum];

/**
 * 
 * @export
 * @interface RuleGroup200Response
 */
export interface RuleGroup200Response {
    /**
     * 
     * @type {RuleGroup200ResponseData}
     * @memberof RuleGroup200Response
     */
    'data'?: RuleGroup200ResponseData;
}
/**
 * 
 * @export
 * @interface RuleGroup200ResponseData
 */
export interface RuleGroup200ResponseData {
    /**
     * 
     * @type {RuleGroup}
     * @memberof RuleGroup200ResponseData
     */
    'schema'?: RuleGroup;
}
/**
 * 
 * @export
 * @interface RuleGroups200Response
 */
export interface RuleGroups200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof RuleGroups200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof RuleGroups200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof RuleGroups200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Rules200Response
 */
export interface Rules200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Rules200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Rules200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Rules200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface SecurityGuide
 */
export interface SecurityGuide {
    /**
     * 
     * @type {any}
     * @memberof SecurityGuide
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGuide
     */
    'type'?: SecurityGuideTypeEnum;
    /**
     * Identificator of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'ref_id'?: any;
    /**
     * Short title of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'title'?: any;
    /**
     * Version of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'version'?: any;
    /**
     * Longer description of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'description'?: any;
    /**
     * Major version of the Operating System that the Security Guide cover
     * @type {any}
     * @memberof SecurityGuide
     */
    'os_major_version'?: any;
}

export const SecurityGuideTypeEnum = {
    SecurityGuide: 'security_guide'
} as const;

export type SecurityGuideTypeEnum = typeof SecurityGuideTypeEnum[keyof typeof SecurityGuideTypeEnum];

/**
 * 
 * @export
 * @interface SecurityGuide200Response
 */
export interface SecurityGuide200Response {
    /**
     * 
     * @type {SecurityGuide200ResponseData}
     * @memberof SecurityGuide200Response
     */
    'data'?: SecurityGuide200ResponseData;
}
/**
 * 
 * @export
 * @interface SecurityGuide200ResponseData
 */
export interface SecurityGuide200ResponseData {
    /**
     * 
     * @type {SecurityGuide}
     * @memberof SecurityGuide200ResponseData
     */
    'schema'?: SecurityGuide;
}
/**
 * 
 * @export
 * @interface SecurityGuides200Response
 */
export interface SecurityGuides200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof SecurityGuides200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof SecurityGuides200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof SecurityGuides200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface SupportedProfile
 */
export interface SupportedProfile {
    /**
     * 
     * @type {any}
     * @memberof SupportedProfile
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SupportedProfile
     */
    'type'?: SupportedProfileTypeEnum;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'ref_id'?: any;
    /**
     * Short title of the Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'title'?: any;
    /**
     * Version of the latest Security Guide supporting this Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'security_guide_version'?: any;
    /**
     * Major version of the Operating System that the Profile cover
     * @type {any}
     * @memberof SupportedProfile
     */
    'os_major_version'?: any;
    /**
     * List of the supported Operating System minor versions that the Profile cover
     * @type {any}
     * @memberof SupportedProfile
     */
    'os_minor_versions'?: any;
}

export const SupportedProfileTypeEnum = {
    SupportedProfile: 'supported_profile'
} as const;

export type SupportedProfileTypeEnum = typeof SupportedProfileTypeEnum[keyof typeof SupportedProfileTypeEnum];

/**
 * 
 * @export
 * @interface SupportedProfiles200Response
 */
export interface SupportedProfiles200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof SupportedProfiles200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof SupportedProfiles200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof SupportedProfiles200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface System
 */
export interface System {
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'type'?: SystemTypeEnum;
    /**
     * Display Name of the System
     * @type {any}
     * @memberof System
     */
    'display_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'culled_timestamp'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'stale_timestamp'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'stale_warning_timestamp'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'updated'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'insights_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof System
     */
    'tags'?: any;
    /**
     * Major version of the Operating System
     * @type {any}
     * @memberof System
     */
    'os_major_version'?: any;
    /**
     * Minor version of the Operating System
     * @type {any}
     * @memberof System
     */
    'os_minor_version'?: any;
    /**
     * List of Policies assigned to the System, visible only when not listing Systems under a given Policy
     * @type {any}
     * @memberof System
     */
    'policies'?: any;
}

export const SystemTypeEnum = {
    System: 'system'
} as const;

export type SystemTypeEnum = typeof SystemTypeEnum[keyof typeof SystemTypeEnum];

/**
 * 
 * @export
 * @interface System200Response
 */
export interface System200Response {
    /**
     * 
     * @type {System200ResponseData}
     * @memberof System200Response
     */
    'data'?: System200ResponseData;
}
/**
 * 
 * @export
 * @interface System200ResponseData
 */
export interface System200ResponseData {
    /**
     * 
     * @type {System}
     * @memberof System200ResponseData
     */
    'schema'?: System;
}
/**
 * 
 * @export
 * @interface Systems200Response
 */
export interface Systems200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Systems200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Systems200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Systems200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface Tailoring
 */
export interface Tailoring {
    /**
     * 
     * @type {any}
     * @memberof Tailoring
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof Tailoring
     */
    'type'?: TailoringTypeEnum;
    /**
     * Identificator of the Profile from which the Tailoring was cloned
     * @type {any}
     * @memberof Tailoring
     */
    'profile_id'?: any;
    /**
     * Identificator of the Security Guide that contains the parent Profile
     * @type {any}
     * @memberof Tailoring
     */
    'security_guide_id'?: any;
    /**
     * Major version of the Operating System that the Tailoring cover
     * @type {any}
     * @memberof Tailoring
     */
    'os_major_version'?: any;
    /**
     * Minor version of the Operating System that the Tailoring cover
     * @type {any}
     * @memberof Tailoring
     */
    'os_minor_version'?: any;
    /**
     * Pair of keys and values for Value Definition customization
     * @type {any}
     * @memberof Tailoring
     */
    'value_overrides'?: any;
}

export const TailoringTypeEnum = {
    Tailoring: 'tailoring'
} as const;

export type TailoringTypeEnum = typeof TailoringTypeEnum[keyof typeof TailoringTypeEnum];

/**
 * 
 * @export
 * @interface Tailoring200Response
 */
export interface Tailoring200Response {
    /**
     * 
     * @type {Tailoring200ResponseData}
     * @memberof Tailoring200Response
     */
    'data'?: Tailoring200ResponseData;
}
/**
 * 
 * @export
 * @interface Tailoring200ResponseData
 */
export interface Tailoring200ResponseData {
    /**
     * 
     * @type {Tailoring}
     * @memberof Tailoring200ResponseData
     */
    'schema'?: Tailoring;
}
/**
 * Defines customizations of rules and variables for a set of profile
 * @export
 * @interface TailoringFile
 */
export interface TailoringFile {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof TailoringFile
     */
    'profiles'?: any;
}
/**
 * 
 * @export
 * @interface Tailorings200Response
 */
export interface Tailorings200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof Tailorings200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof Tailorings200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof Tailorings200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface ValueDefinition
 */
export interface ValueDefinition {
    /**
     * 
     * @type {any}
     * @memberof ValueDefinition
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ValueDefinition
     */
    'type'?: ValueDefinitionTypeEnum;
    /**
     * Identificator of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'ref_id'?: any;
    /**
     * Short title of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'title'?: any;
    /**
     * Type of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'value_type'?: any;
    /**
     * Longer description of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'description'?: any;
    /**
     * Default value of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'default_value'?: any;
}

export const ValueDefinitionTypeEnum = {
    ValueDefinition: 'value_definition'
} as const;

export type ValueDefinitionTypeEnum = typeof ValueDefinitionTypeEnum[keyof typeof ValueDefinitionTypeEnum];

/**
 * 
 * @export
 * @interface ValueDefinition200Response
 */
export interface ValueDefinition200Response {
    /**
     * 
     * @type {ValueDefinition200ResponseData}
     * @memberof ValueDefinition200Response
     */
    'data'?: ValueDefinition200ResponseData;
}
/**
 * 
 * @export
 * @interface ValueDefinition200ResponseData
 */
export interface ValueDefinition200ResponseData {
    /**
     * 
     * @type {ValueDefinition}
     * @memberof ValueDefinition200ResponseData
     */
    'schema'?: ValueDefinition;
}
/**
 * 
 * @export
 * @interface ValueDefinitions200Response
 */
export interface ValueDefinitions200Response {
    /**
     * 
     * @type {Metadata}
     * @memberof ValueDefinitions200Response
     */
    'meta'?: Metadata;
    /**
     * 
     * @type {Links}
     * @memberof ValueDefinitions200Response
     */
    'links'?: Links;
    /**
     * 
     * @type {any}
     * @memberof ValueDefinitions200Response
     */
    'data'?: any;
}

/**
 * AssignRuleApi - axios parameter creator
 * @export
 */
export const AssignRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRule: async (policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignRule', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('assignRule', 'tailoringId', tailoringId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignRule', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssignRuleApi - functional programming interface
 * @export
 */
export const AssignRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssignRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRule(policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRule(policyId, tailoringId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssignRuleApi - factory interface
 * @export
 */
export const AssignRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssignRuleApiFp(configuration)
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {AssignRuleApiAssignRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRule(requestParameters: AssignRuleApiAssignRuleRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.assignRule(requestParameters.policyId, requestParameters.tailoringId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for assignRule operation in AssignRuleApi.
 * @export
 * @interface AssignRuleApiAssignRuleRequest
 */
export interface AssignRuleApiAssignRuleRequest {
    /**
     * 
     * @type {any}
     * @memberof AssignRuleApiAssignRule
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof AssignRuleApiAssignRule
     */
    readonly tailoringId: any

    /**
     * 
     * @type {any}
     * @memberof AssignRuleApiAssignRule
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof AssignRuleApiAssignRule
     */
    readonly xRHIDENTITY?: any
}

/**
 * AssignRuleApi - object-oriented interface
 * @export
 * @class AssignRuleApi
 * @extends {BaseAPI}
 */
export class AssignRuleApi extends BaseAPI {
    /**
     * Assigns a Rule to a Tailoring
     * @summary Assign a Rule to a Tailoring
     * @param {AssignRuleApiAssignRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignRuleApi
     */
    public assignRule(requestParameters: AssignRuleApiAssignRuleRequest, options?: AxiosRequestConfig) {
        return AssignRuleApiFp(this.configuration).assignRule(requestParameters.policyId, requestParameters.tailoringId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssignRulesApi - axios parameter creator
 * @export
 */
export const AssignRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {AssignRulesRequest} [assignRulesRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignRules: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignRules', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('assignRules', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssignRulesApi - functional programming interface
 * @export
 */
export const AssignRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssignRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {AssignRulesRequest} [assignRulesRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRules(policyId, tailoringId, xRHIDENTITY, assignRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssignRulesApi - factory interface
 * @export
 */
export const AssignRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssignRulesApiFp(configuration)
    return {
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {AssignRulesApiAssignRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignRules(requestParameters: AssignRulesApiAssignRulesRequest, options?: AxiosRequestConfig): AxiosPromise<Rules200Response> {
            return localVarFp.assignRules(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.assignRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for assignRules operation in AssignRulesApi.
 * @export
 * @interface AssignRulesApiAssignRulesRequest
 */
export interface AssignRulesApiAssignRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof AssignRulesApiAssignRule
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof AssignRulesApiAssignRule
     */
    readonly tailoringId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof AssignRulesApiAssignRule
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {AssignRulesRequest}
     * @memberof AssignRulesApiAssignRule
     */
    readonly assignRulesRequest?: AssignRulesRequest
}

/**
 * AssignRulesApi - object-oriented interface
 * @export
 * @class AssignRulesApi
 * @extends {BaseAPI}
 */
export class AssignRulesApi extends BaseAPI {
    /**
     * This feature is exclusively used by the frontend
     * @summary Bulk assign Rules to a Tailoring
     * @param {AssignRulesApiAssignRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AssignRulesApi
     */
    public assignRules(requestParameters: AssignRulesApiAssignRulesRequest, options?: AxiosRequestConfig) {
        return AssignRulesApiFp(this.configuration).assignRules(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.assignRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssignSystemApi - axios parameter creator
 * @export
 */
export const AssignSystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {any} id 
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignSystem: async (id: any, policyId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignSystem', 'id', id)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignSystem', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssignSystemApi - functional programming interface
 * @export
 */
export const AssignSystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssignSystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {any} id 
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignSystem(id: any, policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignSystem(id, policyId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssignSystemApi - factory interface
 * @export
 */
export const AssignSystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssignSystemApiFp(configuration)
    return {
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {AssignSystemApiAssignSystemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignSystem(requestParameters: AssignSystemApiAssignSystemRequest, options?: AxiosRequestConfig): AxiosPromise<System200Response> {
            return localVarFp.assignSystem(requestParameters.id, requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for assignSystem operation in AssignSystemApi.
 * @export
 * @interface AssignSystemApiAssignSystemRequest
 */
export interface AssignSystemApiAssignSystemRequest {
    /**
     * 
     * @type {any}
     * @memberof AssignSystemApiAssignSystem
     */
    readonly id: any

    /**
     * 
     * @type {any}
     * @memberof AssignSystemApiAssignSystem
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof AssignSystemApiAssignSystem
     */
    readonly xRHIDENTITY?: any
}

/**
 * AssignSystemApi - object-oriented interface
 * @export
 * @class AssignSystemApi
 * @extends {BaseAPI}
 */
export class AssignSystemApi extends BaseAPI {
    /**
     * Assigns a System to a Policy
     * @summary Assign a System to a Policy
     * @param {AssignSystemApiAssignSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignSystemApi
     */
    public assignSystem(requestParameters: AssignSystemApiAssignSystemRequest, options?: AxiosRequestConfig) {
        return AssignSystemApiFp(this.configuration).assignSystem(requestParameters.id, requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssignSystemsApi - axios parameter creator
 * @export
 */
export const AssignSystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {AssignRulesRequest} [assignRulesRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignSystems: async (policyId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignSystems', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssignSystemsApi - functional programming interface
 * @export
 */
export const AssignSystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssignSystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {AssignRulesRequest} [assignRulesRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignSystems(policyId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignSystems(policyId, xRHIDENTITY, assignRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssignSystemsApi - factory interface
 * @export
 */
export const AssignSystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssignSystemsApiFp(configuration)
    return {
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {AssignSystemsApiAssignSystemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignSystems(requestParameters: AssignSystemsApiAssignSystemsRequest, options?: AxiosRequestConfig): AxiosPromise<Systems200Response> {
            return localVarFp.assignSystems(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.assignRulesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for assignSystems operation in AssignSystemsApi.
 * @export
 * @interface AssignSystemsApiAssignSystemsRequest
 */
export interface AssignSystemsApiAssignSystemsRequest {
    /**
     * 
     * @type {any}
     * @memberof AssignSystemsApiAssignSystem
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof AssignSystemsApiAssignSystem
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {AssignRulesRequest}
     * @memberof AssignSystemsApiAssignSystem
     */
    readonly assignRulesRequest?: AssignRulesRequest
}

/**
 * AssignSystemsApi - object-oriented interface
 * @export
 * @class AssignSystemsApi
 * @extends {BaseAPI}
 */
export class AssignSystemsApi extends BaseAPI {
    /**
     * This feature is exclusively used by the frontend
     * @summary Bulk assign Systems to a Policy
     * @param {AssignSystemsApiAssignSystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AssignSystemsApi
     */
    public assignSystems(requestParameters: AssignSystemsApiAssignSystemsRequest, options?: AxiosRequestConfig) {
        return AssignSystemsApiFp(this.configuration).assignSystems(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.assignRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreatePolicyApi - axios parameter creator
 * @export
 */
export const CreatePolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Policy with the provided attribute
         * @summary Create a Policy
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {Policy} [policy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (xRHIDENTITY?: any, policy?: Policy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreatePolicyApi - functional programming interface
 * @export
 */
export const CreatePolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreatePolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Policy with the provided attribute
         * @summary Create a Policy
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {Policy} [policy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(xRHIDENTITY?: any, policy?: Policy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(xRHIDENTITY, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreatePolicyApi - factory interface
 * @export
 */
export const CreatePolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreatePolicyApiFp(configuration)
    return {
        /**
         * Create a Policy with the provided attribute
         * @summary Create a Policy
         * @param {CreatePolicyApiCreatePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(requestParameters: CreatePolicyApiCreatePolicyRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.createPolicy(requestParameters.xRHIDENTITY, requestParameters.policy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPolicy operation in CreatePolicyApi.
 * @export
 * @interface CreatePolicyApiCreatePolicyRequest
 */
export interface CreatePolicyApiCreatePolicyRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof CreatePolicyApiCreatePolicy
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {Policy}
     * @memberof CreatePolicyApiCreatePolicy
     */
    readonly policy?: Policy
}

/**
 * CreatePolicyApi - object-oriented interface
 * @export
 * @class CreatePolicyApi
 * @extends {BaseAPI}
 */
export class CreatePolicyApi extends BaseAPI {
    /**
     * Create a Policy with the provided attribute
     * @summary Create a Policy
     * @param {CreatePolicyApiCreatePolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreatePolicyApi
     */
    public createPolicy(requestParameters: CreatePolicyApiCreatePolicyRequest = {}, options?: AxiosRequestConfig) {
        return CreatePolicyApiFp(this.configuration).createPolicy(requestParameters.xRHIDENTITY, requestParameters.policy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeletePolicyApi - axios parameter creator
 * @export
 */
export const DeletePolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeletePolicyApi - functional programming interface
 * @export
 */
export const DeletePolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeletePolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeletePolicyApi - factory interface
 * @export
 */
export const DeletePolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeletePolicyApiFp(configuration)
    return {
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {DeletePolicyApiDeletePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(requestParameters: DeletePolicyApiDeletePolicyRequest, options?: AxiosRequestConfig): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.deletePolicy(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deletePolicy operation in DeletePolicyApi.
 * @export
 * @interface DeletePolicyApiDeletePolicyRequest
 */
export interface DeletePolicyApiDeletePolicyRequest {
    /**
     * 
     * @type {any}
     * @memberof DeletePolicyApiDeletePolicy
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof DeletePolicyApiDeletePolicy
     */
    readonly xRHIDENTITY?: any
}

/**
 * DeletePolicyApi - object-oriented interface
 * @export
 * @class DeletePolicyApi
 * @extends {BaseAPI}
 */
export class DeletePolicyApi extends BaseAPI {
    /**
     * Deletes a Policy
     * @summary Delete a Policy
     * @param {DeletePolicyApiDeletePolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletePolicyApi
     */
    public deletePolicy(requestParameters: DeletePolicyApiDeletePolicyRequest, options?: AxiosRequestConfig) {
        return DeletePolicyApiFp(this.configuration).deletePolicy(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Policie
         * @summary Request Policie
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policies: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Policie
         * @summary Request Policie
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policies(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policies(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Lists Policie
         * @summary Request Policie
         * @param {PoliciesApiPoliciesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policies(requestParameters: PoliciesApiPoliciesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Policies200Response> {
            return localVarFp.policies(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for policies operation in PoliciesApi.
 * @export
 * @interface PoliciesApiPoliciesRequest
 */
export interface PoliciesApiPoliciesRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof PoliciesApiPolicie
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof PoliciesApiPolicie
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof PoliciesApiPolicie
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof PoliciesApiPolicie
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof PoliciesApiPolicie
     */
    readonly filter?: any
}

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Lists Policie
     * @summary Request Policie
     * @param {PoliciesApiPoliciesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policies(requestParameters: PoliciesApiPoliciesRequest = {}, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policies(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PolicyApi - axios parameter creator
 * @export
 */
export const PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policy: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyApi - functional programming interface
 * @export
 */
export const PolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policy(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policy(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolicyApi - factory interface
 * @export
 */
export const PolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyApiFp(configuration)
    return {
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {PolicyApiPolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policy(requestParameters: PolicyApiPolicyRequest, options?: AxiosRequestConfig): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.policy(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for policy operation in PolicyApi.
 * @export
 * @interface PolicyApiPolicyRequest
 */
export interface PolicyApiPolicyRequest {
    /**
     * 
     * @type {any}
     * @memberof PolicyApiPolicy
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PolicyApiPolicy
     */
    readonly xRHIDENTITY?: any
}

/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
export class PolicyApi extends BaseAPI {
    /**
     * Returns a Policy
     * @summary Request a Policy
     * @param {PolicyApiPolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public policy(requestParameters: PolicyApiPolicyRequest, options?: AxiosRequestConfig) {
        return PolicyApiFp(this.configuration).policy(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PolicySystemsApi - axios parameter creator
 * @export
 */
export const PolicySystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policySystems: async (policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policySystems', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicySystemsApi - functional programming interface
 * @export
 */
export const PolicySystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicySystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policySystems(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policySystems(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolicySystemsApi - factory interface
 * @export
 */
export const PolicySystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicySystemsApiFp(configuration)
    return {
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {PolicySystemsApiPolicySystemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policySystems(requestParameters: PolicySystemsApiPolicySystemsRequest, options?: AxiosRequestConfig): AxiosPromise<Systems200Response> {
            return localVarFp.policySystems(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for policySystems operation in PolicySystemsApi.
 * @export
 * @interface PolicySystemsApiPolicySystemsRequest
 */
export interface PolicySystemsApiPolicySystemsRequest {
    /**
     * 
     * @type {any}
     * @memberof PolicySystemsApiPolicySystem
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof PolicySystemsApiPolicySystem
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof PolicySystemsApiPolicySystem
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof PolicySystemsApiPolicySystem
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof PolicySystemsApiPolicySystem
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof PolicySystemsApiPolicySystem
     */
    readonly filter?: any
}

/**
 * PolicySystemsApi - object-oriented interface
 * @export
 * @class PolicySystemsApi
 * @extends {BaseAPI}
 */
export class PolicySystemsApi extends BaseAPI {
    /**
     * Lists Systems assigned to a Policy
     * @summary Request Systems assigned to a Policy
     * @param {PolicySystemsApiPolicySystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicySystemsApi
     */
    public policySystems(requestParameters: PolicySystemsApiPolicySystemsRequest, options?: AxiosRequestConfig) {
        return PolicySystemsApiFp(this.configuration).policySystems(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {any} securityGuideId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile: async (securityGuideId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profile', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profile', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {any} securityGuideId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profile(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profile(securityGuideId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {ProfileApiProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile(requestParameters: ProfileApiProfileRequest, options?: AxiosRequestConfig): AxiosPromise<Profile200Response> {
            return localVarFp.profile(requestParameters.securityGuideId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profile operation in ProfileApi.
 * @export
 * @interface ProfileApiProfileRequest
 */
export interface ProfileApiProfileRequest {
    /**
     * 
     * @type {any}
     * @memberof ProfileApiProfile
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof ProfileApiProfile
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ProfileApiProfile
     */
    readonly xRHIDENTITY?: any
}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Returns a Profile
     * @summary Request a Profile
     * @param {ProfileApiProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profile(requestParameters: ProfileApiProfileRequest, options?: AxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profile(requestParameters.securityGuideId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileRuleApi - axios parameter creator
 * @export
 */
export const ProfileRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRule: async (securityGuideId: any, profileId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profileRule', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profileRule', 'profileId', profileId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profileRule', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}/rules/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileRuleApi - functional programming interface
 * @export
 */
export const ProfileRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileRule(securityGuideId: any, profileId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileRule(securityGuideId, profileId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileRuleApi - factory interface
 * @export
 */
export const ProfileRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileRuleApiFp(configuration)
    return {
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {ProfileRuleApiProfileRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRule(requestParameters: ProfileRuleApiProfileRuleRequest, options?: AxiosRequestConfig): AxiosPromise<Rule200Response> {
            return localVarFp.profileRule(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profileRule operation in ProfileRuleApi.
 * @export
 * @interface ProfileRuleApiProfileRuleRequest
 */
export interface ProfileRuleApiProfileRuleRequest {
    /**
     * 
     * @type {any}
     * @memberof ProfileRuleApiProfileRule
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof ProfileRuleApiProfileRule
     */
    readonly profileId: any

    /**
     * 
     * @type {any}
     * @memberof ProfileRuleApiProfileRule
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ProfileRuleApiProfileRule
     */
    readonly xRHIDENTITY?: any
}

/**
 * ProfileRuleApi - object-oriented interface
 * @export
 * @class ProfileRuleApi
 * @extends {BaseAPI}
 */
export class ProfileRuleApi extends BaseAPI {
    /**
     * Returns a Rule assigned to a Profile
     * @summary Request a Rule assigned to a Profile
     * @param {ProfileRuleApiProfileRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileRuleApi
     */
    public profileRule(requestParameters: ProfileRuleApiProfileRuleRequest, options?: AxiosRequestConfig) {
        return ProfileRuleApiFp(this.configuration).profileRule(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileRulesApi - axios parameter creator
 * @export
 */
export const ProfileRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRules: async (securityGuideId: any, profileId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profileRules', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profileRules', 'profileId', profileId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}/rules`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileRulesApi - functional programming interface
 * @export
 */
export const ProfileRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {any} securityGuideId 
         * @param {any} profileId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileRules(securityGuideId: any, profileId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileRules(securityGuideId, profileId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileRulesApi - factory interface
 * @export
 */
export const ProfileRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileRulesApiFp(configuration)
    return {
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {ProfileRulesApiProfileRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRules(requestParameters: ProfileRulesApiProfileRulesRequest, options?: AxiosRequestConfig): AxiosPromise<Rules200Response> {
            return localVarFp.profileRules(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profileRules operation in ProfileRulesApi.
 * @export
 * @interface ProfileRulesApiProfileRulesRequest
 */
export interface ProfileRulesApiProfileRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof ProfileRulesApiProfileRule
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof ProfileRulesApiProfileRule
     */
    readonly profileId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ProfileRulesApiProfileRule
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ProfileRulesApiProfileRule
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ProfileRulesApiProfileRule
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ProfileRulesApiProfileRule
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ProfileRulesApiProfileRule
     */
    readonly filter?: any
}

/**
 * ProfileRulesApi - object-oriented interface
 * @export
 * @class ProfileRulesApi
 * @extends {BaseAPI}
 */
export class ProfileRulesApi extends BaseAPI {
    /**
     * Lists Rules assigned to a Profile
     * @summary Request Rules assigned to a Profile
     * @param {ProfileRulesApiProfileRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileRulesApi
     */
    public profileRules(requestParameters: ProfileRulesApiProfileRulesRequest, options?: AxiosRequestConfig) {
        return ProfileRulesApiFp(this.configuration).profileRules(requestParameters.securityGuideId, requestParameters.profileId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Profile
         * @summary Request Profile
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profiles: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profiles', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Profile
         * @summary Request Profile
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profiles(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profiles(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * Lists Profile
         * @summary Request Profile
         * @param {ProfilesApiProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profiles(requestParameters: ProfilesApiProfilesRequest, options?: AxiosRequestConfig): AxiosPromise<Profiles200Response> {
            return localVarFp.profiles(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profiles operation in ProfilesApi.
 * @export
 * @interface ProfilesApiProfilesRequest
 */
export interface ProfilesApiProfilesRequest {
    /**
     * 
     * @type {any}
     * @memberof ProfilesApiProfile
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ProfilesApiProfile
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ProfilesApiProfile
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ProfilesApiProfile
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ProfilesApiProfile
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ProfilesApiProfile
     */
    readonly filter?: any
}

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * Lists Profile
     * @summary Request Profile
     * @param {ProfilesApiProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profiles(requestParameters: ProfilesApiProfilesRequest, options?: AxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profiles(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportApi - axios parameter creator
 * @export
 */
export const ReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Report
         * @summary Request a Report
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('report', 'id', id)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Report
         * @summary Request a Report
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async report(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.report(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportApiFp(configuration)
    return {
        /**
         * Returns a Report
         * @summary Request a Report
         * @param {ReportApiReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        report(requestParameters: ReportApiReportRequest, options?: AxiosRequestConfig): AxiosPromise<Report200Response> {
            return localVarFp.report(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for report operation in ReportApi.
 * @export
 * @interface ReportApiReportRequest
 */
export interface ReportApiReportRequest {
    /**
     * 
     * @type {any}
     * @memberof ReportApiReport
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ReportApiReport
     */
    readonly xRHIDENTITY?: any
}

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
    /**
     * Returns a Report
     * @summary Request a Report
     * @param {ReportApiReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public report(requestParameters: ReportApiReportRequest, options?: AxiosRequestConfig) {
        return ReportApiFp(this.configuration).report(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Report
         * @summary Request Report
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Reports are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reports: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Report
         * @summary Request Report
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Reports are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reports(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reports200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reports(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * Lists Report
         * @summary Request Report
         * @param {ReportsApiReportsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reports(requestParameters: ReportsApiReportsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Reports200Response> {
            return localVarFp.reports(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reports operation in ReportsApi.
 * @export
 * @interface ReportsApiReportsRequest
 */
export interface ReportsApiReportsRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof ReportsApiReport
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ReportsApiReport
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ReportsApiReport
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ReportsApiReport
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Reports are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ReportsApiReport
     */
    readonly filter?: any
}

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Lists Report
     * @summary Request Report
     * @param {ReportsApiReportsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reports(requestParameters: ReportsApiReportsRequest = {}, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reports(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuleApi - axios parameter creator
 * @export
 */
export const RuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {any} securityGuideId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rule: async (securityGuideId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('rule', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rule', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/rules/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleApi - functional programming interface
 * @export
 */
export const RuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {any} securityGuideId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rule(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rule(securityGuideId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuleApi - factory interface
 * @export
 */
export const RuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuleApiFp(configuration)
    return {
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {RuleApiRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rule(requestParameters: RuleApiRuleRequest, options?: AxiosRequestConfig): AxiosPromise<Rule200Response> {
            return localVarFp.rule(requestParameters.securityGuideId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for rule operation in RuleApi.
 * @export
 * @interface RuleApiRuleRequest
 */
export interface RuleApiRuleRequest {
    /**
     * 
     * @type {any}
     * @memberof RuleApiRule
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof RuleApiRule
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof RuleApiRule
     */
    readonly xRHIDENTITY?: any
}

/**
 * RuleApi - object-oriented interface
 * @export
 * @class RuleApi
 * @extends {BaseAPI}
 */
export class RuleApi extends BaseAPI {
    /**
     * Returns a Rule
     * @summary Request a Rule
     * @param {RuleApiRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public rule(requestParameters: RuleApiRuleRequest, options?: AxiosRequestConfig) {
        return RuleApiFp(this.configuration).rule(requestParameters.securityGuideId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuleGroupApi - axios parameter creator
 * @export
 */
export const RuleGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {any} securityGuideId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroup: async (securityGuideId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('ruleGroup', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleGroup', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/rule_groups/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleGroupApi - functional programming interface
 * @export
 */
export const RuleGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuleGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {any} securityGuideId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleGroup(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleGroup(securityGuideId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuleGroupApi - factory interface
 * @export
 */
export const RuleGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuleGroupApiFp(configuration)
    return {
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {RuleGroupApiRuleGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroup(requestParameters: RuleGroupApiRuleGroupRequest, options?: AxiosRequestConfig): AxiosPromise<RuleGroup200Response> {
            return localVarFp.ruleGroup(requestParameters.securityGuideId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ruleGroup operation in RuleGroupApi.
 * @export
 * @interface RuleGroupApiRuleGroupRequest
 */
export interface RuleGroupApiRuleGroupRequest {
    /**
     * 
     * @type {any}
     * @memberof RuleGroupApiRuleGroup
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof RuleGroupApiRuleGroup
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof RuleGroupApiRuleGroup
     */
    readonly xRHIDENTITY?: any
}

/**
 * RuleGroupApi - object-oriented interface
 * @export
 * @class RuleGroupApi
 * @extends {BaseAPI}
 */
export class RuleGroupApi extends BaseAPI {
    /**
     * Returns a Rule Group
     * @summary Request a Rule Group
     * @param {RuleGroupApiRuleGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupApi
     */
    public ruleGroup(requestParameters: RuleGroupApiRuleGroupRequest, options?: AxiosRequestConfig) {
        return RuleGroupApiFp(this.configuration).ruleGroup(requestParameters.securityGuideId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuleGroupsApi - axios parameter creator
 * @export
 */
export const RuleGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Rule Group
         * @summary Request Rule Group
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroups: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('ruleGroups', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rule_groups`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleGroupsApi - functional programming interface
 * @export
 */
export const RuleGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuleGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Rule Group
         * @summary Request Rule Group
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleGroups(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleGroups(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuleGroupsApi - factory interface
 * @export
 */
export const RuleGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuleGroupsApiFp(configuration)
    return {
        /**
         * Lists Rule Group
         * @summary Request Rule Group
         * @param {RuleGroupsApiRuleGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroups(requestParameters: RuleGroupsApiRuleGroupsRequest, options?: AxiosRequestConfig): AxiosPromise<RuleGroups200Response> {
            return localVarFp.ruleGroups(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ruleGroups operation in RuleGroupsApi.
 * @export
 * @interface RuleGroupsApiRuleGroupsRequest
 */
export interface RuleGroupsApiRuleGroupsRequest {
    /**
     * 
     * @type {any}
     * @memberof RuleGroupsApiRuleGroup
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof RuleGroupsApiRuleGroup
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof RuleGroupsApiRuleGroup
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof RuleGroupsApiRuleGroup
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof RuleGroupsApiRuleGroup
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof RuleGroupsApiRuleGroup
     */
    readonly filter?: any
}

/**
 * RuleGroupsApi - object-oriented interface
 * @export
 * @class RuleGroupsApi
 * @extends {BaseAPI}
 */
export class RuleGroupsApi extends BaseAPI {
    /**
     * Lists Rule Group
     * @summary Request Rule Group
     * @param {RuleGroupsApiRuleGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleGroupsApi
     */
    public ruleGroups(requestParameters: RuleGroupsApiRuleGroupsRequest, options?: AxiosRequestConfig) {
        return RuleGroupsApiFp(this.configuration).ruleGroups(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Rules assigned
         * @summary Request Rule
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rules: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('rules', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rules`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Rules assigned
         * @summary Request Rule
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rules(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rules(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Lists Rules assigned
         * @summary Request Rule
         * @param {RulesApiRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rules(requestParameters: RulesApiRulesRequest, options?: AxiosRequestConfig): AxiosPromise<Rules200Response> {
            return localVarFp.rules(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for rules operation in RulesApi.
 * @export
 * @interface RulesApiRulesRequest
 */
export interface RulesApiRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof RulesApiRule
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof RulesApiRule
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof RulesApiRule
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof RulesApiRule
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof RulesApiRule
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof RulesApiRule
     */
    readonly filter?: any
}

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * Lists Rules assigned
     * @summary Request Rule
     * @param {RulesApiRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public rules(requestParameters: RulesApiRulesRequest, options?: AxiosRequestConfig) {
        return RulesApiFp(this.configuration).rules(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityGuideApi - axios parameter creator
 * @export
 */
export const SecurityGuideApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuide: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGuide', 'id', id)
            const localVarPath = `/security_guides/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityGuideApi - functional programming interface
 * @export
 */
export const SecurityGuideApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityGuideApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuide(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGuide200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuide(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityGuideApi - factory interface
 * @export
 */
export const SecurityGuideApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityGuideApiFp(configuration)
    return {
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {SecurityGuideApiSecurityGuideRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuide(requestParameters: SecurityGuideApiSecurityGuideRequest, options?: AxiosRequestConfig): AxiosPromise<SecurityGuide200Response> {
            return localVarFp.securityGuide(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for securityGuide operation in SecurityGuideApi.
 * @export
 * @interface SecurityGuideApiSecurityGuideRequest
 */
export interface SecurityGuideApiSecurityGuideRequest {
    /**
     * 
     * @type {any}
     * @memberof SecurityGuideApiSecurityGuide
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof SecurityGuideApiSecurityGuide
     */
    readonly xRHIDENTITY?: any
}

/**
 * SecurityGuideApi - object-oriented interface
 * @export
 * @class SecurityGuideApi
 * @extends {BaseAPI}
 */
export class SecurityGuideApi extends BaseAPI {
    /**
     * Returns a Security Guide
     * @summary Request a Security Guide
     * @param {SecurityGuideApiSecurityGuideRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGuideApi
     */
    public securityGuide(requestParameters: SecurityGuideApiSecurityGuideRequest, options?: AxiosRequestConfig) {
        return SecurityGuideApiFp(this.configuration).securityGuide(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityGuideRuleTreeApi - axios parameter creator
 * @export
 */
export const SecurityGuideRuleTreeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuideRuleTree: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGuideRuleTree', 'id', id)
            const localVarPath = `/security_guides/{id}/rule_tree`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityGuideRuleTreeApi - functional programming interface
 * @export
 */
export const SecurityGuideRuleTreeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityGuideRuleTreeApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuideRuleTree(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuideRuleTree(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityGuideRuleTreeApi - factory interface
 * @export
 */
export const SecurityGuideRuleTreeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityGuideRuleTreeApiFp(configuration)
    return {
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {SecurityGuideRuleTreeApiSecurityGuideRuleTreeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuideRuleTree(requestParameters: SecurityGuideRuleTreeApiSecurityGuideRuleTreeRequest, options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.securityGuideRuleTree(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for securityGuideRuleTree operation in SecurityGuideRuleTreeApi.
 * @export
 * @interface SecurityGuideRuleTreeApiSecurityGuideRuleTreeRequest
 */
export interface SecurityGuideRuleTreeApiSecurityGuideRuleTreeRequest {
    /**
     * 
     * @type {any}
     * @memberof SecurityGuideRuleTreeApiSecurityGuideRuleTree
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof SecurityGuideRuleTreeApiSecurityGuideRuleTree
     */
    readonly xRHIDENTITY?: any
}

/**
 * SecurityGuideRuleTreeApi - object-oriented interface
 * @export
 * @class SecurityGuideRuleTreeApi
 * @extends {BaseAPI}
 */
export class SecurityGuideRuleTreeApi extends BaseAPI {
    /**
     * Returns the Rule Tree of a Security Guide
     * @summary Request the Rule Tree of a Security Guide
     * @param {SecurityGuideRuleTreeApiSecurityGuideRuleTreeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGuideRuleTreeApi
     */
    public securityGuideRuleTree(requestParameters: SecurityGuideRuleTreeApiSecurityGuideRuleTreeRequest, options?: AxiosRequestConfig) {
        return SecurityGuideRuleTreeApiFp(this.configuration).securityGuideRuleTree(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityGuidesApi - axios parameter creator
 * @export
 */
export const SecurityGuidesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Security Guide
         * @summary Request Security Guide
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuides: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_guides`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityGuidesApi - functional programming interface
 * @export
 */
export const SecurityGuidesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityGuidesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Security Guide
         * @summary Request Security Guide
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuides(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGuides200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuides(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityGuidesApi - factory interface
 * @export
 */
export const SecurityGuidesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityGuidesApiFp(configuration)
    return {
        /**
         * Lists Security Guide
         * @summary Request Security Guide
         * @param {SecurityGuidesApiSecurityGuidesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuides(requestParameters: SecurityGuidesApiSecurityGuidesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SecurityGuides200Response> {
            return localVarFp.securityGuides(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for securityGuides operation in SecurityGuidesApi.
 * @export
 * @interface SecurityGuidesApiSecurityGuidesRequest
 */
export interface SecurityGuidesApiSecurityGuidesRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof SecurityGuidesApiSecurityGuide
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof SecurityGuidesApiSecurityGuide
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof SecurityGuidesApiSecurityGuide
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof SecurityGuidesApiSecurityGuide
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof SecurityGuidesApiSecurityGuide
     */
    readonly filter?: any
}

/**
 * SecurityGuidesApi - object-oriented interface
 * @export
 * @class SecurityGuidesApi
 * @extends {BaseAPI}
 */
export class SecurityGuidesApi extends BaseAPI {
    /**
     * Lists Security Guide
     * @summary Request Security Guide
     * @param {SecurityGuidesApiSecurityGuidesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGuidesApi
     */
    public securityGuides(requestParameters: SecurityGuidesApiSecurityGuidesRequest = {}, options?: AxiosRequestConfig) {
        return SecurityGuidesApiFp(this.configuration).securityGuides(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SupportedProfilesApi - axios parameter creator
 * @export
 */
export const SupportedProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Supported Profile
         * @summary Request Supported Profile
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedProfiles: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_guides/supported_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportedProfilesApi - functional programming interface
 * @export
 */
export const SupportedProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupportedProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Supported Profile
         * @summary Request Supported Profile
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportedProfiles(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportedProfiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportedProfiles(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SupportedProfilesApi - factory interface
 * @export
 */
export const SupportedProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupportedProfilesApiFp(configuration)
    return {
        /**
         * Lists Supported Profile
         * @summary Request Supported Profile
         * @param {SupportedProfilesApiSupportedProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedProfiles(requestParameters: SupportedProfilesApiSupportedProfilesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SupportedProfiles200Response> {
            return localVarFp.supportedProfiles(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for supportedProfiles operation in SupportedProfilesApi.
 * @export
 * @interface SupportedProfilesApiSupportedProfilesRequest
 */
export interface SupportedProfilesApiSupportedProfilesRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof SupportedProfilesApiSupportedProfile
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof SupportedProfilesApiSupportedProfile
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof SupportedProfilesApiSupportedProfile
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof SupportedProfilesApiSupportedProfile
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof SupportedProfilesApiSupportedProfile
     */
    readonly filter?: any
}

/**
 * SupportedProfilesApi - object-oriented interface
 * @export
 * @class SupportedProfilesApi
 * @extends {BaseAPI}
 */
export class SupportedProfilesApi extends BaseAPI {
    /**
     * Lists Supported Profile
     * @summary Request Supported Profile
     * @param {SupportedProfilesApiSupportedProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportedProfilesApi
     */
    public supportedProfiles(requestParameters: SupportedProfilesApiSupportedProfilesRequest = {}, options?: AxiosRequestConfig) {
        return SupportedProfilesApiFp(this.configuration).supportedProfiles(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        system: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('system', 'id', id)
            const localVarPath = `/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async system(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.system(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {SystemApiSystemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        system(requestParameters: SystemApiSystemRequest, options?: AxiosRequestConfig): AxiosPromise<System200Response> {
            return localVarFp.system(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for system operation in SystemApi.
 * @export
 * @interface SystemApiSystemRequest
 */
export interface SystemApiSystemRequest {
    /**
     * 
     * @type {any}
     * @memberof SystemApiSystem
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof SystemApiSystem
     */
    readonly xRHIDENTITY?: any
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Returns a System
     * @summary Request a System
     * @param {SystemApiSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public system(requestParameters: SystemApiSystemRequest, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).system(requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists System
         * @summary Request System
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systems: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists System
         * @summary Request System
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systems(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systems(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Lists System
         * @summary Request System
         * @param {SystemsApiSystemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systems(requestParameters: SystemsApiSystemsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Systems200Response> {
            return localVarFp.systems(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for systems operation in SystemsApi.
 * @export
 * @interface SystemsApiSystemsRequest
 */
export interface SystemsApiSystemsRequest {
    /**
     * For internal use only
     * @type {any}
     * @memberof SystemsApiSystem
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof SystemsApiSystem
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof SystemsApiSystem
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof SystemsApiSystem
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, &#x60;os_minor_version&#x60;, and &#x60;assigned_or_scanned&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof SystemsApiSystem
     */
    readonly filter?: any
}

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Lists System
     * @summary Request System
     * @param {SystemsApiSystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systems(requestParameters: SystemsApiSystemsRequest = {}, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).systems(requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemsPoliciesApi - axios parameter creator
 * @export
 */
export const SystemsPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {any} systemId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemsPolicies: async (systemId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('systemsPolicies', 'systemId', systemId)
            const localVarPath = `/systems/{system_id}/policies`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsPoliciesApi - functional programming interface
 * @export
 */
export const SystemsPoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsPoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {any} systemId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemsPolicies(systemId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemsPolicies(systemId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemsPoliciesApi - factory interface
 * @export
 */
export const SystemsPoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsPoliciesApiFp(configuration)
    return {
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {SystemsPoliciesApiSystemsPoliciesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemsPolicies(requestParameters: SystemsPoliciesApiSystemsPoliciesRequest, options?: AxiosRequestConfig): AxiosPromise<Policies200Response> {
            return localVarFp.systemsPolicies(requestParameters.systemId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for systemsPolicies operation in SystemsPoliciesApi.
 * @export
 * @interface SystemsPoliciesApiSystemsPoliciesRequest
 */
export interface SystemsPoliciesApiSystemsPoliciesRequest {
    /**
     * 
     * @type {any}
     * @memberof SystemsPoliciesApiSystemsPolicie
     */
    readonly systemId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof SystemsPoliciesApiSystemsPolicie
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof SystemsPoliciesApiSystemsPolicie
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof SystemsPoliciesApiSystemsPolicie
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof SystemsPoliciesApiSystemsPolicie
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof SystemsPoliciesApiSystemsPolicie
     */
    readonly filter?: any
}

/**
 * SystemsPoliciesApi - object-oriented interface
 * @export
 * @class SystemsPoliciesApi
 * @extends {BaseAPI}
 */
export class SystemsPoliciesApi extends BaseAPI {
    /**
     * Lists Policies under a System
     * @summary Request Policies assigned to a System
     * @param {SystemsPoliciesApiSystemsPoliciesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsPoliciesApi
     */
    public systemsPolicies(requestParameters: SystemsPoliciesApiSystemsPoliciesRequest, options?: AxiosRequestConfig) {
        return SystemsPoliciesApiFp(this.configuration).systemsPolicies(requestParameters.systemId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TailoringApi - axios parameter creator
 * @export
 */
export const TailoringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {any} policyId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoring: async (policyId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoring', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tailoring', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TailoringApi - functional programming interface
 * @export
 */
export const TailoringApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TailoringApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {any} policyId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoring(policyId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailoring200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoring(policyId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TailoringApi - factory interface
 * @export
 */
export const TailoringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TailoringApiFp(configuration)
    return {
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {TailoringApiTailoringRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoring(requestParameters: TailoringApiTailoringRequest, options?: AxiosRequestConfig): AxiosPromise<Tailoring200Response> {
            return localVarFp.tailoring(requestParameters.policyId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tailoring operation in TailoringApi.
 * @export
 * @interface TailoringApiTailoringRequest
 */
export interface TailoringApiTailoringRequest {
    /**
     * 
     * @type {any}
     * @memberof TailoringApiTailoring
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof TailoringApiTailoring
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof TailoringApiTailoring
     */
    readonly xRHIDENTITY?: any
}

/**
 * TailoringApi - object-oriented interface
 * @export
 * @class TailoringApi
 * @extends {BaseAPI}
 */
export class TailoringApi extends BaseAPI {
    /**
     * Returns a Tailoring
     * @summary Request a Tailoring
     * @param {TailoringApiTailoringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TailoringApi
     */
    public tailoring(requestParameters: TailoringApiTailoringRequest, options?: AxiosRequestConfig) {
        return TailoringApiFp(this.configuration).tailoring(requestParameters.policyId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TailoringFileApi - axios parameter creator
 * @export
 */
export const TailoringFileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {any} policyId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringFile: async (policyId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoringFile', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tailoringFile', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{id}/tailoring_file.json`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TailoringFileApi - functional programming interface
 * @export
 */
export const TailoringFileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TailoringFileApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {any} policyId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoringFile(policyId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TailoringFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoringFile(policyId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TailoringFileApi - factory interface
 * @export
 */
export const TailoringFileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TailoringFileApiFp(configuration)
    return {
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {TailoringFileApiTailoringFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringFile(requestParameters: TailoringFileApiTailoringFileRequest, options?: AxiosRequestConfig): AxiosPromise<TailoringFile> {
            return localVarFp.tailoringFile(requestParameters.policyId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tailoringFile operation in TailoringFileApi.
 * @export
 * @interface TailoringFileApiTailoringFileRequest
 */
export interface TailoringFileApiTailoringFileRequest {
    /**
     * 
     * @type {any}
     * @memberof TailoringFileApiTailoringFile
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof TailoringFileApiTailoringFile
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof TailoringFileApiTailoringFile
     */
    readonly xRHIDENTITY?: any
}

/**
 * TailoringFileApi - object-oriented interface
 * @export
 * @class TailoringFileApi
 * @extends {BaseAPI}
 */
export class TailoringFileApi extends BaseAPI {
    /**
     * Returns a Tailoring File
     * @summary Request a Tailoring file
     * @param {TailoringFileApiTailoringFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TailoringFileApi
     */
    public tailoringFile(requestParameters: TailoringFileApiTailoringFileRequest, options?: AxiosRequestConfig) {
        return TailoringFileApiFp(this.configuration).tailoringFile(requestParameters.policyId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TailoringRulesApi - axios parameter creator
 * @export
 */
export const TailoringRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringRules: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoringRules', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('tailoringRules', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TailoringRulesApi - functional programming interface
 * @export
 */
export const TailoringRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TailoringRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoringRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoringRules(policyId, tailoringId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TailoringRulesApi - factory interface
 * @export
 */
export const TailoringRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TailoringRulesApiFp(configuration)
    return {
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {TailoringRulesApiTailoringRulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringRules(requestParameters: TailoringRulesApiTailoringRulesRequest, options?: AxiosRequestConfig): AxiosPromise<Rules200Response> {
            return localVarFp.tailoringRules(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tailoringRules operation in TailoringRulesApi.
 * @export
 * @interface TailoringRulesApiTailoringRulesRequest
 */
export interface TailoringRulesApiTailoringRulesRequest {
    /**
     * 
     * @type {any}
     * @memberof TailoringRulesApiTailoringRule
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof TailoringRulesApiTailoringRule
     */
    readonly tailoringId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof TailoringRulesApiTailoringRule
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof TailoringRulesApiTailoringRule
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof TailoringRulesApiTailoringRule
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof TailoringRulesApiTailoringRule
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof TailoringRulesApiTailoringRule
     */
    readonly filter?: any
}

/**
 * TailoringRulesApi - object-oriented interface
 * @export
 * @class TailoringRulesApi
 * @extends {BaseAPI}
 */
export class TailoringRulesApi extends BaseAPI {
    /**
     * Lists Rules assigned to a Tailoring
     * @summary Request Rules assigned to a Tailoring
     * @param {TailoringRulesApiTailoringRulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TailoringRulesApi
     */
    public tailoringRules(requestParameters: TailoringRulesApiTailoringRulesRequest, options?: AxiosRequestConfig) {
        return TailoringRulesApiFp(this.configuration).tailoringRules(requestParameters.policyId, requestParameters.tailoringId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TailoringsApi - axios parameter creator
 * @export
 */
export const TailoringsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Tailoring
         * @summary Request Tailoring
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailorings: async (policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailorings', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/tailorings`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TailoringsApi - functional programming interface
 * @export
 */
export const TailoringsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TailoringsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Tailoring
         * @summary Request Tailoring
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailorings(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailorings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailorings(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TailoringsApi - factory interface
 * @export
 */
export const TailoringsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TailoringsApiFp(configuration)
    return {
        /**
         * Lists Tailoring
         * @summary Request Tailoring
         * @param {TailoringsApiTailoringsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailorings(requestParameters: TailoringsApiTailoringsRequest, options?: AxiosRequestConfig): AxiosPromise<Tailorings200Response> {
            return localVarFp.tailorings(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tailorings operation in TailoringsApi.
 * @export
 * @interface TailoringsApiTailoringsRequest
 */
export interface TailoringsApiTailoringsRequest {
    /**
     * 
     * @type {any}
     * @memberof TailoringsApiTailoring
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof TailoringsApiTailoring
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof TailoringsApiTailoring
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof TailoringsApiTailoring
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof TailoringsApiTailoring
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof TailoringsApiTailoring
     */
    readonly filter?: any
}

/**
 * TailoringsApi - object-oriented interface
 * @export
 * @class TailoringsApi
 * @extends {BaseAPI}
 */
export class TailoringsApi extends BaseAPI {
    /**
     * Lists Tailoring
     * @summary Request Tailoring
     * @param {TailoringsApiTailoringsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TailoringsApi
     */
    public tailorings(requestParameters: TailoringsApiTailoringsRequest, options?: AxiosRequestConfig) {
        return TailoringsApiFp(this.configuration).tailorings(requestParameters.policyId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UnassignRuleApi - axios parameter creator
 * @export
 */
export const UnassignRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRule: async (policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('unassignRule', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('unassignRule', 'tailoringId', tailoringId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unassignRule', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnassignRuleApi - functional programming interface
 * @export
 */
export const UnassignRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnassignRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {any} policyId 
         * @param {any} tailoringId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignRule(policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRule(policyId, tailoringId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UnassignRuleApi - factory interface
 * @export
 */
export const UnassignRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnassignRuleApiFp(configuration)
    return {
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {UnassignRuleApiUnassignRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRule(requestParameters: UnassignRuleApiUnassignRuleRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unassignRule(requestParameters.policyId, requestParameters.tailoringId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for unassignRule operation in UnassignRuleApi.
 * @export
 * @interface UnassignRuleApiUnassignRuleRequest
 */
export interface UnassignRuleApiUnassignRuleRequest {
    /**
     * 
     * @type {any}
     * @memberof UnassignRuleApiUnassignRule
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof UnassignRuleApiUnassignRule
     */
    readonly tailoringId: any

    /**
     * 
     * @type {any}
     * @memberof UnassignRuleApiUnassignRule
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof UnassignRuleApiUnassignRule
     */
    readonly xRHIDENTITY?: any
}

/**
 * UnassignRuleApi - object-oriented interface
 * @export
 * @class UnassignRuleApi
 * @extends {BaseAPI}
 */
export class UnassignRuleApi extends BaseAPI {
    /**
     * Unassigns a Rule from a Tailoring
     * @summary Unassign a Rule from a Tailoring
     * @param {UnassignRuleApiUnassignRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnassignRuleApi
     */
    public unassignRule(requestParameters: UnassignRuleApiUnassignRuleRequest, options?: AxiosRequestConfig) {
        return UnassignRuleApiFp(this.configuration).unassignRule(requestParameters.policyId, requestParameters.tailoringId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UnassignSystemApi - axios parameter creator
 * @export
 */
export const UnassignSystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {any} id 
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignSystem: async (id: any, policyId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unassignSystem', 'id', id)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('unassignSystem', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnassignSystemApi - functional programming interface
 * @export
 */
export const UnassignSystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnassignSystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {any} id 
         * @param {any} policyId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignSystem(id: any, policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignSystem(id, policyId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UnassignSystemApi - factory interface
 * @export
 */
export const UnassignSystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnassignSystemApiFp(configuration)
    return {
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {UnassignSystemApiUnassignSystemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignSystem(requestParameters: UnassignSystemApiUnassignSystemRequest, options?: AxiosRequestConfig): AxiosPromise<System200Response> {
            return localVarFp.unassignSystem(requestParameters.id, requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for unassignSystem operation in UnassignSystemApi.
 * @export
 * @interface UnassignSystemApiUnassignSystemRequest
 */
export interface UnassignSystemApiUnassignSystemRequest {
    /**
     * 
     * @type {any}
     * @memberof UnassignSystemApiUnassignSystem
     */
    readonly id: any

    /**
     * 
     * @type {any}
     * @memberof UnassignSystemApiUnassignSystem
     */
    readonly policyId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof UnassignSystemApiUnassignSystem
     */
    readonly xRHIDENTITY?: any
}

/**
 * UnassignSystemApi - object-oriented interface
 * @export
 * @class UnassignSystemApi
 * @extends {BaseAPI}
 */
export class UnassignSystemApi extends BaseAPI {
    /**
     * Unassigns a System from a Policy
     * @summary Unassign a System from a Policy
     * @param {UnassignSystemApiUnassignSystemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnassignSystemApi
     */
    public unassignSystem(requestParameters: UnassignSystemApiUnassignSystemRequest, options?: AxiosRequestConfig) {
        return UnassignSystemApiFp(this.configuration).unassignSystem(requestParameters.id, requestParameters.policyId, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdatePolicyApi - axios parameter creator
 * @export
 */
export const UpdatePolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates a Policy with the provided attribute
         * @summary Update a Policy
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {PolicyUpdate} [policyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (id: any, xRHIDENTITY?: any, policyUpdate?: PolicyUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdatePolicyApi - functional programming interface
 * @export
 */
export const UpdatePolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdatePolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates a Policy with the provided attribute
         * @summary Update a Policy
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {PolicyUpdate} [policyUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(id: any, xRHIDENTITY?: any, policyUpdate?: PolicyUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(id, xRHIDENTITY, policyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdatePolicyApi - factory interface
 * @export
 */
export const UpdatePolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdatePolicyApiFp(configuration)
    return {
        /**
         * Updates a Policy with the provided attribute
         * @summary Update a Policy
         * @param {UpdatePolicyApiUpdatePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(requestParameters: UpdatePolicyApiUpdatePolicyRequest, options?: AxiosRequestConfig): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.updatePolicy(requestParameters.id, requestParameters.xRHIDENTITY, requestParameters.policyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePolicy operation in UpdatePolicyApi.
 * @export
 * @interface UpdatePolicyApiUpdatePolicyRequest
 */
export interface UpdatePolicyApiUpdatePolicyRequest {
    /**
     * 
     * @type {any}
     * @memberof UpdatePolicyApiUpdatePolicy
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof UpdatePolicyApiUpdatePolicy
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {PolicyUpdate}
     * @memberof UpdatePolicyApiUpdatePolicy
     */
    readonly policyUpdate?: PolicyUpdate
}

/**
 * UpdatePolicyApi - object-oriented interface
 * @export
 * @class UpdatePolicyApi
 * @extends {BaseAPI}
 */
export class UpdatePolicyApi extends BaseAPI {
    /**
     * Updates a Policy with the provided attribute
     * @summary Update a Policy
     * @param {UpdatePolicyApiUpdatePolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatePolicyApi
     */
    public updatePolicy(requestParameters: UpdatePolicyApiUpdatePolicyRequest, options?: AxiosRequestConfig) {
        return UpdatePolicyApiFp(this.configuration).updatePolicy(requestParameters.id, requestParameters.xRHIDENTITY, requestParameters.policyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdateTailoringApi - axios parameter creator
 * @export
 */
export const UpdateTailoringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates a Tailoring with the provided value_override
         * @summary Update a Tailoring
         * @param {any} policyId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {Tailoring} [tailoring] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTailoring: async (policyId: any, id: any, xRHIDENTITY?: any, tailoring?: Tailoring, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('updateTailoring', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTailoring', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tailoring, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateTailoringApi - functional programming interface
 * @export
 */
export const UpdateTailoringApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdateTailoringApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates a Tailoring with the provided value_override
         * @summary Update a Tailoring
         * @param {any} policyId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {Tailoring} [tailoring] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTailoring(policyId: any, id: any, xRHIDENTITY?: any, tailoring?: Tailoring, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailoring200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTailoring(policyId, id, xRHIDENTITY, tailoring, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdateTailoringApi - factory interface
 * @export
 */
export const UpdateTailoringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdateTailoringApiFp(configuration)
    return {
        /**
         * Updates a Tailoring with the provided value_override
         * @summary Update a Tailoring
         * @param {UpdateTailoringApiUpdateTailoringRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTailoring(requestParameters: UpdateTailoringApiUpdateTailoringRequest, options?: AxiosRequestConfig): AxiosPromise<Tailoring200Response> {
            return localVarFp.updateTailoring(requestParameters.policyId, requestParameters.id, requestParameters.xRHIDENTITY, requestParameters.tailoring, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateTailoring operation in UpdateTailoringApi.
 * @export
 * @interface UpdateTailoringApiUpdateTailoringRequest
 */
export interface UpdateTailoringApiUpdateTailoringRequest {
    /**
     * 
     * @type {any}
     * @memberof UpdateTailoringApiUpdateTailoring
     */
    readonly policyId: any

    /**
     * 
     * @type {any}
     * @memberof UpdateTailoringApiUpdateTailoring
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof UpdateTailoringApiUpdateTailoring
     */
    readonly xRHIDENTITY?: any

    /**
     * 
     * @type {Tailoring}
     * @memberof UpdateTailoringApiUpdateTailoring
     */
    readonly tailoring?: Tailoring
}

/**
 * UpdateTailoringApi - object-oriented interface
 * @export
 * @class UpdateTailoringApi
 * @extends {BaseAPI}
 */
export class UpdateTailoringApi extends BaseAPI {
    /**
     * Updates a Tailoring with the provided value_override
     * @summary Update a Tailoring
     * @param {UpdateTailoringApiUpdateTailoringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateTailoringApi
     */
    public updateTailoring(requestParameters: UpdateTailoringApiUpdateTailoringRequest, options?: AxiosRequestConfig) {
        return UpdateTailoringApiFp(this.configuration).updateTailoring(requestParameters.policyId, requestParameters.id, requestParameters.xRHIDENTITY, requestParameters.tailoring, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueDefinitionApi - axios parameter creator
 * @export
 */
export const ValueDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {any} securityGuideId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinition: async (securityGuideId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('valueDefinition', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('valueDefinition', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/value_definitions/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueDefinitionApi - functional programming interface
 * @export
 */
export const ValueDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {any} securityGuideId 
         * @param {any} id 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async valueDefinition(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueDefinition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.valueDefinition(securityGuideId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueDefinitionApi - factory interface
 * @export
 */
export const ValueDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueDefinitionApiFp(configuration)
    return {
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {ValueDefinitionApiValueDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinition(requestParameters: ValueDefinitionApiValueDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ValueDefinition200Response> {
            return localVarFp.valueDefinition(requestParameters.securityGuideId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for valueDefinition operation in ValueDefinitionApi.
 * @export
 * @interface ValueDefinitionApiValueDefinitionRequest
 */
export interface ValueDefinitionApiValueDefinitionRequest {
    /**
     * 
     * @type {any}
     * @memberof ValueDefinitionApiValueDefinition
     */
    readonly securityGuideId: any

    /**
     * 
     * @type {any}
     * @memberof ValueDefinitionApiValueDefinition
     */
    readonly id: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ValueDefinitionApiValueDefinition
     */
    readonly xRHIDENTITY?: any
}

/**
 * ValueDefinitionApi - object-oriented interface
 * @export
 * @class ValueDefinitionApi
 * @extends {BaseAPI}
 */
export class ValueDefinitionApi extends BaseAPI {
    /**
     * Returns a Value Definition
     * @summary Request a Value Definition
     * @param {ValueDefinitionApiValueDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueDefinitionApi
     */
    public valueDefinition(requestParameters: ValueDefinitionApiValueDefinitionRequest, options?: AxiosRequestConfig) {
        return ValueDefinitionApiFp(this.configuration).valueDefinition(requestParameters.securityGuideId, requestParameters.id, requestParameters.xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueDefinitionsApi - axios parameter creator
 * @export
 */
export const ValueDefinitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists Value Definition
         * @summary Request Value Definition
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinitions: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('valueDefinitions', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/value_definitions`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string' 
                    ? xRHIDENTITY 
                    : JSON.stringify(xRHIDENTITY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueDefinitionsApi - functional programming interface
 * @export
 */
export const ValueDefinitionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueDefinitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists Value Definition
         * @summary Request Value Definition
         * @param {any} securityGuideId 
         * @param {any} [xRHIDENTITY] For internal use only
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async valueDefinitions(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueDefinitions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.valueDefinitions(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueDefinitionsApi - factory interface
 * @export
 */
export const ValueDefinitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueDefinitionsApiFp(configuration)
    return {
        /**
         * Lists Value Definition
         * @summary Request Value Definition
         * @param {ValueDefinitionsApiValueDefinitionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinitions(requestParameters: ValueDefinitionsApiValueDefinitionsRequest, options?: AxiosRequestConfig): AxiosPromise<ValueDefinitions200Response> {
            return localVarFp.valueDefinitions(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for valueDefinitions operation in ValueDefinitionsApi.
 * @export
 * @interface ValueDefinitionsApiValueDefinitionsRequest
 */
export interface ValueDefinitionsApiValueDefinitionsRequest {
    /**
     * 
     * @type {any}
     * @memberof ValueDefinitionsApiValueDefinition
     */
    readonly securityGuideId: any

    /**
     * For internal use only
     * @type {any}
     * @memberof ValueDefinitionsApiValueDefinition
     */
    readonly xRHIDENTITY?: any

    /**
     * Number of items to return per page
     * @type {any}
     * @memberof ValueDefinitionsApiValueDefinition
     */
    readonly limit?: any

    /**
     * Offset of first item of paginated response
     * @type {any}
     * @memberof ValueDefinitionsApiValueDefinition
     */
    readonly offset?: any

    /**
     * Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @type {any}
     * @memberof ValueDefinitionsApiValueDefinition
     */
    readonly sortBy?: any

    /**
     * Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(field_1&#x3D;something AND field_2!&#x3D;\&quot;something else\&quot;) OR field_3&gt;40&#x60;)
     * @type {any}
     * @memberof ValueDefinitionsApiValueDefinition
     */
    readonly filter?: any
}

/**
 * ValueDefinitionsApi - object-oriented interface
 * @export
 * @class ValueDefinitionsApi
 * @extends {BaseAPI}
 */
export class ValueDefinitionsApi extends BaseAPI {
    /**
     * Lists Value Definition
     * @summary Request Value Definition
     * @param {ValueDefinitionsApiValueDefinitionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueDefinitionsApi
     */
    public valueDefinitions(requestParameters: ValueDefinitionsApiValueDefinitionsRequest, options?: AxiosRequestConfig) {
        return ValueDefinitionsApiFp(this.configuration).valueDefinitions(requestParameters.securityGuideId, requestParameters.xRHIDENTITY, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }
}


