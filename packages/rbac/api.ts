// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Role Based Access Control
 * The API for Role Based Access Control.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://raw.githubusercontent.com/api/rbac/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    permission: string;
    /**
     * 
     * @type {Array<ResourceDefinition>}
     * @memberof Access
     */
    resourceDefinitions: Array<ResourceDefinition>;
}

/**
 * 
 * @export
 * @interface AccessPagination
 */
export interface AccessPagination {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof AccessPagination
     */
    meta?: PaginationMeta;
    /**
     * 
     * @type {PaginationLinks}
     * @memberof AccessPagination
     */
    links?: PaginationLinks;
    /**
     * 
     * @type {Array<Access>}
     * @memberof AccessPagination
     */
    data: Array<Access>;
}

/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface GroupOut
 */
export interface GroupOut {
    /**
     * 
     * @type {string}
     * @memberof GroupOut
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GroupOut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupOut
     */
    uuid: string;
    /**
     * 
     * @type {Date}
     * @memberof GroupOut
     */
    created: Date;
    /**
     * 
     * @type {Date}
     * @memberof GroupOut
     */
    modified: Date;
}

/**
 * 
 * @export
 * @interface GroupPagination
 */
export interface GroupPagination {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof GroupPagination
     */
    meta?: PaginationMeta;
    /**
     * 
     * @type {PaginationLinks}
     * @memberof GroupPagination
     */
    links?: PaginationLinks;
    /**
     * 
     * @type {Array<GroupOut>}
     * @memberof GroupPagination
     */
    data: Array<GroupOut>;
}

/**
 * 
 * @export
 * @interface GroupPrincipalIn
 */
export interface GroupPrincipalIn {
    /**
     * 
     * @type {Array<PrincipalIn>}
     * @memberof GroupPrincipalIn
     */
    principals: Array<PrincipalIn>;
}

/**
 * 
 * @export
 * @interface GroupWithPrincipals
 */
export interface GroupWithPrincipals {
    /**
     * 
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    uuid: string;
    /**
     * 
     * @type {Date}
     * @memberof GroupWithPrincipals
     */
    created: Date;
    /**
     * 
     * @type {Date}
     * @memberof GroupWithPrincipals
     */
    modified: Date;
    /**
     * 
     * @type {Array<PrincipalOut>}
     * @memberof GroupWithPrincipals
     */
    principals: Array<PrincipalOut>;
}

/**
 * 
 * @export
 * @interface ListPagination
 */
export interface ListPagination {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof ListPagination
     */
    meta?: PaginationMeta;
    /**
     * 
     * @type {PaginationLinks}
     * @memberof ListPagination
     */
    links?: PaginationLinks;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {Array<any>}
     * @memberof ModelError
     */
    errors: Array<any>;
}

/**
 * 
 * @export
 * @interface PaginationLinks
 */
export interface PaginationLinks {
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    first?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginationLinks
     */
    last?: string;
}

/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * 
     * @type {number}
     * @memberof PaginationMeta
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface PolicyExtended
 */
export interface PolicyExtended {
    /**
     * 
     * @type {string}
     * @memberof PolicyExtended
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PolicyExtended
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PolicyExtended
     */
    uuid: string;
    /**
     * 
     * @type {Date}
     * @memberof PolicyExtended
     */
    created: Date;
    /**
     * 
     * @type {Date}
     * @memberof PolicyExtended
     */
    modified: Date;
    /**
     * 
     * @type {GroupOut}
     * @memberof PolicyExtended
     */
    group: GroupOut;
    /**
     * 
     * @type {Array<RoleOut>}
     * @memberof PolicyExtended
     */
    roles: Array<RoleOut>;
}

/**
 * 
 * @export
 * @interface PolicyIn
 */
export interface PolicyIn {
    /**
     * 
     * @type {string}
     * @memberof PolicyIn
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PolicyIn
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PolicyIn
     */
    group: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PolicyIn
     */
    roles: Array<string>;
}

/**
 * 
 * @export
 * @interface PolicyPagination
 */
export interface PolicyPagination {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PolicyPagination
     */
    meta?: PaginationMeta;
    /**
     * 
     * @type {PaginationLinks}
     * @memberof PolicyPagination
     */
    links?: PaginationLinks;
    /**
     * 
     * @type {Array<PolicyExtended>}
     * @memberof PolicyPagination
     */
    data: Array<PolicyExtended>;
}

/**
 * 
 * @export
 * @interface Principal
 */
export interface Principal {
    /**
     * 
     * @type {string}
     * @memberof Principal
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof Principal
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Principal
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Principal
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Principal
     */
    isOrgAdmin?: boolean;
}

/**
 * 
 * @export
 * @interface PrincipalIn
 */
export interface PrincipalIn {
    /**
     * 
     * @type {string}
     * @memberof PrincipalIn
     */
    username: string;
}

/**
 * 
 * @export
 * @interface PrincipalOut
 */
export interface PrincipalOut {
    /**
     * 
     * @type {string}
     * @memberof PrincipalOut
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof PrincipalOut
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof PrincipalOut
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof PrincipalOut
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PrincipalOut
     */
    isOrgAdmin?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PrincipalOut
     */
    uuid: string;
}

/**
 * 
 * @export
 * @interface PrincipalPagination
 */
export interface PrincipalPagination {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof PrincipalPagination
     */
    meta?: PaginationMeta;
    /**
     * 
     * @type {PaginationLinks}
     * @memberof PrincipalPagination
     */
    links?: PaginationLinks;
    /**
     * 
     * @type {Array<Principal>}
     * @memberof PrincipalPagination
     */
    data: Array<Principal>;
}

/**
 * 
 * @export
 * @interface ResourceDefinition
 */
export interface ResourceDefinition {
    /**
     * 
     * @type {ResourceDefinitionFilter}
     * @memberof ResourceDefinition
     */
    attributeFilter: ResourceDefinitionFilter;
}

/**
 * 
 * @export
 * @interface ResourceDefinitionFilter
 */
export interface ResourceDefinitionFilter {
    /**
     * 
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    operation: ResourceDefinitionFilter.OperationEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    value: string;
}

/**
 * @export
 * @namespace ResourceDefinitionFilter
 */
export namespace ResourceDefinitionFilter {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Equal = 'equal',
        In = 'in'
    }
}

/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface RoleIn
 */
export interface RoleIn {
    /**
     * 
     * @type {string}
     * @memberof RoleIn
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RoleIn
     */
    description?: string;
    /**
     * 
     * @type {Array<Access>}
     * @memberof RoleIn
     */
    access: Array<Access>;
}

/**
 * 
 * @export
 * @interface RoleOut
 */
export interface RoleOut {
    /**
     * 
     * @type {string}
     * @memberof RoleOut
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RoleOut
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleOut
     */
    uuid: string;
    /**
     * 
     * @type {Date}
     * @memberof RoleOut
     */
    created: Date;
    /**
     * 
     * @type {Date}
     * @memberof RoleOut
     */
    modified: Date;
}

/**
 * 
 * @export
 * @interface RolePagination
 */
export interface RolePagination {
    /**
     * 
     * @type {PaginationMeta}
     * @memberof RolePagination
     */
    meta?: PaginationMeta;
    /**
     * 
     * @type {PaginationLinks}
     * @memberof RolePagination
     */
    links?: PaginationLinks;
    /**
     * 
     * @type {Array<RoleOut>}
     * @memberof RolePagination
     */
    data: Array<RoleOut>;
}

/**
 * 
 * @export
 * @interface RoleWithAccess
 */
export interface RoleWithAccess {
    /**
     * 
     * @type {string}
     * @memberof RoleWithAccess
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RoleWithAccess
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleWithAccess
     */
    uuid: string;
    /**
     * 
     * @type {Date}
     * @memberof RoleWithAccess
     */
    created: Date;
    /**
     * 
     * @type {Date}
     * @memberof RoleWithAccess
     */
    modified: Date;
    /**
     * 
     * @type {Array<Access>}
     * @memberof RoleWithAccess
     */
    access: Array<Access>;
}

/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    apiVersion: number;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    commit?: string;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    serverAddress?: string;
    /**
     * 
     * @type {any}
     * @memberof Status
     */
    platformInfo?: any;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    pythonVersion?: string;
    /**
     * 
     * @type {any}
     * @memberof Status
     */
    modules?: any;
}

/**
 * 
 * @export
 * @interface Timestamped
 */
export interface Timestamped {
    /**
     * 
     * @type {Date}
     * @memberof Timestamped
     */
    created: Date;
    /**
     * 
     * @type {Date}
     * @memberof Timestamped
     */
    modified: Date;
}

/**
 * 
 * @export
 * @interface UUID
 */
export interface UUID {
    /**
     * 
     * @type {string}
     * @memberof UUID
     */
    uuid: string;
}


/**
 * AccessApi - axios parameter creator
 * @export
 */
export const AccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the permitted access for a principal in the tenant
         * @param {string} application The application name to obtain access for the principal
         * @param {string} [username] Unique username of the principal to obtain access for
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess(application: string, username?: string, limit?: number, offset?: number, options: any = {}): RequestArgs {
            // verify required parameter 'application' is not null or undefined
            if (application === null || application === undefined) {
                throw new RequiredError('application','Required parameter application was null or undefined when calling getPrincipalAccess.');
            }
            const localVarPath = `/access/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the permitted access for a principal in the tenant
         * @param {string} application The application name to obtain access for the principal
         * @param {string} [username] Unique username of the principal to obtain access for
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess(application: string, username?: string, limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPagination> {
            const localVarAxiosArgs = AccessApiAxiosParamCreator(configuration).getPrincipalAccess(application, username, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get the permitted access for a principal in the tenant
         * @param {string} application The application name to obtain access for the principal
         * @param {string} [username] Unique username of the principal to obtain access for
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess(application: string, username?: string, limit?: number, offset?: number, options?: any) {
            return AccessApiFp(configuration).getPrincipalAccess(application, username, limit, offset, options)(axios, basePath);
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * 
     * @summary Get the permitted access for a principal in the tenant
     * @param {string} application The application name to obtain access for the principal
     * @param {string} [username] Unique username of the principal to obtain access for
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public getPrincipalAccess(application: string, username?: string, limit?: number, offset?: number, options?: any) {
        return AccessApiFp(this.configuration).getPrincipalAccess(application, username, limit, offset, options)(this.axios, this.basePath);
    }

}

/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling addPrincipalToGroup.');
            }
            // verify required parameter 'groupPrincipalIn' is not null or undefined
            if (groupPrincipalIn === null || groupPrincipalIn === undefined) {
                throw new RequiredError('groupPrincipalIn','Required parameter groupPrincipalIn was null or undefined when calling addPrincipalToGroup.');
            }
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupPrincipalIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(groupPrincipalIn || {}) : (groupPrincipalIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options: any = {}): RequestArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling createGroup.');
            }
            const localVarPath = `/groups/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(group || {}) : (group || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup(uuid: string, usernames: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deletePrincipalFromGroup.');
            }
            // verify required parameter 'usernames' is not null or undefined
            if (usernames === null || usernames === undefined) {
                throw new RequiredError('usernames','Required parameter usernames was null or undefined when calling deletePrincipalFromGroup.');
            }
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (usernames !== undefined) {
                localVarQueryParameter['usernames'] = usernames;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, name?: string, username?: string, orderBy?: string, options: any = {}): RequestArgs {
            const localVarPath = `/groups/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Udate a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(uuid: string, group: Group, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling updateGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(group || {}) : (group || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWithPrincipals> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOut> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).createGroup(group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).deleteGroup(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup(uuid: string, usernames: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).deletePrincipalFromGroup(uuid, usernames, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWithPrincipals> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).getGroup(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, name?: string, username?: string, orderBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPagination> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).listGroups(limit, offset, name, username, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Udate a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(uuid: string, group: Group, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOut> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).updateGroup(uuid, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any) {
            return GroupApiFp(configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any) {
            return GroupApiFp(configuration).createGroup(group, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(uuid: string, options?: any) {
            return GroupApiFp(configuration).deleteGroup(uuid, options)(axios, basePath);
        },
        /**
         * 
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup(uuid: string, usernames: string, options?: any) {
            return GroupApiFp(configuration).deletePrincipalFromGroup(uuid, usernames, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(uuid: string, options?: any) {
            return GroupApiFp(configuration).getGroup(uuid, options)(axios, basePath);
        },
        /**
         * 
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, name?: string, username?: string, orderBy?: string, options?: any) {
            return GroupApiFp(configuration).listGroups(limit, offset, name, username, orderBy, options)(axios, basePath);
        },
        /**
         * 
         * @summary Udate a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(uuid: string, group: Group, options?: any) {
            return GroupApiFp(configuration).updateGroup(uuid, group, options)(axios, basePath);
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @summary Add a principal to a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any) {
        return GroupApiFp(this.configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a group in a tenant
     * @param {Group} group Group to create in tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(group: Group, options?: any) {
        return GroupApiFp(this.configuration).createGroup(group, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a group in the tenant
     * @param {string} uuid ID of group to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(uuid: string, options?: any) {
        return GroupApiFp(this.configuration).deleteGroup(uuid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Remove a principal from a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {string} usernames A comma separated list of usernames for principals to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deletePrincipalFromGroup(uuid: string, usernames: string, options?: any) {
        return GroupApiFp(this.configuration).deletePrincipalFromGroup(uuid, usernames, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a group in the tenant
     * @param {string} uuid ID of group to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(uuid: string, options?: any) {
        return GroupApiFp(this.configuration).getGroup(uuid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List the groups for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {string} [username] A username for a principal to filter for groups
     * @param {string} [orderBy] Parameter for ordering resource by value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listGroups(limit?: number, offset?: number, name?: string, username?: string, orderBy?: string, options?: any) {
        return GroupApiFp(this.configuration).listGroups(limit, offset, name, username, orderBy, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Udate a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {Group} group Group to update in tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(uuid: string, group: Group, options?: any) {
        return GroupApiFp(this.configuration).updateGroup(uuid, group, options)(this.axios, this.basePath);
    }

}

/**
 * PolicyApi - axios parameter creator
 * @export
 */
export const PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicies(policyIn: PolicyIn, options: any = {}): RequestArgs {
            // verify required parameter 'policyIn' is not null or undefined
            if (policyIn === null || policyIn === undefined) {
                throw new RequiredError('policyIn','Required parameter policyIn was null or undefined when calling createPolicies.');
            }
            const localVarPath = `/policies/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PolicyIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(policyIn || {}) : (policyIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deletePolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getPolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(limit?: number, offset?: number, name?: string, orderBy?: string, options: any = {}): RequestArgs {
            const localVarPath = `/policies/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(uuid: string, policyIn: PolicyIn, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updatePolicy.');
            }
            // verify required parameter 'policyIn' is not null or undefined
            if (policyIn === null || policyIn === undefined) {
                throw new RequiredError('policyIn','Required parameter policyIn was null or undefined when calling updatePolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PolicyIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(policyIn || {}) : (policyIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyApi - functional programming interface
 * @export
 */
export const PolicyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicies(policyIn: PolicyIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).createPolicies(policyIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).deletePolicy(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).getPolicy(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(limit?: number, offset?: number, name?: string, orderBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyPagination> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).listPolicies(limit, offset, name, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(uuid: string, policyIn: PolicyIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).updatePolicy(uuid, policyIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * PolicyApi - factory interface
 * @export
 */
export const PolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicies(policyIn: PolicyIn, options?: any) {
            return PolicyApiFp(configuration).createPolicies(policyIn, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(uuid: string, options?: any) {
            return PolicyApiFp(configuration).deletePolicy(uuid, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(uuid: string, options?: any) {
            return PolicyApiFp(configuration).getPolicy(uuid, options)(axios, basePath);
        },
        /**
         * 
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(limit?: number, offset?: number, name?: string, orderBy?: string, options?: any) {
            return PolicyApiFp(configuration).listPolicies(limit, offset, name, orderBy, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(uuid: string, policyIn: PolicyIn, options?: any) {
            return PolicyApiFp(configuration).updatePolicy(uuid, policyIn, options)(axios, basePath);
        },
    };
};

/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
export class PolicyApi extends BaseAPI {
    /**
     * 
     * @summary Create a policy in a tenant
     * @param {PolicyIn} policyIn Policy to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public createPolicies(policyIn: PolicyIn, options?: any) {
        return PolicyApiFp(this.configuration).createPolicies(policyIn, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a policy in the tenant
     * @param {string} uuid ID of policy to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public deletePolicy(uuid: string, options?: any) {
        return PolicyApiFp(this.configuration).deletePolicy(uuid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a policy in the tenant
     * @param {string} uuid ID of policy to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getPolicy(uuid: string, options?: any) {
        return PolicyApiFp(this.configuration).getPolicy(uuid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List the policies in the tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {string} [orderBy] Parameter for ordering resource by value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public listPolicies(limit?: number, offset?: number, name?: string, orderBy?: string, options?: any) {
        return PolicyApiFp(this.configuration).listPolicies(limit, offset, name, orderBy, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a policy in the tenant
     * @param {string} uuid ID of policy to update
     * @param {PolicyIn} policyIn Policy to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public updatePolicy(uuid: string, policyIn: PolicyIn, options?: any) {
        return PolicyApiFp(this.configuration).updatePolicy(uuid, policyIn, options)(this.axios, this.basePath);
    }

}

/**
 * PrincipalApi - axios parameter creator
 * @export
 */
export const PrincipalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a principal in the tenant
         * @param {string} username Username of principal to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipal(username: string, options: any = {}): RequestArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getPrincipal.');
            }
            const localVarPath = `/principals/{username}/`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(limit?: number, offset?: number, options: any = {}): RequestArgs {
            const localVarPath = `/principals/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrincipalApi - functional programming interface
 * @export
 */
export const PrincipalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a principal in the tenant
         * @param {string} username Username of principal to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipal(username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Principal> {
            const localVarAxiosArgs = PrincipalApiAxiosParamCreator(configuration).getPrincipal(username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrincipalPagination> {
            const localVarAxiosArgs = PrincipalApiAxiosParamCreator(configuration).listPrincipals(limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * PrincipalApi - factory interface
 * @export
 */
export const PrincipalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get a principal in the tenant
         * @param {string} username Username of principal to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipal(username: string, options?: any) {
            return PrincipalApiFp(configuration).getPrincipal(username, options)(axios, basePath);
        },
        /**
         * 
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(limit?: number, offset?: number, options?: any) {
            return PrincipalApiFp(configuration).listPrincipals(limit, offset, options)(axios, basePath);
        },
    };
};

/**
 * PrincipalApi - object-oriented interface
 * @export
 * @class PrincipalApi
 * @extends {BaseAPI}
 */
export class PrincipalApi extends BaseAPI {
    /**
     * 
     * @summary Get a principal in the tenant
     * @param {string} username Username of principal to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrincipalApi
     */
    public getPrincipal(username: string, options?: any) {
        return PrincipalApiFp(this.configuration).getPrincipal(username, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List the principals for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrincipalApi
     */
    public listPrincipals(limit?: number, offset?: number, options?: any) {
        return PrincipalApiFp(this.configuration).listPrincipals(limit, offset, options)(this.axios, this.basePath);
    }

}

/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a roles for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoles(roleIn: RoleIn, options: any = {}): RequestArgs {
            // verify required parameter 'roleIn' is not null or undefined
            if (roleIn === null || roleIn === undefined) {
                throw new RequiredError('roleIn','Required parameter roleIn was null or undefined when calling createRoles.');
            }
            const localVarPath = `/roles/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RoleIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(roleIn || {}) : (roleIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(limit?: number, offset?: number, name?: string, orderBy?: string, options: any = {}): RequestArgs {
            const localVarPath = `/roles/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(uuid: string, roleWithAccess: RoleWithAccess, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateRole.');
            }
            // verify required parameter 'roleWithAccess' is not null or undefined
            if (roleWithAccess === null || roleWithAccess === undefined) {
                throw new RequiredError('roleWithAccess','Required parameter roleWithAccess was null or undefined when calling updateRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RoleWithAccess" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(roleWithAccess || {}) : (roleWithAccess || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a roles for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoles(roleIn: RoleIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).createRoles(roleIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).deleteRole(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).getRole(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(limit?: number, offset?: number, name?: string, orderBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolePagination> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).listRoles(limit, offset, name, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update a Role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).updateRole(uuid, roleWithAccess, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a roles for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoles(roleIn: RoleIn, options?: any) {
            return RoleApiFp(configuration).createRoles(roleIn, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(uuid: string, options?: any) {
            return RoleApiFp(configuration).deleteRole(uuid, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(uuid: string, options?: any) {
            return RoleApiFp(configuration).getRole(uuid, options)(axios, basePath);
        },
        /**
         * 
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {string} [orderBy] Parameter for ordering resource by value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(limit?: number, offset?: number, name?: string, orderBy?: string, options?: any) {
            return RoleApiFp(configuration).listRoles(limit, offset, name, orderBy, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a Role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any) {
            return RoleApiFp(configuration).updateRole(uuid, roleWithAccess, options)(axios, basePath);
        },
    };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
    /**
     * 
     * @summary Create a roles for a tenant
     * @param {RoleIn} roleIn Role to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public createRoles(roleIn: RoleIn, options?: any) {
        return RoleApiFp(this.configuration).createRoles(roleIn, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a role in the tenant
     * @param {string} uuid ID of role to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public deleteRole(uuid: string, options?: any) {
        return RoleApiFp(this.configuration).deleteRole(uuid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get a role in the tenant
     * @param {string} uuid ID of role to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public getRole(uuid: string, options?: any) {
        return RoleApiFp(this.configuration).getRole(uuid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List the roles for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {string} [orderBy] Parameter for ordering resource by value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public listRoles(limit?: number, offset?: number, name?: string, orderBy?: string, options?: any) {
        return RoleApiFp(this.configuration).listRoles(limit, offset, name, orderBy, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a Role in the tenant
     * @param {string} uuid ID of role to update
     * @param {RoleWithAccess} roleWithAccess Update to a Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any) {
        return RoleApiFp(this.configuration).updateRole(uuid, roleWithAccess, options)(this.axios, this.basePath);
    }

}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options: any = {}): RequestArgs {
            const localVarPath = `/status/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status> {
            const localVarAxiosArgs = StatusApiAxiosParamCreator(configuration).getStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any) {
            return StatusApiFp(configuration).getStatus(options)(axios, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @summary Obtain server status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatus(options?: any) {
        return StatusApiFp(this.configuration).getStatus(options)(this.axios, this.basePath);
    }

}

