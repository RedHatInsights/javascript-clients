// tslint:disable
/**
 * Role Based Access Control
 * The API for Role Based Access Control.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Access
 */
export interface Access {
    /**
     *
     * @type {string}
     * @memberof Access
     */
    permission: string;
    /**
     *
     * @type {Array<ResourceDefinition>}
     * @memberof Access
     */
    resourceDefinitions: Array<ResourceDefinition>;
}
/**
 *
 * @export
 * @interface AccessPagination
 */
export interface AccessPagination extends ListPagination {
    /**
     *
     * @type {Array<Access>}
     * @memberof AccessPagination
     */
    data: Array<Access>;
}
/**
 *
 * @export
 * @interface AccessPaginationAllOf
 */
export interface AccessPaginationAllOf {
    /**
     *
     * @type {Array<Access>}
     * @memberof AccessPaginationAllOf
     */
    data: Array<Access>;
}
/**
 *
 * @export
 * @interface AdditionalGroup
 */
export interface AdditionalGroup {
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    uuid?: string;
}
/**
 *
 * @export
 * @interface Error403
 */
export interface Error403 {
    /**
     *
     * @type {Array<object>}
     * @memberof Error403
     */
    errors: Array<object>;
}
/**
 *
 * @export
 * @interface Group
 */
export interface Group {
    /**
     *
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    description?: string;
}
/**
 *
 * @export
 * @interface GroupOut
 */
export interface GroupOut {
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    modified: string;
    /**
     *
     * @type {number}
     * @memberof GroupOut
     */
    principalCount?: number;
    /**
     *
     * @type {number}
     * @memberof GroupOut
     */
    roleCount?: number;
    /**
     *
     * @type {boolean}
     * @memberof GroupOut
     */
    system?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupOut
     */
    platform_default?: boolean;
}
/**
 *
 * @export
 * @interface GroupPagination
 */
export interface GroupPagination extends ListPagination {
    /**
     *
     * @type {Array<GroupOut>}
     * @memberof GroupPagination
     */
    data: Array<GroupOut>;
}
/**
 *
 * @export
 * @interface GroupPaginationAllOf
 */
export interface GroupPaginationAllOf {
    /**
     *
     * @type {Array<GroupOut>}
     * @memberof GroupPaginationAllOf
     */
    data: Array<GroupOut>;
}
/**
 *
 * @export
 * @interface GroupPrincipalIn
 */
export interface GroupPrincipalIn {
    /**
     *
     * @type {Array<PrincipalIn>}
     * @memberof GroupPrincipalIn
     */
    principals: Array<PrincipalIn>;
}
/**
 *
 * @export
 * @interface GroupRoleIn
 */
export interface GroupRoleIn {
    /**
     *
     * @type {Array<string>}
     * @memberof GroupRoleIn
     */
    roles: Array<string>;
}
/**
 *
 * @export
 * @interface GroupRolesPagination
 */
export interface GroupRolesPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof GroupRolesPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof GroupRolesPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof GroupRolesPagination
     */
    data: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipals
 */
export interface GroupWithPrincipals {
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    modified: string;
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipals
     */
    principals: Array<Principal>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipalsAllOf
 */
export interface GroupWithPrincipalsAllOf {
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipalsAllOf
     */
    principals: Array<Principal>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipalsAndRoles
 */
export interface GroupWithPrincipalsAndRoles {
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    modified: string;
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipalsAndRoles
     */
    principals: Array<Principal>;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof GroupWithPrincipalsAndRoles
     */
    roles: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipalsAndRolesAllOf
 */
export interface GroupWithPrincipalsAndRolesAllOf {
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipalsAndRolesAllOf
     */
    principals: Array<Principal>;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof GroupWithPrincipalsAndRolesAllOf
     */
    roles: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof InlineResponse200
     */
    data: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface ListPagination
 */
export interface ListPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof ListPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ListPagination
     */
    links?: PaginationLinks;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {Array<object>}
     * @memberof ModelError
     */
    errors: Array<object>;
}
/**
 *
 * @export
 * @interface PaginationLinks
 */
export interface PaginationLinks {
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    first?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    previous?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    next?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    last?: string;
}
/**
 *
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     *
     * @type {number}
     * @memberof PaginationMeta
     */
    count?: number;
}
/**
 *
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    description?: string;
}
/**
 *
 * @export
 * @interface PolicyExtended
 */
export interface PolicyExtended {
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    modified: string;
    /**
     *
     * @type {GroupOut}
     * @memberof PolicyExtended
     */
    group: GroupOut;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof PolicyExtended
     */
    roles: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface PolicyExtendedAllOf
 */
export interface PolicyExtendedAllOf {
    /**
     *
     * @type {GroupOut}
     * @memberof PolicyExtendedAllOf
     */
    group: GroupOut;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof PolicyExtendedAllOf
     */
    roles: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface PolicyIn
 */
export interface PolicyIn extends Policy {
    /**
     *
     * @type {string}
     * @memberof PolicyIn
     */
    group: string;
    /**
     *
     * @type {Array<string>}
     * @memberof PolicyIn
     */
    roles: Array<string>;
}
/**
 *
 * @export
 * @interface PolicyInAllOf
 */
export interface PolicyInAllOf {
    /**
     *
     * @type {string}
     * @memberof PolicyInAllOf
     */
    group: string;
    /**
     *
     * @type {Array<string>}
     * @memberof PolicyInAllOf
     */
    roles: Array<string>;
}
/**
 *
 * @export
 * @interface PolicyPagination
 */
export interface PolicyPagination extends ListPagination {
    /**
     *
     * @type {Array<PolicyExtended>}
     * @memberof PolicyPagination
     */
    data: Array<PolicyExtended>;
}
/**
 *
 * @export
 * @interface PolicyPaginationAllOf
 */
export interface PolicyPaginationAllOf {
    /**
     *
     * @type {Array<PolicyExtended>}
     * @memberof PolicyPaginationAllOf
     */
    data: Array<PolicyExtended>;
}
/**
 *
 * @export
 * @interface Principal
 */
export interface Principal {
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    first_name?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    last_name?: string;
    /**
     *
     * @type {boolean}
     * @memberof Principal
     */
    is_active?: boolean;
}
/**
 *
 * @export
 * @interface PrincipalIn
 */
export interface PrincipalIn {
    /**
     *
     * @type {string}
     * @memberof PrincipalIn
     */
    username: string;
}
/**
 *
 * @export
 * @interface PrincipalOut
 */
export interface PrincipalOut {
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    first_name?: string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    last_name?: string;
    /**
     *
     * @type {boolean}
     * @memberof PrincipalOut
     */
    is_active?: boolean;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    uuid: string;
}
/**
 *
 * @export
 * @interface PrincipalPagination
 */
export interface PrincipalPagination extends ListPagination {
    /**
     *
     * @type {Array<Principal>}
     * @memberof PrincipalPagination
     */
    data: Array<Principal>;
}
/**
 *
 * @export
 * @interface PrincipalPaginationAllOf
 */
export interface PrincipalPaginationAllOf {
    /**
     *
     * @type {Array<Principal>}
     * @memberof PrincipalPaginationAllOf
     */
    data: Array<Principal>;
}
/**
 *
 * @export
 * @interface ResourceDefinition
 */
export interface ResourceDefinition {
    /**
     *
     * @type {ResourceDefinitionFilter}
     * @memberof ResourceDefinition
     */
    attributeFilter: ResourceDefinitionFilter;
}
/**
 *
 * @export
 * @interface ResourceDefinitionFilter
 */
export interface ResourceDefinitionFilter {
    /**
     *
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    key: string;
    /**
     *
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    operation: ResourceDefinitionFilterOperationEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    value: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceDefinitionFilterOperationEnum {
    Equal = 'equal',
    In = 'in'
}

/**
 *
 * @export
 * @interface Role
 */
export interface Role {
    /**
     *
     * @type {string}
     * @memberof Role
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Role
     */
    description?: string;
}
/**
 *
 * @export
 * @interface RoleIn
 */
export interface RoleIn extends Role {
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleIn
     */
    access: Array<Access>;
}
/**
 *
 * @export
 * @interface RoleInAllOf
 */
export interface RoleInAllOf {
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleInAllOf
     */
    access: Array<Access>;
}
/**
 *
 * @export
 * @interface RoleOut
 */
export interface RoleOut {
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    modified: string;
    /**
     *
     * @type {number}
     * @memberof RoleOut
     */
    policyCount?: number;
    /**
     *
     * @type {number}
     * @memberof RoleOut
     */
    accessCount?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOut
     */
    applications?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOut
     */
    system?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOut
     */
    platform_default?: boolean;
}
/**
 *
 * @export
 * @interface RoleOutDynamic
 */
export interface RoleOutDynamic {
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    modified: string;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    policyCount: number;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    accessCount: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOutDynamic
     */
    applications: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamic
     */
    system: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamic
     */
    platform_default: boolean;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    groups_in_count?: number;
    /**
     *
     * @type {Array<AdditionalGroup>}
     * @memberof RoleOutDynamic
     */
    groups_in?: Array<AdditionalGroup>;
}
/**
 *
 * @export
 * @interface RoleOutDynamicAllOf
 */
export interface RoleOutDynamicAllOf {
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamicAllOf
     */
    policyCount: number;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamicAllOf
     */
    accessCount: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOutDynamicAllOf
     */
    applications: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamicAllOf
     */
    system: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamicAllOf
     */
    platform_default: boolean;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamicAllOf
     */
    groups_in_count?: number;
    /**
     *
     * @type {Array<AdditionalGroup>}
     * @memberof RoleOutDynamicAllOf
     */
    groups_in?: Array<AdditionalGroup>;
}
/**
 *
 * @export
 * @interface RolePagination
 */
export interface RolePagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof RolePagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof RolePagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof RolePagination
     */
    data: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface RolePaginationDynamic
 */
export interface RolePaginationDynamic extends ListPagination {
    /**
     *
     * @type {Array<RoleOutDynamic>}
     * @memberof RolePaginationDynamic
     */
    data: Array<RoleOutDynamic>;
}
/**
 *
 * @export
 * @interface RolePaginationDynamicAllOf
 */
export interface RolePaginationDynamicAllOf {
    /**
     *
     * @type {Array<RoleOutDynamic>}
     * @memberof RolePaginationDynamicAllOf
     */
    data: Array<RoleOutDynamic>;
}
/**
 *
 * @export
 * @interface RoleWithAccess
 */
export interface RoleWithAccess {
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    modified: string;
    /**
     *
     * @type {number}
     * @memberof RoleWithAccess
     */
    policyCount?: number;
    /**
     *
     * @type {number}
     * @memberof RoleWithAccess
     */
    accessCount?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleWithAccess
     */
    applications?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleWithAccess
     */
    system?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleWithAccess
     */
    platform_default?: boolean;
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleWithAccess
     */
    access: Array<Access>;
}
/**
 *
 * @export
 * @interface Status
 */
export interface Status {
    /**
     *
     * @type {number}
     * @memberof Status
     */
    api_version: number;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    commit?: string;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    server_address?: string;
    /**
     *
     * @type {object}
     * @memberof Status
     */
    platform_info?: object;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    python_version?: string;
    /**
     *
     * @type {object}
     * @memberof Status
     */
    modules?: object;
}
/**
 *
 * @export
 * @interface Timestamped
 */
export interface Timestamped {
    /**
     *
     * @type {string}
     * @memberof Timestamped
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof Timestamped
     */
    modified: string;
}
/**
 *
 * @export
 * @interface UUID
 */
export interface UUID {
    /**
     *
     * @type {string}
     * @memberof UUID
     */
    uuid: string;
}

/**
 * AccessApi - axios parameter creator
 * @export
 */
export const AccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess(application: string, username?: string, limit?: number, offset?: number, options: any = {}): RequestArgs {
            // verify required parameter 'application' is not null or undefined
            if (application === null || application === undefined) {
                throw new RequiredError('application','Required parameter application was null or undefined when calling getPrincipalAccess.');
            }
            const localVarPath = `/access/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess(application: string, username?: string, limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPagination> {
            const localVarAxiosArgs = AccessApiAxiosParamCreator(configuration).getPrincipalAccess(application, username, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess(application: string, username?: string, limit?: number, offset?: number, options?: any): AxiosPromise<AccessPagination> {
            return AccessApiFp(configuration).getPrincipalAccess(application, username, limit, offset, options)(axios, basePath);
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * Access responses are sorted in ascending order by an ID internal to the database
     * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
     * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
     * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public getPrincipalAccess(application: string, username?: string, limit?: number, offset?: number, options?: any) {
        return AccessApiFp(this.configuration).getPrincipalAccess(application, username, limit, offset, options)(this.axios, this.basePath);
    }

}


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling addPrincipalToGroup.');
            }
            // verify required parameter 'groupPrincipalIn' is not null or undefined
            if (groupPrincipalIn === null || groupPrincipalIn === undefined) {
                throw new RequiredError('groupPrincipalIn','Required parameter groupPrincipalIn was null or undefined when calling addPrincipalToGroup.');
            }
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof groupPrincipalIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(groupPrincipalIn !== undefined ? groupPrincipalIn : {}) : (groupPrincipalIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling addRoleToGroup.');
            }
            // verify required parameter 'groupRoleIn' is not null or undefined
            if (groupRoleIn === null || groupRoleIn === undefined) {
                throw new RequiredError('groupRoleIn','Required parameter groupRoleIn was null or undefined when calling addRoleToGroup.');
            }
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof groupRoleIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(groupRoleIn !== undefined ? groupRoleIn : {}) : (groupRoleIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options: any = {}): RequestArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling createGroup.');
            }
            const localVarPath = `/groups/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof group !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(group !== undefined ? group : {}) : (group || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup(uuid: string, usernames: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deletePrincipalFromGroup.');
            }
            // verify required parameter 'usernames' is not null or undefined
            if (usernames === null || usernames === undefined) {
                throw new RequiredError('usernames','Required parameter usernames was null or undefined when calling deletePrincipalFromGroup.');
            }
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (usernames !== undefined) {
                localVarQueryParameter['usernames'] = usernames;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleFromGroup(uuid: string, roles: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRoleFromGroup.');
            }
            // verify required parameter 'roles' is not null or undefined
            if (roles === null || roles === undefined) {
                throw new RequiredError('roles','Required parameter roles was null or undefined when calling deleteRoleFromGroup.');
            }
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalsFromGroup(uuid: string, principalUsername?: string, limit?: number, offset?: number, orderBy?: 'username', options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getPrincipalsFromGroup.');
            }
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (principalUsername !== undefined) {
                localVarQueryParameter['principal_username'] = principalUsername;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {'all' | 'any'} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', username?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: 'all' | 'any', orderBy?: string, options: any = {}): RequestArgs {
            const localVarPath = `/groups/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameMatch !== undefined) {
                localVarQueryParameter['name_match'] = nameMatch;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (uuid) {
                localVarQueryParameter['uuid'] = uuid.join(COLLECTION_FORMATS.csv);
            }

            if (roleNames) {
                localVarQueryParameter['role_names'] = roleNames.join(COLLECTION_FORMATS.csv);
            }

            if (roleDiscriminator !== undefined) {
                localVarQueryParameter['role_discriminator'] = roleDiscriminator;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDescription?: string, limit?: number, offset?: number, orderBy?: 'name' | 'modified' | 'policyCount', options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling listRolesForGroup.');
            }
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['role_name'] = roleName;
            }

            if (roleDescription !== undefined) {
                localVarQueryParameter['role_description'] = roleDescription;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Udate a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(uuid: string, group: Group, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling updateGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof group !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(group !== undefined ? group : {}) : (group || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWithPrincipalsAndRoles> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).addRoleToGroup(uuid, groupRoleIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOut> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).createGroup(group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).deleteGroup(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup(uuid: string, usernames: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).deletePrincipalFromGroup(uuid, usernames, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleFromGroup(uuid: string, roles: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).deleteRoleFromGroup(uuid, roles, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWithPrincipalsAndRoles> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).getGroup(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalsFromGroup(uuid: string, principalUsername?: string, limit?: number, offset?: number, orderBy?: 'username', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrincipalPagination> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).getPrincipalsFromGroup(uuid, principalUsername, limit, offset, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {'all' | 'any'} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', username?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: 'all' | 'any', orderBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPagination> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).listGroups(limit, offset, name, nameMatch, scope, username, uuid, roleNames, roleDiscriminator, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDescription?: string, limit?: number, offset?: number, orderBy?: 'name' | 'modified' | 'policyCount', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRolesPagination> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).listRolesForGroup(uuid, exclude, roleName, roleDescription, limit, offset, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Udate a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(uuid: string, group: Group, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOut> {
            const localVarAxiosArgs = GroupApiAxiosParamCreator(configuration).updateGroup(uuid, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any): AxiosPromise<GroupWithPrincipalsAndRoles> {
            return GroupApiFp(configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options)(axios, basePath);
        },
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: any): AxiosPromise<InlineResponse200> {
            return GroupApiFp(configuration).addRoleToGroup(uuid, groupRoleIn, options)(axios, basePath);
        },
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any): AxiosPromise<GroupOut> {
            return GroupApiFp(configuration).createGroup(group, options)(axios, basePath);
        },
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(uuid: string, options?: any): AxiosPromise<void> {
            return GroupApiFp(configuration).deleteGroup(uuid, options)(axios, basePath);
        },
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup(uuid: string, usernames: string, options?: any): AxiosPromise<void> {
            return GroupApiFp(configuration).deletePrincipalFromGroup(uuid, usernames, options)(axios, basePath);
        },
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleFromGroup(uuid: string, roles: string, options?: any): AxiosPromise<void> {
            return GroupApiFp(configuration).deleteRoleFromGroup(uuid, roles, options)(axios, basePath);
        },
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(uuid: string, options?: any): AxiosPromise<GroupWithPrincipalsAndRoles> {
            return GroupApiFp(configuration).getGroup(uuid, options)(axios, basePath);
        },
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalsFromGroup(uuid: string, principalUsername?: string, limit?: number, offset?: number, orderBy?: 'username', options?: any): AxiosPromise<PrincipalPagination> {
            return GroupApiFp(configuration).getPrincipalsFromGroup(uuid, principalUsername, limit, offset, orderBy, options)(axios, basePath);
        },
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {'all' | 'any'} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', username?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: 'all' | 'any', orderBy?: string, options?: any): AxiosPromise<GroupPagination> {
            return GroupApiFp(configuration).listGroups(limit, offset, name, nameMatch, scope, username, uuid, roleNames, roleDiscriminator, orderBy, options)(axios, basePath);
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDescription?: string, limit?: number, offset?: number, orderBy?: 'name' | 'modified' | 'policyCount', options?: any): AxiosPromise<GroupRolesPagination> {
            return GroupApiFp(configuration).listRolesForGroup(uuid, exclude, roleName, roleDescription, limit, offset, orderBy, options)(axios, basePath);
        },
        /**
         *
         * @summary Udate a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(uuid: string, group: Group, options?: any): AxiosPromise<GroupOut> {
            return GroupApiFp(configuration).updateGroup(uuid, group, options)(axios, basePath);
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     *
     * @summary Add a principal to a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any) {
        return GroupApiFp(this.configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Add a role to a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {GroupRoleIn} groupRoleIn Role to add to a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: any) {
        return GroupApiFp(this.configuration).addRoleToGroup(uuid, groupRoleIn, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Create a group in a tenant
     * @param {Group} group Group to create in tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(group: Group, options?: any) {
        return GroupApiFp(this.configuration).createGroup(group, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Delete a group in the tenant
     * @param {string} uuid ID of group to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(uuid: string, options?: any) {
        return GroupApiFp(this.configuration).deleteGroup(uuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Remove a principal from a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {string} usernames A comma separated list of usernames for principals to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deletePrincipalFromGroup(uuid: string, usernames: string, options?: any) {
        return GroupApiFp(this.configuration).deletePrincipalFromGroup(uuid, usernames, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Remove a role from a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteRoleFromGroup(uuid: string, roles: string, options?: any) {
        return GroupApiFp(this.configuration).deleteRoleFromGroup(uuid, roles, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Get a group in the tenant
     * @param {string} uuid ID of group to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(uuid: string, options?: any) {
        return GroupApiFp(this.configuration).getGroup(uuid, options)(this.axios, this.basePath);
    }

    /**
     * By default, responses are sorted in ascending order by username
     * @summary Get a list of principals from a group in the tenant
     * @param {string} uuid ID of group from which to get principals
     * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getPrincipalsFromGroup(uuid: string, principalUsername?: string, limit?: number, offset?: number, orderBy?: 'username', options?: any) {
        return GroupApiFp(this.configuration).getPrincipalsFromGroup(uuid, principalUsername, limit, offset, orderBy, options)(this.axios, this.basePath);
    }

    /**
     * By default, responses are sorted in ascending order by group name
     * @summary List the groups for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name.
     * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
     * @param {string} [username] A username for a principal to filter for groups
     * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
     * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
     * @param {'all' | 'any'} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
     * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listGroups(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', username?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: 'all' | 'any', orderBy?: string, options?: any) {
        return GroupApiFp(this.configuration).listGroups(limit, offset, name, nameMatch, scope, username, uuid, roleNames, roleDiscriminator, orderBy, options)(this.axios, this.basePath);
    }

    /**
     * By default, responses are sorted in ascending order by role name
     * @summary List the roles for a group in the tenant
     * @param {string} uuid ID of group
     * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
     * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
     * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {'name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDescription?: string, limit?: number, offset?: number, orderBy?: 'name' | 'modified' | 'policyCount', options?: any) {
        return GroupApiFp(this.configuration).listRolesForGroup(uuid, exclude, roleName, roleDescription, limit, offset, orderBy, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Udate a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {Group} group Group to update in tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(uuid: string, group: Group, options?: any) {
        return GroupApiFp(this.configuration).updateGroup(uuid, group, options)(this.axios, this.basePath);
    }

}


/**
 * PolicyApi - axios parameter creator
 * @export
 */
export const PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicies(policyIn: PolicyIn, options: any = {}): RequestArgs {
            // verify required parameter 'policyIn' is not null or undefined
            if (policyIn === null || policyIn === undefined) {
                throw new RequiredError('policyIn','Required parameter policyIn was null or undefined when calling createPolicies.');
            }
            const localVarPath = `/policies/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof policyIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(policyIn !== undefined ? policyIn : {}) : (policyIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deletePolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getPolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by policy name
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [groupName] Parameter for filtering resource by group name using string contains search.
         * @param {string} [groupUuid] Parameter for filtering resource by group uuid using UUID exact match.
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(limit?: number, offset?: number, name?: string, scope?: 'account' | 'principal', groupName?: string, groupUuid?: string, orderBy?: string, options: any = {}): RequestArgs {
            const localVarPath = `/policies/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (groupName !== undefined) {
                localVarQueryParameter['group_name'] = groupName;
            }

            if (groupUuid !== undefined) {
                localVarQueryParameter['group_uuid'] = groupUuid;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(uuid: string, policyIn: PolicyIn, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updatePolicy.');
            }
            // verify required parameter 'policyIn' is not null or undefined
            if (policyIn === null || policyIn === undefined) {
                throw new RequiredError('policyIn','Required parameter policyIn was null or undefined when calling updatePolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof policyIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(policyIn !== undefined ? policyIn : {}) : (policyIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyApi - functional programming interface
 * @export
 */
export const PolicyApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicies(policyIn: PolicyIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).createPolicies(policyIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).deletePolicy(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).getPolicy(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by policy name
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [groupName] Parameter for filtering resource by group name using string contains search.
         * @param {string} [groupUuid] Parameter for filtering resource by group uuid using UUID exact match.
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(limit?: number, offset?: number, name?: string, scope?: 'account' | 'principal', groupName?: string, groupUuid?: string, orderBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyPagination> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).listPolicies(limit, offset, name, scope, groupName, groupUuid, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(uuid: string, policyIn: PolicyIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended> {
            const localVarAxiosArgs = PolicyApiAxiosParamCreator(configuration).updatePolicy(uuid, policyIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PolicyApi - factory interface
 * @export
 */
export const PolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicies(policyIn: PolicyIn, options?: any): AxiosPromise<PolicyExtended> {
            return PolicyApiFp(configuration).createPolicies(policyIn, options)(axios, basePath);
        },
        /**
         *
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(uuid: string, options?: any): AxiosPromise<void> {
            return PolicyApiFp(configuration).deletePolicy(uuid, options)(axios, basePath);
        },
        /**
         *
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(uuid: string, options?: any): AxiosPromise<PolicyExtended> {
            return PolicyApiFp(configuration).getPolicy(uuid, options)(axios, basePath);
        },
        /**
         * By default, responses are sorted in ascending order by policy name
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [groupName] Parameter for filtering resource by group name using string contains search.
         * @param {string} [groupUuid] Parameter for filtering resource by group uuid using UUID exact match.
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(limit?: number, offset?: number, name?: string, scope?: 'account' | 'principal', groupName?: string, groupUuid?: string, orderBy?: string, options?: any): AxiosPromise<PolicyPagination> {
            return PolicyApiFp(configuration).listPolicies(limit, offset, name, scope, groupName, groupUuid, orderBy, options)(axios, basePath);
        },
        /**
         *
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(uuid: string, policyIn: PolicyIn, options?: any): AxiosPromise<PolicyExtended> {
            return PolicyApiFp(configuration).updatePolicy(uuid, policyIn, options)(axios, basePath);
        },
    };
};

/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
export class PolicyApi extends BaseAPI {
    /**
     *
     * @summary Create a policy in a tenant
     * @param {PolicyIn} policyIn Policy to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public createPolicies(policyIn: PolicyIn, options?: any) {
        return PolicyApiFp(this.configuration).createPolicies(policyIn, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Delete a policy in the tenant
     * @param {string} uuid ID of policy to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public deletePolicy(uuid: string, options?: any) {
        return PolicyApiFp(this.configuration).deletePolicy(uuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Get a policy in the tenant
     * @param {string} uuid ID of policy to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getPolicy(uuid: string, options?: any) {
        return PolicyApiFp(this.configuration).getPolicy(uuid, options)(this.axios, this.basePath);
    }

    /**
     * By default, responses are sorted in ascending order by policy name
     * @summary List the policies in the tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
     * @param {string} [groupName] Parameter for filtering resource by group name using string contains search.
     * @param {string} [groupUuid] Parameter for filtering resource by group uuid using UUID exact match.
     * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public listPolicies(limit?: number, offset?: number, name?: string, scope?: 'account' | 'principal', groupName?: string, groupUuid?: string, orderBy?: string, options?: any) {
        return PolicyApiFp(this.configuration).listPolicies(limit, offset, name, scope, groupName, groupUuid, orderBy, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Update a policy in the tenant
     * @param {string} uuid ID of policy to update
     * @param {PolicyIn} policyIn Policy to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public updatePolicy(uuid: string, policyIn: PolicyIn, options?: any) {
        return PolicyApiFp(this.configuration).updatePolicy(uuid, policyIn, options)(this.axios, this.basePath);
    }

}


/**
 * PrincipalApi - axios parameter creator
 * @export
 */
export const PrincipalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [usernames] Usernames of principals to get
         * @param {'asc' | 'desc'} [sortOrder] The sort order of the query, either ascending or descending
         * @param {string} [email] Exact e-mail address of principal to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(limit?: number, offset?: number, usernames?: string, sortOrder?: 'asc' | 'desc', email?: string, options: any = {}): RequestArgs {
            const localVarPath = `/principals/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (usernames !== undefined) {
                localVarQueryParameter['usernames'] = usernames;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrincipalApi - functional programming interface
 * @export
 */
export const PrincipalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [usernames] Usernames of principals to get
         * @param {'asc' | 'desc'} [sortOrder] The sort order of the query, either ascending or descending
         * @param {string} [email] Exact e-mail address of principal to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(limit?: number, offset?: number, usernames?: string, sortOrder?: 'asc' | 'desc', email?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrincipalPagination> {
            const localVarAxiosArgs = PrincipalApiAxiosParamCreator(configuration).listPrincipals(limit, offset, usernames, sortOrder, email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PrincipalApi - factory interface
 * @export
 */
export const PrincipalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [usernames] Usernames of principals to get
         * @param {'asc' | 'desc'} [sortOrder] The sort order of the query, either ascending or descending
         * @param {string} [email] Exact e-mail address of principal to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(limit?: number, offset?: number, usernames?: string, sortOrder?: 'asc' | 'desc', email?: string, options?: any): AxiosPromise<PrincipalPagination> {
            return PrincipalApiFp(configuration).listPrincipals(limit, offset, usernames, sortOrder, email, options)(axios, basePath);
        },
    };
};

/**
 * PrincipalApi - object-oriented interface
 * @export
 * @class PrincipalApi
 * @extends {BaseAPI}
 */
export class PrincipalApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by username
     * @summary List the principals for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [usernames] Usernames of principals to get
     * @param {'asc' | 'desc'} [sortOrder] The sort order of the query, either ascending or descending
     * @param {string} [email] Exact e-mail address of principal to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrincipalApi
     */
    public listPrincipals(limit?: number, offset?: number, usernames?: string, sortOrder?: 'asc' | 'desc', email?: string, options?: any) {
        return PrincipalApiFp(this.configuration).listPrincipals(limit, offset, usernames, sortOrder, email, options)(this.axios, this.basePath);
    }

}


/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a roles for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoles(roleIn: RoleIn, options: any = {}): RequestArgs {
            // verify required parameter 'roleIn' is not null or undefined
            if (roleIn === null || roleIn === undefined) {
                throw new RequiredError('roleIn','Required parameter roleIn was null or undefined when calling createRoles.');
            }
            const localVarPath = `/roles/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof roleIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(roleIn !== undefined ? roleIn : {}) : (roleIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAccess(uuid: string, limit?: number, offset?: number, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRoleAccess.');
            }
            const localVarPath = `/roles/{uuid}/access/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<'groups_in' | 'groups_in_count'>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', orderBy?: string, addFields?: Array<'groups_in' | 'groups_in_count'>, username?: string, options: any = {}): RequestArgs {
            const localVarPath = `/roles/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameMatch !== undefined) {
                localVarQueryParameter['name_match'] = nameMatch;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (addFields) {
                localVarQueryParameter['add_fields'] = addFields.join(COLLECTION_FORMATS.csv);
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a Role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(uuid: string, roleWithAccess: RoleWithAccess, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateRole.');
            }
            // verify required parameter 'roleWithAccess' is not null or undefined
            if (roleWithAccess === null || roleWithAccess === undefined) {
                throw new RequiredError('roleWithAccess','Required parameter roleWithAccess was null or undefined when calling updateRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof roleWithAccess !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(roleWithAccess !== undefined ? roleWithAccess : {}) : (roleWithAccess || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a roles for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoles(roleIn: RoleIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).createRoles(roleIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).deleteRole(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).getRole(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAccess(uuid: string, limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPagination> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).getRoleAccess(uuid, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<'groups_in' | 'groups_in_count'>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', orderBy?: string, addFields?: Array<'groups_in' | 'groups_in_count'>, username?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolePaginationDynamic> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).listRoles(limit, offset, name, nameMatch, scope, orderBy, addFields, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a Role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = RoleApiAxiosParamCreator(configuration).updateRole(uuid, roleWithAccess, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a roles for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoles(roleIn: RoleIn, options?: any): AxiosPromise<RoleWithAccess> {
            return RoleApiFp(configuration).createRoles(roleIn, options)(axios, basePath);
        },
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(uuid: string, options?: any): AxiosPromise<void> {
            return RoleApiFp(configuration).deleteRole(uuid, options)(axios, basePath);
        },
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(uuid: string, options?: any): AxiosPromise<RoleWithAccess> {
            return RoleApiFp(configuration).getRole(uuid, options)(axios, basePath);
        },
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAccess(uuid: string, limit?: number, offset?: number, options?: any): AxiosPromise<AccessPagination> {
            return RoleApiFp(configuration).getRoleAccess(uuid, limit, offset, options)(axios, basePath);
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<'groups_in' | 'groups_in_count'>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', orderBy?: string, addFields?: Array<'groups_in' | 'groups_in_count'>, username?: string, options?: any): AxiosPromise<RolePaginationDynamic> {
            return RoleApiFp(configuration).listRoles(limit, offset, name, nameMatch, scope, orderBy, addFields, username, options)(axios, basePath);
        },
        /**
         *
         * @summary Update a Role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any): AxiosPromise<void> {
            return RoleApiFp(configuration).updateRole(uuid, roleWithAccess, options)(axios, basePath);
        },
    };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
    /**
     *
     * @summary Create a roles for a tenant
     * @param {RoleIn} roleIn Role to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public createRoles(roleIn: RoleIn, options?: any) {
        return RoleApiFp(this.configuration).createRoles(roleIn, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Delete a role in the tenant
     * @param {string} uuid ID of role to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public deleteRole(uuid: string, options?: any) {
        return RoleApiFp(this.configuration).deleteRole(uuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Get a role in the tenant
     * @param {string} uuid ID of role to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public getRole(uuid: string, options?: any) {
        return RoleApiFp(this.configuration).getRole(uuid, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Get access for a role in the tenant
     * @param {string} uuid ID of the role
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public getRoleAccess(uuid: string, limit?: number, offset?: number, options?: any) {
        return RoleApiFp(this.configuration).getRoleAccess(uuid, limit, offset, options)(this.axios, this.basePath);
    }

    /**
     * By default, responses are sorted in ascending order by role name
     * @summary List the roles for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name.
     * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
     * @param {string} [orderBy] Parameter for ordering resource by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {Array<'groups_in' | 'groups_in_count'>} [addFields] Parameter for add list of fields to display for roles.
     * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public listRoles(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', orderBy?: string, addFields?: Array<'groups_in' | 'groups_in_count'>, username?: string, options?: any) {
        return RoleApiFp(this.configuration).listRoles(limit, offset, name, nameMatch, scope, orderBy, addFields, username, options)(this.axios, this.basePath);
    }

    /**
     *
     * @summary Update a Role in the tenant
     * @param {string} uuid ID of role to update
     * @param {RoleWithAccess} roleWithAccess Update to a Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any) {
        return RoleApiFp(this.configuration).updateRole(uuid, roleWithAccess, options)(this.axios, this.basePath);
    }

}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options: any = {}): RequestArgs {
            const localVarPath = `/status/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status> {
            const localVarAxiosArgs = StatusApiAxiosParamCreator(configuration).getStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<Status> {
            return StatusApiFp(configuration).getStatus(options)(axios, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     *
     * @summary Obtain server status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatus(options?: any) {
        return StatusApiFp(this.configuration).getStatus(options)(this.axios, this.basePath);
    }

}


