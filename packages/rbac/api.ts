// tslint:disable
/**
 * Role Based Access Control
 * The API for Role Based Access Control.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Access
 */
export interface Access {
    /**
     *
     * @type {string}
     * @memberof Access
     */
    permission: string;
    /**
     *
     * @type {Array<ResourceDefinition>}
     * @memberof Access
     */
    resourceDefinitions: Array<ResourceDefinition>;
}
/**
 *
 * @export
 * @interface AccessPagination
 */
export interface AccessPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof AccessPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof AccessPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<Access>}
     * @memberof AccessPagination
     */
    data: Array<Access>;
}
/**
 *
 * @export
 * @interface AccessPaginationAllOf
 */
export interface AccessPaginationAllOf {
    /**
     *
     * @type {Array<Access>}
     * @memberof AccessPaginationAllOf
     */
    data: Array<Access>;
}
/**
 *
 * @export
 * @interface AdditionalGroup
 */
export interface AdditionalGroup {
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    uuid?: string;
}
/**
 *
 * @export
 * @interface CrossAccountRequest
 */
export interface CrossAccountRequest {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    request_id?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    target_account?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    target_org?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    created?: string;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequest
     */
    start_date?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequest
     */
    end_date?: any;
}
/**
 *
 * @export
 * @interface CrossAccountRequestByAccount
 */
export interface CrossAccountRequestByAccount {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    request_id?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    target_account?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    target_org?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    created?: string;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestByAccount
     */
    start_date?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestByAccount
     */
    end_date?: any;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    first_name?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    last_name?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    email?: string;
}
/**
 *
 * @export
 * @interface CrossAccountRequestByAccountAllOf
 */
export interface CrossAccountRequestByAccountAllOf {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccountAllOf
     */
    first_name?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccountAllOf
     */
    last_name?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccountAllOf
     */
    email?: string;
}
/**
 *
 * @export
 * @interface CrossAccountRequestByUserId
 */
export interface CrossAccountRequestByUserId {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    request_id?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    target_account?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    target_org?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    created?: string;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestByUserId
     */
    start_date?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestByUserId
     */
    end_date?: any;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    user_id?: string;
}
/**
 *
 * @export
 * @interface CrossAccountRequestByUserIdAllOf
 */
export interface CrossAccountRequestByUserIdAllOf {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserIdAllOf
     */
    user_id?: string;
}
/**
 * @type CrossAccountRequestDetail
 * @export
 */
export type CrossAccountRequestDetail = CrossAccountRequestDetailByAccount | CrossAccountRequestDetailByUseId;

/**
 *
 * @export
 * @interface CrossAccountRequestDetailByAccount
 */
export interface CrossAccountRequestDetailByAccount {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    request_id?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    target_account?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    target_org?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    start_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    end_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    created?: string;
    /**
     *
     * @type {Array<CrossAccountRequestWithRolesRoles>}
     * @memberof CrossAccountRequestDetailByAccount
     */
    roles?: Array<CrossAccountRequestWithRolesRoles>;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccount
     */
    first_name?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccount
     */
    last_name?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccount
     */
    email?: any;
}
/**
 *
 * @export
 * @interface CrossAccountRequestDetailByAccountAllOf
 */
export interface CrossAccountRequestDetailByAccountAllOf {
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccountAllOf
     */
    first_name?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccountAllOf
     */
    last_name?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccountAllOf
     */
    email?: any;
}
/**
 *
 * @export
 * @interface CrossAccountRequestDetailByUseId
 */
export interface CrossAccountRequestDetailByUseId {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    request_id?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    target_account?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    target_org?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    start_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    end_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    created?: string;
    /**
     *
     * @type {Array<CrossAccountRequestWithRolesRoles>}
     * @memberof CrossAccountRequestDetailByUseId
     */
    roles?: Array<CrossAccountRequestWithRolesRoles>;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByUseId
     */
    user_id?: any;
}
/**
 *
 * @export
 * @interface CrossAccountRequestDetailByUseIdAllOf
 */
export interface CrossAccountRequestDetailByUseIdAllOf {
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByUseIdAllOf
     */
    user_id?: any;
}
/**
 *
 * @export
 * @interface CrossAccountRequestIn
 */
export interface CrossAccountRequestIn {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestIn
     */
    target_account: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestIn
     */
    target_org?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestIn
     */
    start_date: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestIn
     */
    end_date: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CrossAccountRequestIn
     */
    roles: Array<string>;
}
/**
 *
 * @export
 * @interface CrossAccountRequestOut
 */
export interface CrossAccountRequestOut {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    request_id?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    target_account?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    target_org?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    start_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    end_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    created?: string;
    /**
     *
     * @type {Array<CrossAccountRequestWithRolesRoles>}
     * @memberof CrossAccountRequestOut
     */
    roles?: Array<CrossAccountRequestWithRolesRoles>;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    user_id?: string;
}
/**
 *
 * @export
 * @interface CrossAccountRequestPagination
 */
export interface CrossAccountRequestPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof CrossAccountRequestPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof CrossAccountRequestPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<CrossAccountRequestByAccount | CrossAccountRequestByUserId>}
     * @memberof CrossAccountRequestPagination
     */
    data: Array<CrossAccountRequestByAccount | CrossAccountRequestByUserId>;
}
/**
 *
 * @export
 * @interface CrossAccountRequestPaginationAllOf
 */
export interface CrossAccountRequestPaginationAllOf {
    /**
     *
     * @type {Array<CrossAccountRequestByAccount | CrossAccountRequestByUserId>}
     * @memberof CrossAccountRequestPaginationAllOf
     */
    data: Array<CrossAccountRequestByAccount | CrossAccountRequestByUserId>;
}
/**
 *
 * @export
 * @interface CrossAccountRequestPatch
 */
export interface CrossAccountRequestPatch {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestPatch
     */
    start_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestPatch
     */
    end_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CrossAccountRequestPatch
     */
    roles?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestPatch
     */
    status?: CrossAccountRequestPatchStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CrossAccountRequestPatchStatusEnum {
    Pending = 'pending',
    Approved = 'approved',
    Expired = 'expired',
    Cancelled = 'cancelled',
    Denied = 'denied'
}

/**
 *
 * @export
 * @interface CrossAccountRequestUpdateIn
 */
export interface CrossAccountRequestUpdateIn {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestUpdateIn
     */
    start_date: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestUpdateIn
     */
    end_date: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CrossAccountRequestUpdateIn
     */
    roles: Array<string>;
}
/**
 *
 * @export
 * @interface CrossAccountRequestWithRoles
 */
export interface CrossAccountRequestWithRoles {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    request_id?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    target_account?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    target_org?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    start_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    end_date?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    created?: string;
    /**
     *
     * @type {Array<CrossAccountRequestWithRolesRoles>}
     * @memberof CrossAccountRequestWithRoles
     */
    roles?: Array<CrossAccountRequestWithRolesRoles>;
}
/**
 *
 * @export
 * @interface CrossAccountRequestWithRolesRoles
 */
export interface CrossAccountRequestWithRolesRoles {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRolesRoles
     */
    display_name?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRolesRoles
     */
    description?: string;
    /**
     *
     * @type {Array<Permission>}
     * @memberof CrossAccountRequestWithRolesRoles
     */
    permissions?: Array<Permission>;
}
/**
 *
 * @export
 * @interface Error403
 */
export interface Error403 {
    /**
     *
     * @type {Array<Error403Errors>}
     * @memberof Error403
     */
    errors: Array<Error403Errors>;
}
/**
 *
 * @export
 * @interface Error403Errors
 */
export interface Error403Errors {
    /**
     *
     * @type {string}
     * @memberof Error403Errors
     */
    detail?: string;
    /**
     *
     * @type {string}
     * @memberof Error403Errors
     */
    source?: string;
    /**
     *
     * @type {string}
     * @memberof Error403Errors
     */
    status?: string;
}
/**
 *
 * @export
 * @interface ErrorErrors
 */
export interface ErrorErrors {
    /**
     *
     * @type {string}
     * @memberof ErrorErrors
     */
    detail?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorErrors
     */
    status?: string;
}
/**
 * Error structure for the \"Not Found\" responses.
 * @export
 * @interface ErrorNotFound
 */
export interface ErrorNotFound {
    /**
     *
     * @type {Array<ErrorNotFoundErrors>}
     * @memberof ErrorNotFound
     */
    errors: Array<ErrorNotFoundErrors>;
}
/**
 *
 * @export
 * @interface ErrorNotFoundErrors
 */
export interface ErrorNotFoundErrors {
    /**
     * Detail of the error.
     * @type {string}
     * @memberof ErrorNotFoundErrors
     */
    detail?: string;
    /**
     * Status of the response
     * @type {string}
     * @memberof ErrorNotFoundErrors
     */
    status?: string;
    /**
     * Source of the error.
     * @type {string}
     * @memberof ErrorNotFoundErrors
     */
    source?: string;
}
/**
 *
 * @export
 * @interface Group
 */
export interface Group {
    /**
     *
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    description?: string;
}
/**
 *
 * @export
 * @interface GroupOut
 */
export interface GroupOut {
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    modified: string;
    /**
     *
     * @type {number}
     * @memberof GroupOut
     */
    principalCount?: number;
    /**
     *
     * @type {number}
     * @memberof GroupOut
     */
    roleCount?: number;
    /**
     *
     * @type {boolean}
     * @memberof GroupOut
     */
    system?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupOut
     */
    platform_default?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupOut
     */
    admin_default?: boolean;
}
/**
 *
 * @export
 * @interface GroupOutAllOf
 */
export interface GroupOutAllOf {
    /**
     *
     * @type {number}
     * @memberof GroupOutAllOf
     */
    principalCount?: number;
    /**
     *
     * @type {number}
     * @memberof GroupOutAllOf
     */
    roleCount?: number;
    /**
     *
     * @type {boolean}
     * @memberof GroupOutAllOf
     */
    system?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupOutAllOf
     */
    platform_default?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupOutAllOf
     */
    admin_default?: boolean;
}
/**
 *
 * @export
 * @interface GroupPagination
 */
export interface GroupPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof GroupPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof GroupPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<GroupOut>}
     * @memberof GroupPagination
     */
    data: Array<GroupOut>;
}
/**
 *
 * @export
 * @interface GroupPaginationAllOf
 */
export interface GroupPaginationAllOf {
    /**
     *
     * @type {Array<GroupOut>}
     * @memberof GroupPaginationAllOf
     */
    data: Array<GroupOut>;
}
/**
 *
 * @export
 * @interface GroupPrincipalIn
 */
export interface GroupPrincipalIn {
    /**
     *
     * @type {Array<PrincipalIn>}
     * @memberof GroupPrincipalIn
     */
    principals: Array<PrincipalIn>;
}
/**
 *
 * @export
 * @interface GroupRoleIn
 */
export interface GroupRoleIn {
    /**
     *
     * @type {Array<string>}
     * @memberof GroupRoleIn
     */
    roles: Array<string>;
}
/**
 *
 * @export
 * @interface GroupRolesPagination
 */
export interface GroupRolesPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof GroupRolesPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof GroupRolesPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof GroupRolesPagination
     */
    data: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipals
 */
export interface GroupWithPrincipals {
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    modified: string;
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipals
     */
    principals: Array<Principal>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipalsAllOf
 */
export interface GroupWithPrincipalsAllOf {
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipalsAllOf
     */
    principals: Array<Principal>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipalsAndRoles
 */
export interface GroupWithPrincipalsAndRoles {
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    modified: string;
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipalsAndRoles
     */
    principals: Array<Principal>;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof GroupWithPrincipalsAndRoles
     */
    roles: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipalsAndRolesAllOf
 */
export interface GroupWithPrincipalsAndRolesAllOf {
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipalsAndRolesAllOf
     */
    principals: Array<Principal>;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof GroupWithPrincipalsAndRolesAllOf
     */
    roles: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof InlineResponse200
     */
    data: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface ListPagination
 */
export interface ListPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof ListPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ListPagination
     */
    links?: PaginationLinks;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {Array<ErrorErrors>}
     * @memberof ModelError
     */
    errors: Array<ErrorErrors>;
}
/**
 *
 * @export
 * @interface PaginationLinks
 */
export interface PaginationLinks {
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    first?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    previous?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    next?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    last?: string;
}
/**
 *
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     *
     * @type {number}
     * @memberof PaginationMeta
     */
    count?: number;
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    application?: string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    resource_type?: string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    verb?: string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    permission?: string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    description?: string;
}
/**
 *
 * @export
 * @interface PermissionOptionsPagination
 */
export interface PermissionOptionsPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof PermissionOptionsPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof PermissionOptionsPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<string>}
     * @memberof PermissionOptionsPagination
     */
    data: Array<string>;
}
/**
 *
 * @export
 * @interface PermissionOptionsPaginationAllOf
 */
export interface PermissionOptionsPaginationAllOf {
    /**
     *
     * @type {Array<string>}
     * @memberof PermissionOptionsPaginationAllOf
     */
    data: Array<string>;
}
/**
 *
 * @export
 * @interface PermissionPagination
 */
export interface PermissionPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof PermissionPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof PermissionPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<Permission>}
     * @memberof PermissionPagination
     */
    data: Array<Permission>;
}
/**
 *
 * @export
 * @interface PermissionPaginationAllOf
 */
export interface PermissionPaginationAllOf {
    /**
     *
     * @type {Array<Permission>}
     * @memberof PermissionPaginationAllOf
     */
    data: Array<Permission>;
}
/**
 *
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    description?: string;
}
/**
 *
 * @export
 * @interface PolicyExtended
 */
export interface PolicyExtended {
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    modified: string;
    /**
     *
     * @type {GroupOut}
     * @memberof PolicyExtended
     */
    group: GroupOut;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof PolicyExtended
     */
    roles: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface PolicyExtendedAllOf
 */
export interface PolicyExtendedAllOf {
    /**
     *
     * @type {GroupOut}
     * @memberof PolicyExtendedAllOf
     */
    group: GroupOut;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof PolicyExtendedAllOf
     */
    roles: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface PolicyIn
 */
export interface PolicyIn {
    /**
     *
     * @type {string}
     * @memberof PolicyIn
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof PolicyIn
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof PolicyIn
     */
    group: string;
    /**
     *
     * @type {Array<string>}
     * @memberof PolicyIn
     */
    roles: Array<string>;
}
/**
 *
 * @export
 * @interface PolicyInAllOf
 */
export interface PolicyInAllOf {
    /**
     *
     * @type {string}
     * @memberof PolicyInAllOf
     */
    group: string;
    /**
     *
     * @type {Array<string>}
     * @memberof PolicyInAllOf
     */
    roles: Array<string>;
}
/**
 *
 * @export
 * @interface PolicyPagination
 */
export interface PolicyPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof PolicyPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof PolicyPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<PolicyExtended>}
     * @memberof PolicyPagination
     */
    data: Array<PolicyExtended>;
}
/**
 *
 * @export
 * @interface PolicyPaginationAllOf
 */
export interface PolicyPaginationAllOf {
    /**
     *
     * @type {Array<PolicyExtended>}
     * @memberof PolicyPaginationAllOf
     */
    data: Array<PolicyExtended>;
}
/**
 *
 * @export
 * @interface Principal
 */
export interface Principal {
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    first_name?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    last_name?: string;
    /**
     *
     * @type {boolean}
     * @memberof Principal
     */
    is_active?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Principal
     */
    is_org_admin?: boolean;
    /**
     *
     * @type {string | number}
     * @memberof Principal
     */
    external_source_id?: string | number;
}
/**
 *
 * @export
 * @interface PrincipalIn
 */
export interface PrincipalIn {
    /**
     *
     * @type {string}
     * @memberof PrincipalIn
     */
    username: string;
}
/**
 *
 * @export
 * @interface PrincipalMinimal
 */
export interface PrincipalMinimal {
    /**
     *
     * @type {string}
     * @memberof PrincipalMinimal
     */
    username: string;
}
/**
 *
 * @export
 * @interface PrincipalOut
 */
export interface PrincipalOut {
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    first_name?: string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    last_name?: string;
    /**
     *
     * @type {boolean}
     * @memberof PrincipalOut
     */
    is_active?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PrincipalOut
     */
    is_org_admin?: boolean;
    /**
     *
     * @type {string | number}
     * @memberof PrincipalOut
     */
    external_source_id?: string | number;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    uuid: string;
}
/**
 *
 * @export
 * @interface PrincipalPagination
 */
export interface PrincipalPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof PrincipalPagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof PrincipalPagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<Principal | PrincipalMinimal>}
     * @memberof PrincipalPagination
     */
    data: Array<Principal | PrincipalMinimal>;
}
/**
 *
 * @export
 * @interface PrincipalPaginationAllOf
 */
export interface PrincipalPaginationAllOf {
    /**
     *
     * @type {Array<Principal | PrincipalMinimal>}
     * @memberof PrincipalPaginationAllOf
     */
    data: Array<Principal | PrincipalMinimal>;
}
/**
 *
 * @export
 * @interface ResourceDefinition
 */
export interface ResourceDefinition {
    /**
     *
     * @type {ResourceDefinitionFilter}
     * @memberof ResourceDefinition
     */
    attributeFilter: ResourceDefinitionFilter;
}
/**
 *
 * @export
 * @interface ResourceDefinitionFilter
 */
export interface ResourceDefinitionFilter {
    /**
     *
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    key: string;
    /**
     *
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    operation: ResourceDefinitionFilterOperationEnum;
    /**
     *
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    value: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ResourceDefinitionFilterOperationEnum {
    Equal = 'equal',
    In = 'in'
}

/**
 *
 * @export
 * @interface Role
 */
export interface Role {
    /**
     *
     * @type {string}
     * @memberof Role
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Role
     */
    display_name?: string;
    /**
     *
     * @type {string}
     * @memberof Role
     */
    description?: string;
}
/**
 *
 * @export
 * @interface RoleIn
 */
export interface RoleIn {
    /**
     *
     * @type {string}
     * @memberof RoleIn
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RoleIn
     */
    display_name?: string;
    /**
     *
     * @type {string}
     * @memberof RoleIn
     */
    description?: string;
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleIn
     */
    access: Array<Access>;
}
/**
 *
 * @export
 * @interface RoleInAllOf
 */
export interface RoleInAllOf {
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleInAllOf
     */
    access: Array<Access>;
}
/**
 *
 * @export
 * @interface RoleOut
 */
export interface RoleOut {
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    display_name?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    modified: string;
    /**
     *
     * @type {number}
     * @memberof RoleOut
     */
    policyCount?: number;
    /**
     *
     * @type {number}
     * @memberof RoleOut
     */
    accessCount?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOut
     */
    applications?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOut
     */
    system?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOut
     */
    platform_default?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOut
     */
    admin_default?: boolean;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    external_role_id?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    external_tenant?: string;
}
/**
 *
 * @export
 * @interface RoleOutAllOf
 */
export interface RoleOutAllOf {
    /**
     *
     * @type {number}
     * @memberof RoleOutAllOf
     */
    policyCount?: number;
    /**
     *
     * @type {number}
     * @memberof RoleOutAllOf
     */
    accessCount?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOutAllOf
     */
    applications?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutAllOf
     */
    system?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutAllOf
     */
    platform_default?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutAllOf
     */
    admin_default?: boolean;
    /**
     *
     * @type {string}
     * @memberof RoleOutAllOf
     */
    external_role_id?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutAllOf
     */
    external_tenant?: string;
}
/**
 *
 * @export
 * @interface RoleOutDynamic
 */
export interface RoleOutDynamic {
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    display_name?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    modified: string;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    policyCount: number;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    accessCount: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOutDynamic
     */
    applications: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamic
     */
    system: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamic
     */
    platform_default: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamic
     */
    admin_default: boolean;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    groups_in_count?: number;
    /**
     *
     * @type {Array<AdditionalGroup>}
     * @memberof RoleOutDynamic
     */
    groups_in?: Array<AdditionalGroup>;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    external_role_id?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    external_tenant?: string;
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleOutDynamic
     */
    access?: Array<Access>;
}
/**
 *
 * @export
 * @interface RoleOutDynamicAllOf
 */
export interface RoleOutDynamicAllOf {
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamicAllOf
     */
    policyCount: number;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamicAllOf
     */
    accessCount: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOutDynamicAllOf
     */
    applications: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamicAllOf
     */
    system: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamicAllOf
     */
    platform_default: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamicAllOf
     */
    admin_default: boolean;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamicAllOf
     */
    groups_in_count?: number;
    /**
     *
     * @type {Array<AdditionalGroup>}
     * @memberof RoleOutDynamicAllOf
     */
    groups_in?: Array<AdditionalGroup>;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamicAllOf
     */
    external_role_id?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamicAllOf
     */
    external_tenant?: string;
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleOutDynamicAllOf
     */
    access?: Array<Access>;
}
/**
 *
 * @export
 * @interface RolePagination
 */
export interface RolePagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof RolePagination
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof RolePagination
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof RolePagination
     */
    data: Array<RoleOut>;
}
/**
 *
 * @export
 * @interface RolePaginationDynamic
 */
export interface RolePaginationDynamic {
    /**
     *
     * @type {PaginationMeta}
     * @memberof RolePaginationDynamic
     */
    meta?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof RolePaginationDynamic
     */
    links?: PaginationLinks;
    /**
     *
     * @type {Array<RoleOutDynamic>}
     * @memberof RolePaginationDynamic
     */
    data: Array<RoleOutDynamic>;
}
/**
 *
 * @export
 * @interface RolePaginationDynamicAllOf
 */
export interface RolePaginationDynamicAllOf {
    /**
     *
     * @type {Array<RoleOutDynamic>}
     * @memberof RolePaginationDynamicAllOf
     */
    data: Array<RoleOutDynamic>;
}
/**
 *
 * @export
 * @interface RolePatch
 */
export interface RolePatch {
    /**
     *
     * @type {string}
     * @memberof RolePatch
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof RolePatch
     */
    display_name?: string;
    /**
     *
     * @type {string}
     * @memberof RolePatch
     */
    description?: string;
}
/**
 *
 * @export
 * @interface RoleWithAccess
 */
export interface RoleWithAccess {
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    display_name?: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    uuid: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    modified: string;
    /**
     *
     * @type {number}
     * @memberof RoleWithAccess
     */
    policyCount?: number;
    /**
     *
     * @type {number}
     * @memberof RoleWithAccess
     */
    accessCount?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleWithAccess
     */
    applications?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleWithAccess
     */
    system?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleWithAccess
     */
    platform_default?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleWithAccess
     */
    admin_default?: boolean;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    external_role_id?: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    external_tenant?: string;
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleWithAccess
     */
    access: Array<Access>;
}
/**
 *
 * @export
 * @interface Status
 */
export interface Status {
    /**
     *
     * @type {number}
     * @memberof Status
     */
    api_version: number;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    commit?: string;
}
/**
 *
 * @export
 * @interface Timestamped
 */
export interface Timestamped {
    /**
     *
     * @type {string}
     * @memberof Timestamped
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof Timestamped
     */
    modified: string;
}
/**
 *
 * @export
 * @interface UUID
 */
export interface UUID {
    /**
     *
     * @type {string}
     * @memberof UUID
     */
    uuid: string;
}

/**
 * AccessApi - axios parameter creator
 * @export
 */
export const AccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {'application' | 'resource_type' | 'verb'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {'enabled' | 'disabled' | 'all'} [status] Set the status of users to get back.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess: async (application: string, username?: string, orderBy?: 'application' | 'resource_type' | 'verb', status?: 'enabled' | 'disabled' | 'all', limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'application' is not null or undefined
            if (application === null || application === undefined) {
                throw new RequiredError('application','Required parameter application was null or undefined when calling getPrincipalAccess.');
            }
            const localVarPath = `/access/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {'application' | 'resource_type' | 'verb'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {'enabled' | 'disabled' | 'all'} [status] Set the status of users to get back.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrincipalAccess(application: string, username?: string, orderBy?: 'application' | 'resource_type' | 'verb', status?: 'enabled' | 'disabled' | 'all', limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPagination>> {
            const localVarAxiosArgs = await AccessApiAxiosParamCreator(configuration).getPrincipalAccess(application, username, orderBy, status, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {'application' | 'resource_type' | 'verb'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {'enabled' | 'disabled' | 'all'} [status] Set the status of users to get back.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess(application: string, username?: string, orderBy?: 'application' | 'resource_type' | 'verb', status?: 'enabled' | 'disabled' | 'all', limit?: number, offset?: number, options?: any): AxiosPromise<AccessPagination> {
            return AccessApiFp(configuration).getPrincipalAccess(application, username, orderBy, status, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * Access responses are sorted in ascending order by an ID internal to the database
     * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
     * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
     * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
     * @param {'application' | 'resource_type' | 'verb'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
     * @param {'enabled' | 'disabled' | 'all'} [status] Set the status of users to get back.
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public getPrincipalAccess(application: string, username?: string, orderBy?: 'application' | 'resource_type' | 'verb', status?: 'enabled' | 'disabled' | 'all', limit?: number, offset?: number, options?: any) {
        return AccessApiFp(this.configuration).getPrincipalAccess(application, username, orderBy, status, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CrossAccountRequestApi - axios parameter creator
 * @export
 */
export const CrossAccountRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a cross account request
         * @param {CrossAccountRequestIn} crossAccountRequestIn CrossAccountRequest to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCrossAccountRequests: async (crossAccountRequestIn: CrossAccountRequestIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'crossAccountRequestIn' is not null or undefined
            if (crossAccountRequestIn === null || crossAccountRequestIn === undefined) {
                throw new RequiredError('crossAccountRequestIn','Required parameter crossAccountRequestIn was null or undefined when calling createCrossAccountRequests.');
            }
            const localVarPath = `/cross-account-requests/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof crossAccountRequestIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(crossAccountRequestIn !== undefined ? crossAccountRequestIn : {}) : (crossAccountRequestIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {'user_id' | 'target_org'} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {'true'} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossAccountRequest: async (uuid: string, queryBy?: 'user_id' | 'target_org', account?: string, approvedOnly?: 'true', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getCrossAccountRequest.');
            }
            const localVarPath = `/cross-account-requests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (queryBy !== undefined) {
                localVarQueryParameter['query_by'] = queryBy;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (approvedOnly !== undefined) {
                localVarQueryParameter['approved_only'] = approvedOnly;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by created_at
         * @summary List the cross account requests for a user or account
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'user_id' | 'target_org'} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {string} [orgId] Parameter for filtering resource by an org id. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by org id.
         * @param {'true'} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {'pending' | 'approved' | 'denied' | 'cancelled' | 'expired'} [status] Parameter for filtering resource based on status.
         * @param {'request_id' | 'start_date' | 'end_date' | 'created' | 'modified' | 'status'} [orderBy] Parameter for ordering by field. For inverse ordering, use \&#39;-\&#39;, e.g. ?order_by&#x3D;-start_date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrossAccountRequests: async (limit?: number, offset?: number, queryBy?: 'user_id' | 'target_org', account?: string, orgId?: string, approvedOnly?: 'true', status?: 'pending' | 'approved' | 'denied' | 'cancelled' | 'expired', orderBy?: 'request_id' | 'start_date' | 'end_date' | 'created' | 'modified' | 'status', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/cross-account-requests/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (queryBy !== undefined) {
                localVarQueryParameter['query_by'] = queryBy;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['org_id'] = orgId;
            }

            if (approvedOnly !== undefined) {
                localVarQueryParameter['approved_only'] = approvedOnly;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch the start_date/end_date/roles of an existing request. Could be used by TAM requestor to cancel request or target account admin to approve/deny request.
         * @summary Patch a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestPatch} crossAccountRequestPatch Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCrossAccountRequest: async (uuid: string, crossAccountRequestPatch: CrossAccountRequestPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling patchCrossAccountRequest.');
            }
            // verify required parameter 'crossAccountRequestPatch' is not null or undefined
            if (crossAccountRequestPatch === null || crossAccountRequestPatch === undefined) {
                throw new RequiredError('crossAccountRequestPatch','Required parameter crossAccountRequestPatch was null or undefined when calling patchCrossAccountRequest.');
            }
            const localVarPath = `/cross-account-requests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof crossAccountRequestPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(crossAccountRequestPatch !== undefined ? crossAccountRequestPatch : {}) : (crossAccountRequestPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For TAM requestor to update the start_date/end_date/roles of an existing cross account request.
         * @summary Update a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestUpdateIn} crossAccountRequestUpdateIn Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCrossAccountRequest: async (uuid: string, crossAccountRequestUpdateIn: CrossAccountRequestUpdateIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling putCrossAccountRequest.');
            }
            // verify required parameter 'crossAccountRequestUpdateIn' is not null or undefined
            if (crossAccountRequestUpdateIn === null || crossAccountRequestUpdateIn === undefined) {
                throw new RequiredError('crossAccountRequestUpdateIn','Required parameter crossAccountRequestUpdateIn was null or undefined when calling putCrossAccountRequest.');
            }
            const localVarPath = `/cross-account-requests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof crossAccountRequestUpdateIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(crossAccountRequestUpdateIn !== undefined ? crossAccountRequestUpdateIn : {}) : (crossAccountRequestUpdateIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrossAccountRequestApi - functional programming interface
 * @export
 */
export const CrossAccountRequestApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a cross account request
         * @param {CrossAccountRequestIn} crossAccountRequestIn CrossAccountRequest to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCrossAccountRequests(crossAccountRequestIn: CrossAccountRequestIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestOut>> {
            const localVarAxiosArgs = await CrossAccountRequestApiAxiosParamCreator(configuration).createCrossAccountRequests(crossAccountRequestIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {'user_id' | 'target_org'} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {'true'} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrossAccountRequest(uuid: string, queryBy?: 'user_id' | 'target_org', account?: string, approvedOnly?: 'true', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestDetail>> {
            const localVarAxiosArgs = await CrossAccountRequestApiAxiosParamCreator(configuration).getCrossAccountRequest(uuid, queryBy, account, approvedOnly, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by created_at
         * @summary List the cross account requests for a user or account
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'user_id' | 'target_org'} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {string} [orgId] Parameter for filtering resource by an org id. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by org id.
         * @param {'true'} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {'pending' | 'approved' | 'denied' | 'cancelled' | 'expired'} [status] Parameter for filtering resource based on status.
         * @param {'request_id' | 'start_date' | 'end_date' | 'created' | 'modified' | 'status'} [orderBy] Parameter for ordering by field. For inverse ordering, use \&#39;-\&#39;, e.g. ?order_by&#x3D;-start_date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCrossAccountRequests(limit?: number, offset?: number, queryBy?: 'user_id' | 'target_org', account?: string, orgId?: string, approvedOnly?: 'true', status?: 'pending' | 'approved' | 'denied' | 'cancelled' | 'expired', orderBy?: 'request_id' | 'start_date' | 'end_date' | 'created' | 'modified' | 'status', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestPagination>> {
            const localVarAxiosArgs = await CrossAccountRequestApiAxiosParamCreator(configuration).listCrossAccountRequests(limit, offset, queryBy, account, orgId, approvedOnly, status, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patch the start_date/end_date/roles of an existing request. Could be used by TAM requestor to cancel request or target account admin to approve/deny request.
         * @summary Patch a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestPatch} crossAccountRequestPatch Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCrossAccountRequest(uuid: string, crossAccountRequestPatch: CrossAccountRequestPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestDetail>> {
            const localVarAxiosArgs = await CrossAccountRequestApiAxiosParamCreator(configuration).patchCrossAccountRequest(uuid, crossAccountRequestPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * For TAM requestor to update the start_date/end_date/roles of an existing cross account request.
         * @summary Update a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestUpdateIn} crossAccountRequestUpdateIn Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCrossAccountRequest(uuid: string, crossAccountRequestUpdateIn: CrossAccountRequestUpdateIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestDetail>> {
            const localVarAxiosArgs = await CrossAccountRequestApiAxiosParamCreator(configuration).putCrossAccountRequest(uuid, crossAccountRequestUpdateIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CrossAccountRequestApi - factory interface
 * @export
 */
export const CrossAccountRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a cross account request
         * @param {CrossAccountRequestIn} crossAccountRequestIn CrossAccountRequest to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCrossAccountRequests(crossAccountRequestIn: CrossAccountRequestIn, options?: any): AxiosPromise<CrossAccountRequestOut> {
            return CrossAccountRequestApiFp(configuration).createCrossAccountRequests(crossAccountRequestIn, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {'user_id' | 'target_org'} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {'true'} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossAccountRequest(uuid: string, queryBy?: 'user_id' | 'target_org', account?: string, approvedOnly?: 'true', options?: any): AxiosPromise<CrossAccountRequestDetail> {
            return CrossAccountRequestApiFp(configuration).getCrossAccountRequest(uuid, queryBy, account, approvedOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, responses are sorted in ascending order by created_at
         * @summary List the cross account requests for a user or account
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'user_id' | 'target_org'} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {string} [orgId] Parameter for filtering resource by an org id. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by org id.
         * @param {'true'} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {'pending' | 'approved' | 'denied' | 'cancelled' | 'expired'} [status] Parameter for filtering resource based on status.
         * @param {'request_id' | 'start_date' | 'end_date' | 'created' | 'modified' | 'status'} [orderBy] Parameter for ordering by field. For inverse ordering, use \&#39;-\&#39;, e.g. ?order_by&#x3D;-start_date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrossAccountRequests(limit?: number, offset?: number, queryBy?: 'user_id' | 'target_org', account?: string, orgId?: string, approvedOnly?: 'true', status?: 'pending' | 'approved' | 'denied' | 'cancelled' | 'expired', orderBy?: 'request_id' | 'start_date' | 'end_date' | 'created' | 'modified' | 'status', options?: any): AxiosPromise<CrossAccountRequestPagination> {
            return CrossAccountRequestApiFp(configuration).listCrossAccountRequests(limit, offset, queryBy, account, orgId, approvedOnly, status, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch the start_date/end_date/roles of an existing request. Could be used by TAM requestor to cancel request or target account admin to approve/deny request.
         * @summary Patch a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestPatch} crossAccountRequestPatch Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCrossAccountRequest(uuid: string, crossAccountRequestPatch: CrossAccountRequestPatch, options?: any): AxiosPromise<CrossAccountRequestDetail> {
            return CrossAccountRequestApiFp(configuration).patchCrossAccountRequest(uuid, crossAccountRequestPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * For TAM requestor to update the start_date/end_date/roles of an existing cross account request.
         * @summary Update a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestUpdateIn} crossAccountRequestUpdateIn Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCrossAccountRequest(uuid: string, crossAccountRequestUpdateIn: CrossAccountRequestUpdateIn, options?: any): AxiosPromise<CrossAccountRequestDetail> {
            return CrossAccountRequestApiFp(configuration).putCrossAccountRequest(uuid, crossAccountRequestUpdateIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CrossAccountRequestApi - object-oriented interface
 * @export
 * @class CrossAccountRequestApi
 * @extends {BaseAPI}
 */
export class CrossAccountRequestApi extends BaseAPI {
    /**
     *
     * @summary Create a cross account request
     * @param {CrossAccountRequestIn} crossAccountRequestIn CrossAccountRequest to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrossAccountRequestApi
     */
    public createCrossAccountRequests(crossAccountRequestIn: CrossAccountRequestIn, options?: any) {
        return CrossAccountRequestApiFp(this.configuration).createCrossAccountRequests(crossAccountRequestIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a cross account request
     * @param {string} uuid ID of cross account request to get
     * @param {'user_id' | 'target_org'} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
     * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
     * @param {'true'} [approvedOnly] Parameter for filtering resource which have been approved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrossAccountRequestApi
     */
    public getCrossAccountRequest(uuid: string, queryBy?: 'user_id' | 'target_org', account?: string, approvedOnly?: 'true', options?: any) {
        return CrossAccountRequestApiFp(this.configuration).getCrossAccountRequest(uuid, queryBy, account, approvedOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, responses are sorted in ascending order by created_at
     * @summary List the cross account requests for a user or account
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {'user_id' | 'target_org'} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
     * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
     * @param {string} [orgId] Parameter for filtering resource by an org id. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by org id.
     * @param {'true'} [approvedOnly] Parameter for filtering resource which have been approved.
     * @param {'pending' | 'approved' | 'denied' | 'cancelled' | 'expired'} [status] Parameter for filtering resource based on status.
     * @param {'request_id' | 'start_date' | 'end_date' | 'created' | 'modified' | 'status'} [orderBy] Parameter for ordering by field. For inverse ordering, use \&#39;-\&#39;, e.g. ?order_by&#x3D;-start_date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrossAccountRequestApi
     */
    public listCrossAccountRequests(limit?: number, offset?: number, queryBy?: 'user_id' | 'target_org', account?: string, orgId?: string, approvedOnly?: 'true', status?: 'pending' | 'approved' | 'denied' | 'cancelled' | 'expired', orderBy?: 'request_id' | 'start_date' | 'end_date' | 'created' | 'modified' | 'status', options?: any) {
        return CrossAccountRequestApiFp(this.configuration).listCrossAccountRequests(limit, offset, queryBy, account, orgId, approvedOnly, status, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch the start_date/end_date/roles of an existing request. Could be used by TAM requestor to cancel request or target account admin to approve/deny request.
     * @summary Patch a cross account request
     * @param {string} uuid ID of cross account request to get
     * @param {CrossAccountRequestPatch} crossAccountRequestPatch Updates to CrossAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrossAccountRequestApi
     */
    public patchCrossAccountRequest(uuid: string, crossAccountRequestPatch: CrossAccountRequestPatch, options?: any) {
        return CrossAccountRequestApiFp(this.configuration).patchCrossAccountRequest(uuid, crossAccountRequestPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For TAM requestor to update the start_date/end_date/roles of an existing cross account request.
     * @summary Update a cross account request
     * @param {string} uuid ID of cross account request to get
     * @param {CrossAccountRequestUpdateIn} crossAccountRequestUpdateIn Updates to CrossAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrossAccountRequestApi
     */
    public putCrossAccountRequest(uuid: string, crossAccountRequestUpdateIn: CrossAccountRequestUpdateIn, options?: any) {
        return CrossAccountRequestApiFp(this.configuration).putCrossAccountRequest(uuid, crossAccountRequestUpdateIn, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup: async (uuid: string, groupPrincipalIn: GroupPrincipalIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling addPrincipalToGroup.');
            }
            // verify required parameter 'groupPrincipalIn' is not null or undefined
            if (groupPrincipalIn === null || groupPrincipalIn === undefined) {
                throw new RequiredError('groupPrincipalIn','Required parameter groupPrincipalIn was null or undefined when calling addPrincipalToGroup.');
            }
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof groupPrincipalIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(groupPrincipalIn !== undefined ? groupPrincipalIn : {}) : (groupPrincipalIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToGroup: async (uuid: string, groupRoleIn: GroupRoleIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling addRoleToGroup.');
            }
            // verify required parameter 'groupRoleIn' is not null or undefined
            if (groupRoleIn === null || groupRoleIn === undefined) {
                throw new RequiredError('groupRoleIn','Required parameter groupRoleIn was null or undefined when calling addRoleToGroup.');
            }
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof groupRoleIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(groupRoleIn !== undefined ? groupRoleIn : {}) : (groupRoleIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling createGroup.');
            }
            const localVarPath = `/groups/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof group !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(group !== undefined ? group : {}) : (group || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup: async (uuid: string, usernames: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deletePrincipalFromGroup.');
            }
            // verify required parameter 'usernames' is not null or undefined
            if (usernames === null || usernames === undefined) {
                throw new RequiredError('usernames','Required parameter usernames was null or undefined when calling deletePrincipalFromGroup.');
            }
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (usernames !== undefined) {
                localVarQueryParameter['usernames'] = usernames;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleFromGroup: async (uuid: string, roles: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRoleFromGroup.');
            }
            // verify required parameter 'roles' is not null or undefined
            if (roles === null || roles === undefined) {
                throw new RequiredError('roles','Required parameter roles was null or undefined when calling deleteRoleFromGroup.');
            }
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {'true' | 'false'} [adminOnly] Get only admin users within an account.
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {'service-account' | 'user'} [principalType] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalsFromGroup: async (uuid: string, adminOnly?: 'true' | 'false', principalUsername?: string, limit?: number, offset?: number, orderBy?: 'username', usernameOnly?: boolean, principalType?: 'service-account' | 'user', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getPrincipalsFromGroup.');
            }
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (adminOnly !== undefined) {
                localVarQueryParameter['admin_only'] = adminOnly;
            }

            if (principalUsername !== undefined) {
                localVarQueryParameter['principal_username'] = principalUsername;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (usernameOnly !== undefined) {
                localVarQueryParameter['username_only'] = usernameOnly;
            }

            if (principalType !== undefined) {
                localVarQueryParameter['principal_type'] = principalType;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [excludeUsername] A username for a principal to filter for groups where principal is not a member and can be added manually
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {'all' | 'any'} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {'name' | 'modified' | 'principalCount' | 'policyCount'} [orderBy] Parameter for ordering groups by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {boolean} [platformDefault] An optional flag to return either platform default or non-platform default groups.
         * @param {boolean} [adminDefault] An optional flag to return either admin default or non-admin default groups.
         * @param {boolean} [system] An optional flag to return either system or non-system groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', username?: string, excludeUsername?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: 'all' | 'any', orderBy?: 'name' | 'modified' | 'principalCount' | 'policyCount', platformDefault?: boolean, adminDefault?: boolean, system?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameMatch !== undefined) {
                localVarQueryParameter['name_match'] = nameMatch;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (excludeUsername !== undefined) {
                localVarQueryParameter['exclude_username'] = excludeUsername;
            }

            if (uuid) {
                localVarQueryParameter['uuid'] = uuid.join(COLLECTION_FORMATS.csv);
            }

            if (roleNames) {
                localVarQueryParameter['role_names'] = roleNames.join(COLLECTION_FORMATS.csv);
            }

            if (roleDiscriminator !== undefined) {
                localVarQueryParameter['role_discriminator'] = roleDiscriminator;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (platformDefault !== undefined) {
                localVarQueryParameter['platform_default'] = platformDefault;
            }

            if (adminDefault !== undefined) {
                localVarQueryParameter['admin_default'] = adminDefault;
            }

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDisplayName] Parameter for filtering group roles by role &#x60;display_name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {boolean} [roleSystem] Parameter for filtering group roles by system flag.
         * @param {string} [roleExternalTenant] Parameter for filtering group roles by role &#x60;external_tenant&#x60; using string search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'name' | 'display_name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRolesForGroup: async (uuid: string, exclude?: boolean, roleName?: string, roleDisplayName?: string, roleDescription?: string, roleSystem?: boolean, roleExternalTenant?: string, limit?: number, offset?: number, orderBy?: 'name' | 'display_name' | 'modified' | 'policyCount', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling listRolesForGroup.');
            }
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['role_name'] = roleName;
            }

            if (roleDisplayName !== undefined) {
                localVarQueryParameter['role_display_name'] = roleDisplayName;
            }

            if (roleDescription !== undefined) {
                localVarQueryParameter['role_description'] = roleDescription;
            }

            if (roleSystem !== undefined) {
                localVarQueryParameter['role_system'] = roleSystem;
            }

            if (roleExternalTenant !== undefined) {
                localVarQueryParameter['role_external_tenant'] = roleExternalTenant;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (uuid: string, group: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling updateGroup.');
            }
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof group !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(group !== undefined ? group : {}) : (group || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWithPrincipalsAndRoles>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).addRoleToGroup(uuid, groupRoleIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOut>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).createGroup(group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).deleteGroup(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrincipalFromGroup(uuid: string, usernames: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).deletePrincipalFromGroup(uuid, usernames, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleFromGroup(uuid: string, roles: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).deleteRoleFromGroup(uuid, roles, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWithPrincipalsAndRoles>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).getGroup(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {'true' | 'false'} [adminOnly] Get only admin users within an account.
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {'service-account' | 'user'} [principalType] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrincipalsFromGroup(uuid: string, adminOnly?: 'true' | 'false', principalUsername?: string, limit?: number, offset?: number, orderBy?: 'username', usernameOnly?: boolean, principalType?: 'service-account' | 'user', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrincipalPagination>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).getPrincipalsFromGroup(uuid, adminOnly, principalUsername, limit, offset, orderBy, usernameOnly, principalType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [excludeUsername] A username for a principal to filter for groups where principal is not a member and can be added manually
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {'all' | 'any'} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {'name' | 'modified' | 'principalCount' | 'policyCount'} [orderBy] Parameter for ordering groups by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {boolean} [platformDefault] An optional flag to return either platform default or non-platform default groups.
         * @param {boolean} [adminDefault] An optional flag to return either admin default or non-admin default groups.
         * @param {boolean} [system] An optional flag to return either system or non-system groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', username?: string, excludeUsername?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: 'all' | 'any', orderBy?: 'name' | 'modified' | 'principalCount' | 'policyCount', platformDefault?: boolean, adminDefault?: boolean, system?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPagination>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).listGroups(limit, offset, name, nameMatch, scope, username, excludeUsername, uuid, roleNames, roleDiscriminator, orderBy, platformDefault, adminDefault, system, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDisplayName] Parameter for filtering group roles by role &#x60;display_name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {boolean} [roleSystem] Parameter for filtering group roles by system flag.
         * @param {string} [roleExternalTenant] Parameter for filtering group roles by role &#x60;external_tenant&#x60; using string search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'name' | 'display_name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDisplayName?: string, roleDescription?: string, roleSystem?: boolean, roleExternalTenant?: string, limit?: number, offset?: number, orderBy?: 'name' | 'display_name' | 'modified' | 'policyCount', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRolesPagination>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).listRolesForGroup(uuid, exclude, roleName, roleDisplayName, roleDescription, roleSystem, roleExternalTenant, limit, offset, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(uuid: string, group: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOut>> {
            const localVarAxiosArgs = await GroupApiAxiosParamCreator(configuration).updateGroup(uuid, group, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any): AxiosPromise<GroupWithPrincipalsAndRoles> {
            return GroupApiFp(configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: any): AxiosPromise<InlineResponse200> {
            return GroupApiFp(configuration).addRoleToGroup(uuid, groupRoleIn, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any): AxiosPromise<GroupOut> {
            return GroupApiFp(configuration).createGroup(group, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(uuid: string, options?: any): AxiosPromise<void> {
            return GroupApiFp(configuration).deleteGroup(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} usernames A comma separated list of usernames for principals to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup(uuid: string, usernames: string, options?: any): AxiosPromise<void> {
            return GroupApiFp(configuration).deletePrincipalFromGroup(uuid, usernames, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleFromGroup(uuid: string, roles: string, options?: any): AxiosPromise<void> {
            return GroupApiFp(configuration).deleteRoleFromGroup(uuid, roles, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(uuid: string, options?: any): AxiosPromise<GroupWithPrincipalsAndRoles> {
            return GroupApiFp(configuration).getGroup(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {'true' | 'false'} [adminOnly] Get only admin users within an account.
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {'service-account' | 'user'} [principalType] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalsFromGroup(uuid: string, adminOnly?: 'true' | 'false', principalUsername?: string, limit?: number, offset?: number, orderBy?: 'username', usernameOnly?: boolean, principalType?: 'service-account' | 'user', options?: any): AxiosPromise<PrincipalPagination> {
            return GroupApiFp(configuration).getPrincipalsFromGroup(uuid, adminOnly, principalUsername, limit, offset, orderBy, usernameOnly, principalType, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [excludeUsername] A username for a principal to filter for groups where principal is not a member and can be added manually
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {'all' | 'any'} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {'name' | 'modified' | 'principalCount' | 'policyCount'} [orderBy] Parameter for ordering groups by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {boolean} [platformDefault] An optional flag to return either platform default or non-platform default groups.
         * @param {boolean} [adminDefault] An optional flag to return either admin default or non-admin default groups.
         * @param {boolean} [system] An optional flag to return either system or non-system groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', username?: string, excludeUsername?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: 'all' | 'any', orderBy?: 'name' | 'modified' | 'principalCount' | 'policyCount', platformDefault?: boolean, adminDefault?: boolean, system?: boolean, options?: any): AxiosPromise<GroupPagination> {
            return GroupApiFp(configuration).listGroups(limit, offset, name, nameMatch, scope, username, excludeUsername, uuid, roleNames, roleDiscriminator, orderBy, platformDefault, adminDefault, system, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDisplayName] Parameter for filtering group roles by role &#x60;display_name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {boolean} [roleSystem] Parameter for filtering group roles by system flag.
         * @param {string} [roleExternalTenant] Parameter for filtering group roles by role &#x60;external_tenant&#x60; using string search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'name' | 'display_name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDisplayName?: string, roleDescription?: string, roleSystem?: boolean, roleExternalTenant?: string, limit?: number, offset?: number, orderBy?: 'name' | 'display_name' | 'modified' | 'policyCount', options?: any): AxiosPromise<GroupRolesPagination> {
            return GroupApiFp(configuration).listRolesForGroup(uuid, exclude, roleName, roleDisplayName, roleDescription, roleSystem, roleExternalTenant, limit, offset, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(uuid: string, group: Group, options?: any): AxiosPromise<GroupOut> {
            return GroupApiFp(configuration).updateGroup(uuid, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     *
     * @summary Add a principal to a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any) {
        return GroupApiFp(this.configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Add a role to a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {GroupRoleIn} groupRoleIn Role to add to a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: any) {
        return GroupApiFp(this.configuration).addRoleToGroup(uuid, groupRoleIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create a group in a tenant
     * @param {Group} group Group to create in tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(group: Group, options?: any) {
        return GroupApiFp(this.configuration).createGroup(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a group in the tenant
     * @param {string} uuid ID of group to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(uuid: string, options?: any) {
        return GroupApiFp(this.configuration).deleteGroup(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Remove a principal from a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {string} usernames A comma separated list of usernames for principals to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deletePrincipalFromGroup(uuid: string, usernames: string, options?: any) {
        return GroupApiFp(this.configuration).deletePrincipalFromGroup(uuid, usernames, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Remove a role from a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteRoleFromGroup(uuid: string, roles: string, options?: any) {
        return GroupApiFp(this.configuration).deleteRoleFromGroup(uuid, roles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a group in the tenant
     * @param {string} uuid ID of group to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(uuid: string, options?: any) {
        return GroupApiFp(this.configuration).getGroup(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, responses are sorted in ascending order by username
     * @summary Get a list of principals from a group in the tenant
     * @param {string} uuid ID of group from which to get principals
     * @param {'true' | 'false'} [adminOnly] Get only admin users within an account.
     * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
     * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
     * @param {'service-account' | 'user'} [principalType] Parameter for selecting the type of principal to be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getPrincipalsFromGroup(uuid: string, adminOnly?: 'true' | 'false', principalUsername?: string, limit?: number, offset?: number, orderBy?: 'username', usernameOnly?: boolean, principalType?: 'service-account' | 'user', options?: any) {
        return GroupApiFp(this.configuration).getPrincipalsFromGroup(uuid, adminOnly, principalUsername, limit, offset, orderBy, usernameOnly, principalType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, responses are sorted in ascending order by group name
     * @summary List the groups for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
     * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
     * @param {string} [username] A username for a principal to filter for groups
     * @param {string} [excludeUsername] A username for a principal to filter for groups where principal is not a member and can be added manually
     * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
     * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
     * @param {'all' | 'any'} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
     * @param {'name' | 'modified' | 'principalCount' | 'policyCount'} [orderBy] Parameter for ordering groups by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {boolean} [platformDefault] An optional flag to return either platform default or non-platform default groups.
     * @param {boolean} [adminDefault] An optional flag to return either admin default or non-admin default groups.
     * @param {boolean} [system] An optional flag to return either system or non-system groups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listGroups(limit?: number, offset?: number, name?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', username?: string, excludeUsername?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: 'all' | 'any', orderBy?: 'name' | 'modified' | 'principalCount' | 'policyCount', platformDefault?: boolean, adminDefault?: boolean, system?: boolean, options?: any) {
        return GroupApiFp(this.configuration).listGroups(limit, offset, name, nameMatch, scope, username, excludeUsername, uuid, roleNames, roleDiscriminator, orderBy, platformDefault, adminDefault, system, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, responses are sorted in ascending order by role name
     * @summary List the roles for a group in the tenant
     * @param {string} uuid ID of group
     * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
     * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
     * @param {string} [roleDisplayName] Parameter for filtering group roles by role &#x60;display_name&#x60; using string contains search.
     * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
     * @param {boolean} [roleSystem] Parameter for filtering group roles by system flag.
     * @param {string} [roleExternalTenant] Parameter for filtering group roles by role &#x60;external_tenant&#x60; using string search.
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {'name' | 'display_name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDisplayName?: string, roleDescription?: string, roleSystem?: boolean, roleExternalTenant?: string, limit?: number, offset?: number, orderBy?: 'name' | 'display_name' | 'modified' | 'policyCount', options?: any) {
        return GroupApiFp(this.configuration).listRolesForGroup(uuid, exclude, roleName, roleDisplayName, roleDescription, roleSystem, roleExternalTenant, limit, offset, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {Group} group Group to update in tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(uuid: string, group: Group, options?: any) {
        return GroupApiFp(this.configuration).updateGroup(uuid, group, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PermissionApi - axios parameter creator
 * @export
 */
export const PermissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, options of application is returned. And could be resource_type or verb on demand.
         * @summary List the available options for fields of permissions for a tenant
         * @param {'application' | 'resource_type' | 'verb'} field specify which fields of permission to display
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [application] Filter returned options based on application. You may also use a comma-separated list to filter on multiple applications.
         * @param {string} [resourceType] Filter returned options based on resource_type. You may also use a comma-separated list to filter on multiple resource_types.
         * @param {string} [verb] Filter returned options based on verb. You may also use a comma-separated list to filter on multiple verbs.
         * @param {'true' | 'false'} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission option with a global allowance on the supplied \&#39;?field&#x3D;\&#39; value of \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {'true' | 'false'} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionOptions: async (field: 'application' | 'resource_type' | 'verb', limit?: number, offset?: number, application?: string, resourceType?: string, verb?: string, excludeGlobals?: 'true' | 'false', allowedOnly?: 'true' | 'false', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'field' is not null or undefined
            if (field === null || field === undefined) {
                throw new RequiredError('field','Required parameter field was null or undefined when calling listPermissionOptions.');
            }
            const localVarPath = `/permissions/options/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (field !== undefined) {
                localVarQueryParameter['field'] = field;
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (verb !== undefined) {
                localVarQueryParameter['verb'] = verb;
            }

            if (excludeGlobals !== undefined) {
                localVarQueryParameter['exclude_globals'] = excludeGlobals;
            }

            if (allowedOnly !== undefined) {
                localVarQueryParameter['allowed_only'] = allowedOnly;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by permission application.
         * @summary List the permissions for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'application' | 'resource_type' | 'verb' | 'permission'} [orderBy] Parameter for ordering permissions by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {string} [application] Exact match for the application name of a permission. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [resourceType] Exact match for the resource type name of a permission. You may also use a comma-separated list to match on multiple resource_types.
         * @param {string} [verb] Exact match for the operation verb name of a permission You may also use a comma-separated list to match on multiple verbs.
         * @param {string} [permission] Partial match for the aggregate permission value name of a permission object.
         * @param {'true' | 'false'} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission with a global allowance on either \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {string} [excludeRoles] An optional string filter which accepts one or more role UUIDs, comma-separated, to return permissions not associated with the supplied role(s).
         * @param {'true' | 'false'} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: async (limit?: number, offset?: number, orderBy?: 'application' | 'resource_type' | 'verb' | 'permission', application?: string, resourceType?: string, verb?: string, permission?: string, excludeGlobals?: 'true' | 'false', excludeRoles?: string, allowedOnly?: 'true' | 'false', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (verb !== undefined) {
                localVarQueryParameter['verb'] = verb;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }

            if (excludeGlobals !== undefined) {
                localVarQueryParameter['exclude_globals'] = excludeGlobals;
            }

            if (excludeRoles !== undefined) {
                localVarQueryParameter['exclude_roles'] = excludeRoles;
            }

            if (allowedOnly !== undefined) {
                localVarQueryParameter['allowed_only'] = allowedOnly;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionApi - functional programming interface
 * @export
 */
export const PermissionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * By default, options of application is returned. And could be resource_type or verb on demand.
         * @summary List the available options for fields of permissions for a tenant
         * @param {'application' | 'resource_type' | 'verb'} field specify which fields of permission to display
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [application] Filter returned options based on application. You may also use a comma-separated list to filter on multiple applications.
         * @param {string} [resourceType] Filter returned options based on resource_type. You may also use a comma-separated list to filter on multiple resource_types.
         * @param {string} [verb] Filter returned options based on verb. You may also use a comma-separated list to filter on multiple verbs.
         * @param {'true' | 'false'} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission option with a global allowance on the supplied \&#39;?field&#x3D;\&#39; value of \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {'true' | 'false'} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissionOptions(field: 'application' | 'resource_type' | 'verb', limit?: number, offset?: number, application?: string, resourceType?: string, verb?: string, excludeGlobals?: 'true' | 'false', allowedOnly?: 'true' | 'false', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionOptionsPagination>> {
            const localVarAxiosArgs = await PermissionApiAxiosParamCreator(configuration).listPermissionOptions(field, limit, offset, application, resourceType, verb, excludeGlobals, allowedOnly, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by permission application.
         * @summary List the permissions for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'application' | 'resource_type' | 'verb' | 'permission'} [orderBy] Parameter for ordering permissions by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {string} [application] Exact match for the application name of a permission. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [resourceType] Exact match for the resource type name of a permission. You may also use a comma-separated list to match on multiple resource_types.
         * @param {string} [verb] Exact match for the operation verb name of a permission You may also use a comma-separated list to match on multiple verbs.
         * @param {string} [permission] Partial match for the aggregate permission value name of a permission object.
         * @param {'true' | 'false'} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission with a global allowance on either \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {string} [excludeRoles] An optional string filter which accepts one or more role UUIDs, comma-separated, to return permissions not associated with the supplied role(s).
         * @param {'true' | 'false'} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissions(limit?: number, offset?: number, orderBy?: 'application' | 'resource_type' | 'verb' | 'permission', application?: string, resourceType?: string, verb?: string, permission?: string, excludeGlobals?: 'true' | 'false', excludeRoles?: string, allowedOnly?: 'true' | 'false', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionPagination>> {
            const localVarAxiosArgs = await PermissionApiAxiosParamCreator(configuration).listPermissions(limit, offset, orderBy, application, resourceType, verb, permission, excludeGlobals, excludeRoles, allowedOnly, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PermissionApi - factory interface
 * @export
 */
export const PermissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * By default, options of application is returned. And could be resource_type or verb on demand.
         * @summary List the available options for fields of permissions for a tenant
         * @param {'application' | 'resource_type' | 'verb'} field specify which fields of permission to display
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [application] Filter returned options based on application. You may also use a comma-separated list to filter on multiple applications.
         * @param {string} [resourceType] Filter returned options based on resource_type. You may also use a comma-separated list to filter on multiple resource_types.
         * @param {string} [verb] Filter returned options based on verb. You may also use a comma-separated list to filter on multiple verbs.
         * @param {'true' | 'false'} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission option with a global allowance on the supplied \&#39;?field&#x3D;\&#39; value of \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {'true' | 'false'} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionOptions(field: 'application' | 'resource_type' | 'verb', limit?: number, offset?: number, application?: string, resourceType?: string, verb?: string, excludeGlobals?: 'true' | 'false', allowedOnly?: 'true' | 'false', options?: any): AxiosPromise<PermissionOptionsPagination> {
            return PermissionApiFp(configuration).listPermissionOptions(field, limit, offset, application, resourceType, verb, excludeGlobals, allowedOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, responses are sorted in ascending order by permission application.
         * @summary List the permissions for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'application' | 'resource_type' | 'verb' | 'permission'} [orderBy] Parameter for ordering permissions by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {string} [application] Exact match for the application name of a permission. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [resourceType] Exact match for the resource type name of a permission. You may also use a comma-separated list to match on multiple resource_types.
         * @param {string} [verb] Exact match for the operation verb name of a permission You may also use a comma-separated list to match on multiple verbs.
         * @param {string} [permission] Partial match for the aggregate permission value name of a permission object.
         * @param {'true' | 'false'} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission with a global allowance on either \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {string} [excludeRoles] An optional string filter which accepts one or more role UUIDs, comma-separated, to return permissions not associated with the supplied role(s).
         * @param {'true' | 'false'} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(limit?: number, offset?: number, orderBy?: 'application' | 'resource_type' | 'verb' | 'permission', application?: string, resourceType?: string, verb?: string, permission?: string, excludeGlobals?: 'true' | 'false', excludeRoles?: string, allowedOnly?: 'true' | 'false', options?: any): AxiosPromise<PermissionPagination> {
            return PermissionApiFp(configuration).listPermissions(limit, offset, orderBy, application, resourceType, verb, permission, excludeGlobals, excludeRoles, allowedOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionApi - object-oriented interface
 * @export
 * @class PermissionApi
 * @extends {BaseAPI}
 */
export class PermissionApi extends BaseAPI {
    /**
     * By default, options of application is returned. And could be resource_type or verb on demand.
     * @summary List the available options for fields of permissions for a tenant
     * @param {'application' | 'resource_type' | 'verb'} field specify which fields of permission to display
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [application] Filter returned options based on application. You may also use a comma-separated list to filter on multiple applications.
     * @param {string} [resourceType] Filter returned options based on resource_type. You may also use a comma-separated list to filter on multiple resource_types.
     * @param {string} [verb] Filter returned options based on verb. You may also use a comma-separated list to filter on multiple verbs.
     * @param {'true' | 'false'} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission option with a global allowance on the supplied \&#39;?field&#x3D;\&#39; value of \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
     * @param {'true' | 'false'} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public listPermissionOptions(field: 'application' | 'resource_type' | 'verb', limit?: number, offset?: number, application?: string, resourceType?: string, verb?: string, excludeGlobals?: 'true' | 'false', allowedOnly?: 'true' | 'false', options?: any) {
        return PermissionApiFp(this.configuration).listPermissionOptions(field, limit, offset, application, resourceType, verb, excludeGlobals, allowedOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, responses are sorted in ascending order by permission application.
     * @summary List the permissions for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {'application' | 'resource_type' | 'verb' | 'permission'} [orderBy] Parameter for ordering permissions by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
     * @param {string} [application] Exact match for the application name of a permission. You may also use a comma-separated list to match on multiple applications.
     * @param {string} [resourceType] Exact match for the resource type name of a permission. You may also use a comma-separated list to match on multiple resource_types.
     * @param {string} [verb] Exact match for the operation verb name of a permission You may also use a comma-separated list to match on multiple verbs.
     * @param {string} [permission] Partial match for the aggregate permission value name of a permission object.
     * @param {'true' | 'false'} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission with a global allowance on either \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
     * @param {string} [excludeRoles] An optional string filter which accepts one or more role UUIDs, comma-separated, to return permissions not associated with the supplied role(s).
     * @param {'true' | 'false'} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public listPermissions(limit?: number, offset?: number, orderBy?: 'application' | 'resource_type' | 'verb' | 'permission', application?: string, resourceType?: string, verb?: string, permission?: string, excludeGlobals?: 'true' | 'false', excludeRoles?: string, allowedOnly?: 'true' | 'false', options?: any) {
        return PermissionApiFp(this.configuration).listPermissions(limit, offset, orderBy, application, resourceType, verb, permission, excludeGlobals, excludeRoles, allowedOnly, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PolicyApi - axios parameter creator
 * @export
 */
export const PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicies: async (policyIn: PolicyIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyIn' is not null or undefined
            if (policyIn === null || policyIn === undefined) {
                throw new RequiredError('policyIn','Required parameter policyIn was null or undefined when calling createPolicies.');
            }
            const localVarPath = `/policies/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof policyIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(policyIn !== undefined ? policyIn : {}) : (policyIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deletePolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getPolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by policy name
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [groupName] Parameter for filtering resource by group name using string contains search.
         * @param {string} [groupUuid] Parameter for filtering resource by group uuid using UUID exact match.
         * @param {'name' | 'modified'} [orderBy] Parameter for ordering policies by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies: async (limit?: number, offset?: number, name?: string, scope?: 'account' | 'principal', groupName?: string, groupUuid?: string, orderBy?: 'name' | 'modified', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (groupName !== undefined) {
                localVarQueryParameter['group_name'] = groupName;
            }

            if (groupUuid !== undefined) {
                localVarQueryParameter['group_uuid'] = groupUuid;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (uuid: string, policyIn: PolicyIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updatePolicy.');
            }
            // verify required parameter 'policyIn' is not null or undefined
            if (policyIn === null || policyIn === undefined) {
                throw new RequiredError('policyIn','Required parameter policyIn was null or undefined when calling updatePolicy.');
            }
            const localVarPath = `/policies/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof policyIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(policyIn !== undefined ? policyIn : {}) : (policyIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyApi - functional programming interface
 * @export
 */
export const PolicyApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicies(policyIn: PolicyIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended>> {
            const localVarAxiosArgs = await PolicyApiAxiosParamCreator(configuration).createPolicies(policyIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PolicyApiAxiosParamCreator(configuration).deletePolicy(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicy(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended>> {
            const localVarAxiosArgs = await PolicyApiAxiosParamCreator(configuration).getPolicy(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by policy name
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [groupName] Parameter for filtering resource by group name using string contains search.
         * @param {string} [groupUuid] Parameter for filtering resource by group uuid using UUID exact match.
         * @param {'name' | 'modified'} [orderBy] Parameter for ordering policies by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPolicies(limit?: number, offset?: number, name?: string, scope?: 'account' | 'principal', groupName?: string, groupUuid?: string, orderBy?: 'name' | 'modified', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyPagination>> {
            const localVarAxiosArgs = await PolicyApiAxiosParamCreator(configuration).listPolicies(limit, offset, name, scope, groupName, groupUuid, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(uuid: string, policyIn: PolicyIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyExtended>> {
            const localVarAxiosArgs = await PolicyApiAxiosParamCreator(configuration).updatePolicy(uuid, policyIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PolicyApi - factory interface
 * @export
 */
export const PolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a policy in a tenant
         * @param {PolicyIn} policyIn Policy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicies(policyIn: PolicyIn, options?: any): AxiosPromise<PolicyExtended> {
            return PolicyApiFp(configuration).createPolicies(policyIn, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a policy in the tenant
         * @param {string} uuid ID of policy to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(uuid: string, options?: any): AxiosPromise<void> {
            return PolicyApiFp(configuration).deletePolicy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a policy in the tenant
         * @param {string} uuid ID of policy to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(uuid: string, options?: any): AxiosPromise<PolicyExtended> {
            return PolicyApiFp(configuration).getPolicy(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, responses are sorted in ascending order by policy name
         * @summary List the policies in the tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {string} [groupName] Parameter for filtering resource by group name using string contains search.
         * @param {string} [groupUuid] Parameter for filtering resource by group uuid using UUID exact match.
         * @param {'name' | 'modified'} [orderBy] Parameter for ordering policies by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(limit?: number, offset?: number, name?: string, scope?: 'account' | 'principal', groupName?: string, groupUuid?: string, orderBy?: 'name' | 'modified', options?: any): AxiosPromise<PolicyPagination> {
            return PolicyApiFp(configuration).listPolicies(limit, offset, name, scope, groupName, groupUuid, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a policy in the tenant
         * @param {string} uuid ID of policy to update
         * @param {PolicyIn} policyIn Policy to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(uuid: string, policyIn: PolicyIn, options?: any): AxiosPromise<PolicyExtended> {
            return PolicyApiFp(configuration).updatePolicy(uuid, policyIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
export class PolicyApi extends BaseAPI {
    /**
     *
     * @summary Create a policy in a tenant
     * @param {PolicyIn} policyIn Policy to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public createPolicies(policyIn: PolicyIn, options?: any) {
        return PolicyApiFp(this.configuration).createPolicies(policyIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a policy in the tenant
     * @param {string} uuid ID of policy to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public deletePolicy(uuid: string, options?: any) {
        return PolicyApiFp(this.configuration).deletePolicy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a policy in the tenant
     * @param {string} uuid ID of policy to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getPolicy(uuid: string, options?: any) {
        return PolicyApiFp(this.configuration).getPolicy(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, responses are sorted in ascending order by policy name
     * @summary List the policies in the tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
     * @param {string} [groupName] Parameter for filtering resource by group name using string contains search.
     * @param {string} [groupUuid] Parameter for filtering resource by group uuid using UUID exact match.
     * @param {'name' | 'modified'} [orderBy] Parameter for ordering policies by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public listPolicies(limit?: number, offset?: number, name?: string, scope?: 'account' | 'principal', groupName?: string, groupUuid?: string, orderBy?: 'name' | 'modified', options?: any) {
        return PolicyApiFp(this.configuration).listPolicies(limit, offset, name, scope, groupName, groupUuid, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a policy in the tenant
     * @param {string} uuid ID of policy to update
     * @param {PolicyIn} policyIn Policy to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public updatePolicy(uuid: string, policyIn: PolicyIn, options?: any) {
        return PolicyApiFp(this.configuration).updatePolicy(uuid, policyIn, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PrincipalApi - axios parameter creator
 * @export
 */
export const PrincipalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'partial' | 'exact'} [matchCriteria] Parameter for specifying the matching criteria for an object\&#39;s name and/or email. Currently, match_criteria of partial searches for a username/email using \&quot;starts with\&quot; pattern.
         * @param {string} [usernames] Comma separated usernames of principals to get. If match_criteria is specified, only the first username will be picked up for search.
         * @param {'asc' | 'desc'} [sortOrder] The sort order of the query, either ascending or descending. Defaults to ascending.
         * @param {string} [email] E-mail address of principal to search for. Could be combined with match_criteria for searching.
         * @param {'enabled' | 'disabled' | 'all'} [status] Set the status of users to get back.
         * @param {'true' | 'false'} [adminOnly] Get only admin users within an account. Setting this would ignore the parameters: usernames, email
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {'service-account' | 'user'} [type] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals: async (limit?: number, offset?: number, matchCriteria?: 'partial' | 'exact', usernames?: string, sortOrder?: 'asc' | 'desc', email?: string, status?: 'enabled' | 'disabled' | 'all', adminOnly?: 'true' | 'false', orderBy?: 'username', usernameOnly?: boolean, type?: 'service-account' | 'user', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/principals/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (matchCriteria !== undefined) {
                localVarQueryParameter['match_criteria'] = matchCriteria;
            }

            if (usernames !== undefined) {
                localVarQueryParameter['usernames'] = usernames;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (adminOnly !== undefined) {
                localVarQueryParameter['admin_only'] = adminOnly;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (usernameOnly !== undefined) {
                localVarQueryParameter['username_only'] = usernameOnly;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrincipalApi - functional programming interface
 * @export
 */
export const PrincipalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'partial' | 'exact'} [matchCriteria] Parameter for specifying the matching criteria for an object\&#39;s name and/or email. Currently, match_criteria of partial searches for a username/email using \&quot;starts with\&quot; pattern.
         * @param {string} [usernames] Comma separated usernames of principals to get. If match_criteria is specified, only the first username will be picked up for search.
         * @param {'asc' | 'desc'} [sortOrder] The sort order of the query, either ascending or descending. Defaults to ascending.
         * @param {string} [email] E-mail address of principal to search for. Could be combined with match_criteria for searching.
         * @param {'enabled' | 'disabled' | 'all'} [status] Set the status of users to get back.
         * @param {'true' | 'false'} [adminOnly] Get only admin users within an account. Setting this would ignore the parameters: usernames, email
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {'service-account' | 'user'} [type] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPrincipals(limit?: number, offset?: number, matchCriteria?: 'partial' | 'exact', usernames?: string, sortOrder?: 'asc' | 'desc', email?: string, status?: 'enabled' | 'disabled' | 'all', adminOnly?: 'true' | 'false', orderBy?: 'username', usernameOnly?: boolean, type?: 'service-account' | 'user', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrincipalPagination>> {
            const localVarAxiosArgs = await PrincipalApiAxiosParamCreator(configuration).listPrincipals(limit, offset, matchCriteria, usernames, sortOrder, email, status, adminOnly, orderBy, usernameOnly, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PrincipalApi - factory interface
 * @export
 */
export const PrincipalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {'partial' | 'exact'} [matchCriteria] Parameter for specifying the matching criteria for an object\&#39;s name and/or email. Currently, match_criteria of partial searches for a username/email using \&quot;starts with\&quot; pattern.
         * @param {string} [usernames] Comma separated usernames of principals to get. If match_criteria is specified, only the first username will be picked up for search.
         * @param {'asc' | 'desc'} [sortOrder] The sort order of the query, either ascending or descending. Defaults to ascending.
         * @param {string} [email] E-mail address of principal to search for. Could be combined with match_criteria for searching.
         * @param {'enabled' | 'disabled' | 'all'} [status] Set the status of users to get back.
         * @param {'true' | 'false'} [adminOnly] Get only admin users within an account. Setting this would ignore the parameters: usernames, email
         * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {'service-account' | 'user'} [type] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(limit?: number, offset?: number, matchCriteria?: 'partial' | 'exact', usernames?: string, sortOrder?: 'asc' | 'desc', email?: string, status?: 'enabled' | 'disabled' | 'all', adminOnly?: 'true' | 'false', orderBy?: 'username', usernameOnly?: boolean, type?: 'service-account' | 'user', options?: any): AxiosPromise<PrincipalPagination> {
            return PrincipalApiFp(configuration).listPrincipals(limit, offset, matchCriteria, usernames, sortOrder, email, status, adminOnly, orderBy, usernameOnly, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrincipalApi - object-oriented interface
 * @export
 * @class PrincipalApi
 * @extends {BaseAPI}
 */
export class PrincipalApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by username
     * @summary List the principals for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {'partial' | 'exact'} [matchCriteria] Parameter for specifying the matching criteria for an object\&#39;s name and/or email. Currently, match_criteria of partial searches for a username/email using \&quot;starts with\&quot; pattern.
     * @param {string} [usernames] Comma separated usernames of principals to get. If match_criteria is specified, only the first username will be picked up for search.
     * @param {'asc' | 'desc'} [sortOrder] The sort order of the query, either ascending or descending. Defaults to ascending.
     * @param {string} [email] E-mail address of principal to search for. Could be combined with match_criteria for searching.
     * @param {'enabled' | 'disabled' | 'all'} [status] Set the status of users to get back.
     * @param {'true' | 'false'} [adminOnly] Get only admin users within an account. Setting this would ignore the parameters: usernames, email
     * @param {'username'} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
     * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
     * @param {'service-account' | 'user'} [type] Parameter for selecting the type of principal to be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrincipalApi
     */
    public listPrincipals(limit?: number, offset?: number, matchCriteria?: 'partial' | 'exact', usernames?: string, sortOrder?: 'asc' | 'desc', email?: string, status?: 'enabled' | 'disabled' | 'all', adminOnly?: 'true' | 'false', orderBy?: 'username', usernameOnly?: boolean, type?: 'service-account' | 'user', options?: any) {
        return PrincipalApiFp(this.configuration).listPrincipals(limit, offset, matchCriteria, usernames, sortOrder, email, status, adminOnly, orderBy, usernameOnly, type, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a role for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (roleIn: RoleIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleIn' is not null or undefined
            if (roleIn === null || roleIn === undefined) {
                throw new RequiredError('roleIn','Required parameter roleIn was null or undefined when calling createRole.');
            }
            const localVarPath = `/roles/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof roleIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(roleIn !== undefined ? roleIn : {}) : (roleIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (uuid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (uuid: string, scope?: 'account' | 'principal', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAccess: async (uuid: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRoleAccess.');
            }
            const localVarPath = `/roles/{uuid}/access/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {boolean} [system] Parameter for filtering resource by system flag.
         * @param {string} [displayName] Parameter for filtering resource by display_name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {'name' | 'display_name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<'groups_in' | 'groups_in_count' | 'access'>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {string} [application] The application name(s) to filter roles by, from permissions or external tenant name. This is an exact match. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [permission] The permission(s) to filter roles by. This is an exact match. You may also use a comma-separated list to match on multiple permissions.
         * @param {string} [externalTenant] Parameter for filtering roles by external tenant name using string search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (limit?: number, offset?: number, name?: string, system?: boolean, displayName?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', orderBy?: 'name' | 'display_name' | 'modified' | 'policyCount', addFields?: Array<'groups_in' | 'groups_in_count' | 'access'>, username?: string, application?: string, permission?: string, externalTenant?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (nameMatch !== undefined) {
                localVarQueryParameter['name_match'] = nameMatch;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (addFields) {
                localVarQueryParameter['add_fields'] = addFields.join(COLLECTION_FORMATS.csv);
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }

            if (externalTenant !== undefined) {
                localVarQueryParameter['external_tenant'] = externalTenant;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Patch a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePatch} [rolePatch] Patch to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: async (uuid: string, rolePatch?: RolePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling patchRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rolePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rolePatch !== undefined ? rolePatch : {}) : (rolePatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (uuid: string, roleWithAccess: RoleWithAccess, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling updateRole.');
            }
            // verify required parameter 'roleWithAccess' is not null or undefined
            if (roleWithAccess === null || roleWithAccess === undefined) {
                throw new RequiredError('roleWithAccess','Required parameter roleWithAccess was null or undefined when calling updateRole.');
            }
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof roleWithAccess !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(roleWithAccess !== undefined ? roleWithAccess : {}) : (roleWithAccess || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a role for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(roleIn: RoleIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess>> {
            const localVarAxiosArgs = await RoleApiAxiosParamCreator(configuration).createRole(roleIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(uuid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RoleApiAxiosParamCreator(configuration).deleteRole(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(uuid: string, scope?: 'account' | 'principal', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess>> {
            const localVarAxiosArgs = await RoleApiAxiosParamCreator(configuration).getRole(uuid, scope, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAccess(uuid: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPagination>> {
            const localVarAxiosArgs = await RoleApiAxiosParamCreator(configuration).getRoleAccess(uuid, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {boolean} [system] Parameter for filtering resource by system flag.
         * @param {string} [displayName] Parameter for filtering resource by display_name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {'name' | 'display_name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<'groups_in' | 'groups_in_count' | 'access'>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {string} [application] The application name(s) to filter roles by, from permissions or external tenant name. This is an exact match. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [permission] The permission(s) to filter roles by. This is an exact match. You may also use a comma-separated list to match on multiple permissions.
         * @param {string} [externalTenant] Parameter for filtering roles by external tenant name using string search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(limit?: number, offset?: number, name?: string, system?: boolean, displayName?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', orderBy?: 'name' | 'display_name' | 'modified' | 'policyCount', addFields?: Array<'groups_in' | 'groups_in_count' | 'access'>, username?: string, application?: string, permission?: string, externalTenant?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolePaginationDynamic>> {
            const localVarAxiosArgs = await RoleApiAxiosParamCreator(configuration).listRoles(limit, offset, name, system, displayName, nameMatch, scope, orderBy, addFields, username, application, permission, externalTenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Patch a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePatch} [rolePatch] Patch to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRole(uuid: string, rolePatch?: RolePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess>> {
            const localVarAxiosArgs = await RoleApiAxiosParamCreator(configuration).patchRole(uuid, rolePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RoleApiAxiosParamCreator(configuration).updateRole(uuid, roleWithAccess, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Create a role for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(roleIn: RoleIn, options?: any): AxiosPromise<RoleWithAccess> {
            return RoleApiFp(configuration).createRole(roleIn, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(uuid: string, options?: any): AxiosPromise<void> {
            return RoleApiFp(configuration).deleteRole(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(uuid: string, scope?: 'account' | 'principal', options?: any): AxiosPromise<RoleWithAccess> {
            return RoleApiFp(configuration).getRole(uuid, scope, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAccess(uuid: string, limit?: number, offset?: number, options?: any): AxiosPromise<AccessPagination> {
            return RoleApiFp(configuration).getRoleAccess(uuid, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {boolean} [system] Parameter for filtering resource by system flag.
         * @param {string} [displayName] Parameter for filtering resource by display_name using string contains search.
         * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
         * @param {'name' | 'display_name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<'groups_in' | 'groups_in_count' | 'access'>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {string} [application] The application name(s) to filter roles by, from permissions or external tenant name. This is an exact match. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [permission] The permission(s) to filter roles by. This is an exact match. You may also use a comma-separated list to match on multiple permissions.
         * @param {string} [externalTenant] Parameter for filtering roles by external tenant name using string search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(limit?: number, offset?: number, name?: string, system?: boolean, displayName?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', orderBy?: 'name' | 'display_name' | 'modified' | 'policyCount', addFields?: Array<'groups_in' | 'groups_in_count' | 'access'>, username?: string, application?: string, permission?: string, externalTenant?: string, options?: any): AxiosPromise<RolePaginationDynamic> {
            return RoleApiFp(configuration).listRoles(limit, offset, name, system, displayName, nameMatch, scope, orderBy, addFields, username, application, permission, externalTenant, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Patch a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePatch} [rolePatch] Patch to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRole(uuid: string, rolePatch?: RolePatch, options?: any): AxiosPromise<RoleWithAccess> {
            return RoleApiFp(configuration).patchRole(uuid, rolePatch, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RoleWithAccess} roleWithAccess Update to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any): AxiosPromise<void> {
            return RoleApiFp(configuration).updateRole(uuid, roleWithAccess, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
    /**
     *
     * @summary Create a role for a tenant
     * @param {RoleIn} roleIn Role to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public createRole(roleIn: RoleIn, options?: any) {
        return RoleApiFp(this.configuration).createRole(roleIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Delete a role in the tenant
     * @param {string} uuid ID of role to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public deleteRole(uuid: string, options?: any) {
        return RoleApiFp(this.configuration).deleteRole(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get a role in the tenant
     * @param {string} uuid ID of role to get
     * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public getRole(uuid: string, scope?: 'account' | 'principal', options?: any) {
        return RoleApiFp(this.configuration).getRole(uuid, scope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get access for a role in the tenant
     * @param {string} uuid ID of the role
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public getRoleAccess(uuid: string, limit?: number, offset?: number, options?: any) {
        return RoleApiFp(this.configuration).getRoleAccess(uuid, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, responses are sorted in ascending order by role name
     * @summary List the roles for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {boolean} [system] Parameter for filtering resource by system flag.
     * @param {string} [displayName] Parameter for filtering resource by display_name using string contains search.
     * @param {'partial' | 'exact'} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
     * @param {'account' | 'principal'} [scope] Parameter for filtering resource by scope.
     * @param {'name' | 'display_name' | 'modified' | 'policyCount'} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {Array<'groups_in' | 'groups_in_count' | 'access'>} [addFields] Parameter for add list of fields to display for roles.
     * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
     * @param {string} [application] The application name(s) to filter roles by, from permissions or external tenant name. This is an exact match. You may also use a comma-separated list to match on multiple applications.
     * @param {string} [permission] The permission(s) to filter roles by. This is an exact match. You may also use a comma-separated list to match on multiple permissions.
     * @param {string} [externalTenant] Parameter for filtering roles by external tenant name using string search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public listRoles(limit?: number, offset?: number, name?: string, system?: boolean, displayName?: string, nameMatch?: 'partial' | 'exact', scope?: 'account' | 'principal', orderBy?: 'name' | 'display_name' | 'modified' | 'policyCount', addFields?: Array<'groups_in' | 'groups_in_count' | 'access'>, username?: string, application?: string, permission?: string, externalTenant?: string, options?: any) {
        return RoleApiFp(this.configuration).listRoles(limit, offset, name, system, displayName, nameMatch, scope, orderBy, addFields, username, application, permission, externalTenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Patch a role in the tenant
     * @param {string} uuid ID of role to update
     * @param {RolePatch} [rolePatch] Patch to a role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public patchRole(uuid: string, rolePatch?: RolePatch, options?: any) {
        return RoleApiFp(this.configuration).patchRole(uuid, rolePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a role in the tenant
     * @param {string} uuid ID of role to update
     * @param {RoleWithAccess} roleWithAccess Update to a role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public updateRole(uuid: string, roleWithAccess: RoleWithAccess, options?: any) {
        return RoleApiFp(this.configuration).updateRole(uuid, roleWithAccess, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await StatusApiAxiosParamCreator(configuration).getStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<Status> {
            return StatusApiFp(configuration).getStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     *
     * @summary Obtain server status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatus(options?: any) {
        return StatusApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

}


