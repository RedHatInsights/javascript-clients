/* tslint:disable */
/* eslint-disable */
/**
 * Role Based Access Control
 * The API for Role Based Access Control.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Access
 */
export interface Access {
    /**
     *
     * @type {string}
     * @memberof Access
     */
    'permission': string;
    /**
     *
     * @type {Array<ResourceDefinition>}
     * @memberof Access
     */
    'resourceDefinitions': Array<ResourceDefinition>;
}
/**
 *
 * @export
 * @interface AccessPagination
 */
export interface AccessPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof AccessPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof AccessPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<Access>}
     * @memberof AccessPagination
     */
    'data': Array<Access>;
}
/**
 *
 * @export
 * @interface AddRoleToGroup200Response
 */
export interface AddRoleToGroup200Response {
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof AddRoleToGroup200Response
     */
    'data': Array<RoleOut>;
}
/**
 *
 * @export
 * @interface AdditionalGroup
 */
export interface AdditionalGroup {
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof AdditionalGroup
     */
    'uuid'?: string;
}
/**
 *
 * @export
 * @interface CrossAccountRequest
 */
export interface CrossAccountRequest {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    'request_id'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    'target_account'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    'target_org'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    'status'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequest
     */
    'created'?: string;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequest
     */
    'start_date'?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequest
     */
    'end_date'?: any;
}
/**
 *
 * @export
 * @interface CrossAccountRequestByAccount
 */
export interface CrossAccountRequestByAccount {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    'request_id'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    'target_account'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    'target_org'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    'status'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    'created'?: string;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestByAccount
     */
    'start_date'?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestByAccount
     */
    'end_date'?: any;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    'first_name'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    'last_name'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByAccount
     */
    'email'?: string;
}
/**
 *
 * @export
 * @interface CrossAccountRequestByUserId
 */
export interface CrossAccountRequestByUserId {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    'request_id'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    'target_account'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    'target_org'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    'status'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    'created'?: string;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestByUserId
     */
    'start_date'?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestByUserId
     */
    'end_date'?: any;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestByUserId
     */
    'user_id'?: string;
}
/**
 * @type CrossAccountRequestDetail
 * @export
 */
export type CrossAccountRequestDetail = CrossAccountRequestDetailByAccount | CrossAccountRequestDetailByUseId;

/**
 *
 * @export
 * @interface CrossAccountRequestDetailByAccount
 */
export interface CrossAccountRequestDetailByAccount {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'request_id'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'target_account'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'target_org'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'start_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'end_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'status'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'created'?: string;
    /**
     *
     * @type {Array<CrossAccountRequestWithRolesRolesInner>}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'roles'?: Array<CrossAccountRequestWithRolesRolesInner>;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'first_name'?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'last_name'?: any;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByAccount
     */
    'email'?: any;
}
/**
 *
 * @export
 * @interface CrossAccountRequestDetailByUseId
 */
export interface CrossAccountRequestDetailByUseId {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'request_id'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'target_account'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'target_org'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'start_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'end_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'status'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'created'?: string;
    /**
     *
     * @type {Array<CrossAccountRequestWithRolesRolesInner>}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'roles'?: Array<CrossAccountRequestWithRolesRolesInner>;
    /**
     *
     * @type {any}
     * @memberof CrossAccountRequestDetailByUseId
     */
    'user_id'?: any;
}
/**
 *
 * @export
 * @interface CrossAccountRequestIn
 */
export interface CrossAccountRequestIn {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestIn
     */
    'target_account': string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestIn
     */
    'target_org': string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestIn
     */
    'start_date': string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestIn
     */
    'end_date': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CrossAccountRequestIn
     */
    'roles': Array<string>;
}
/**
 *
 * @export
 * @interface CrossAccountRequestOut
 */
export interface CrossAccountRequestOut {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    'request_id'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    'target_account'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    'target_org'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    'start_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    'end_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    'status'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    'created'?: string;
    /**
     *
     * @type {Array<CrossAccountRequestWithRolesRolesInner>}
     * @memberof CrossAccountRequestOut
     */
    'roles'?: Array<CrossAccountRequestWithRolesRolesInner>;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestOut
     */
    'user_id'?: string;
}
/**
 *
 * @export
 * @interface CrossAccountRequestPagination
 */
export interface CrossAccountRequestPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof CrossAccountRequestPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof CrossAccountRequestPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<CrossAccountRequestPaginationAllOfDataInner>}
     * @memberof CrossAccountRequestPagination
     */
    'data': Array<CrossAccountRequestPaginationAllOfDataInner>;
}
/**
 * @type CrossAccountRequestPaginationAllOfDataInner
 * @export
 */
export type CrossAccountRequestPaginationAllOfDataInner = CrossAccountRequestByAccount | CrossAccountRequestByUserId;

/**
 *
 * @export
 * @interface CrossAccountRequestPatch
 */
export interface CrossAccountRequestPatch {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestPatch
     */
    'start_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestPatch
     */
    'end_date'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CrossAccountRequestPatch
     */
    'roles'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestPatch
     */
    'status'?: CrossAccountRequestPatchStatusEnum;
}

export const CrossAccountRequestPatchStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Expired: 'expired',
    Cancelled: 'cancelled',
    Denied: 'denied'
} as const;

export type CrossAccountRequestPatchStatusEnum = typeof CrossAccountRequestPatchStatusEnum[keyof typeof CrossAccountRequestPatchStatusEnum];

/**
 *
 * @export
 * @interface CrossAccountRequestUpdateIn
 */
export interface CrossAccountRequestUpdateIn {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestUpdateIn
     */
    'start_date': string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestUpdateIn
     */
    'end_date': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CrossAccountRequestUpdateIn
     */
    'roles': Array<string>;
}
/**
 *
 * @export
 * @interface CrossAccountRequestWithRoles
 */
export interface CrossAccountRequestWithRoles {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    'request_id'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    'target_account'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    'target_org'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    'start_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    'end_date'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    'status'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRoles
     */
    'created'?: string;
    /**
     *
     * @type {Array<CrossAccountRequestWithRolesRolesInner>}
     * @memberof CrossAccountRequestWithRoles
     */
    'roles'?: Array<CrossAccountRequestWithRolesRolesInner>;
}
/**
 *
 * @export
 * @interface CrossAccountRequestWithRolesRolesInner
 */
export interface CrossAccountRequestWithRolesRolesInner {
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRolesRolesInner
     */
    'display_name'?: string;
    /**
     *
     * @type {string}
     * @memberof CrossAccountRequestWithRolesRolesInner
     */
    'description'?: string;
    /**
     *
     * @type {Array<Permission>}
     * @memberof CrossAccountRequestWithRolesRolesInner
     */
    'permissions'?: Array<Permission>;
}
/**
 *
 * @export
 * @interface Error403
 */
export interface Error403 {
    /**
     *
     * @type {Array<Error403ErrorsInner>}
     * @memberof Error403
     */
    'errors': Array<Error403ErrorsInner>;
}
/**
 *
 * @export
 * @interface Error403ErrorsInner
 */
export interface Error403ErrorsInner {
    /**
     *
     * @type {string}
     * @memberof Error403ErrorsInner
     */
    'detail'?: string;
    /**
     *
     * @type {string}
     * @memberof Error403ErrorsInner
     */
    'source'?: string;
    /**
     *
     * @type {string}
     * @memberof Error403ErrorsInner
     */
    'status'?: string;
}
/**
 *
 * @export
 * @interface ErrorErrorsInner
 */
export interface ErrorErrorsInner {
    /**
     *
     * @type {string}
     * @memberof ErrorErrorsInner
     */
    'detail'?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorErrorsInner
     */
    'status'?: string;
}
/**
 * Error structure for the \"Not Found\" responses.
 * @export
 * @interface ErrorNotFound
 */
export interface ErrorNotFound {
    /**
     *
     * @type {Array<ErrorNotFoundErrorsInner>}
     * @memberof ErrorNotFound
     */
    'errors': Array<ErrorNotFoundErrorsInner>;
}
/**
 *
 * @export
 * @interface ErrorNotFoundErrorsInner
 */
export interface ErrorNotFoundErrorsInner {
    /**
     * Detail of the error.
     * @type {string}
     * @memberof ErrorNotFoundErrorsInner
     */
    'detail'?: string;
    /**
     * Status of the response
     * @type {string}
     * @memberof ErrorNotFoundErrorsInner
     */
    'status'?: string;
    /**
     * Source of the error.
     * @type {string}
     * @memberof ErrorNotFoundErrorsInner
     */
    'source'?: string;
}
/**
 * @type GetPrincipalsFromGroup200Response
 * @export
 */
export type GetPrincipalsFromGroup200Response = PrincipalPagination | ServiceAccountInGroupResponse | ServiceAccountPagination;

/**
 *
 * @export
 * @interface Group
 */
export interface Group {
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface GroupOut
 */
export interface GroupOut {
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    'modified': string;
    /**
     *
     * @type {number}
     * @memberof GroupOut
     */
    'principalCount'?: number;
    /**
     *
     * @type {number}
     * @memberof GroupOut
     */
    'roleCount'?: number;
    /**
     *
     * @type {boolean}
     * @memberof GroupOut
     */
    'system'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupOut
     */
    'platform_default'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupOut
     */
    'admin_default'?: boolean;
}
/**
 *
 * @export
 * @interface GroupPagination
 */
export interface GroupPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof GroupPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof GroupPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<GroupOut>}
     * @memberof GroupPagination
     */
    'data': Array<GroupOut>;
}
/**
 *
 * @export
 * @interface GroupPrincipalIn
 */
export interface GroupPrincipalIn {
    /**
     *
     * @type {Array<GroupPrincipalInPrincipalsInner>}
     * @memberof GroupPrincipalIn
     */
    'principals': Array<GroupPrincipalInPrincipalsInner>;
}
/**
 *
 * @export
 * @interface GroupPrincipalInPrincipalsInner
 */
export interface GroupPrincipalInPrincipalsInner {
    /**
     *
     * @type {string}
     * @memberof GroupPrincipalInPrincipalsInner
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof GroupPrincipalInPrincipalsInner
     */
    'type': GroupPrincipalInPrincipalsInnerTypeEnum;
    /**
     *
     * @type {string}
     * @memberof GroupPrincipalInPrincipalsInner
     */
    'clientId': string;
}

export const GroupPrincipalInPrincipalsInnerTypeEnum = {
    ServiceAccount: 'service-account'
} as const;

export type GroupPrincipalInPrincipalsInnerTypeEnum = typeof GroupPrincipalInPrincipalsInnerTypeEnum[keyof typeof GroupPrincipalInPrincipalsInnerTypeEnum];

/**
 *
 * @export
 * @interface GroupRoleIn
 */
export interface GroupRoleIn {
    /**
     *
     * @type {Array<string>}
     * @memberof GroupRoleIn
     */
    'roles': Array<string>;
}
/**
 *
 * @export
 * @interface GroupRolesPagination
 */
export interface GroupRolesPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof GroupRolesPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof GroupRolesPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof GroupRolesPagination
     */
    'data': Array<RoleOut>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipals
 */
export interface GroupWithPrincipals {
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipals
     */
    'modified': string;
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipals
     */
    'principals': Array<Principal>;
}
/**
 *
 * @export
 * @interface GroupWithPrincipalsAndRoles
 */
export interface GroupWithPrincipalsAndRoles {
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof GroupWithPrincipalsAndRoles
     */
    'modified': string;
    /**
     *
     * @type {Array<Principal>}
     * @memberof GroupWithPrincipalsAndRoles
     */
    'principals': Array<Principal>;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof GroupWithPrincipalsAndRoles
     */
    'roles': Array<RoleOut>;
}
/**
 *
 * @export
 * @interface ListPagination
 */
export interface ListPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof ListPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ListPagination
     */
    'links'?: PaginationLinks;
}
/**
 * @type ListPrincipals200Response
 * @export
 */
export type ListPrincipals200Response = PrincipalPagination | ServiceAccountPagination;

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {Array<ErrorErrorsInner>}
     * @memberof ModelError
     */
    'errors': Array<ErrorErrorsInner>;
}
/**
 *
 * @export
 * @interface PaginationLinks
 */
export interface PaginationLinks {
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    'first'?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    'previous'?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    'next'?: string;
    /**
     *
     * @type {string}
     * @memberof PaginationLinks
     */
    'last'?: string;
}
/**
 *
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     *
     * @type {number}
     * @memberof PaginationMeta
     */
    'count'?: number;
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    'application'?: string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    'resource_type'?: string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    'verb'?: string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    'permission'?: string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface PermissionOptionsPagination
 */
export interface PermissionOptionsPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof PermissionOptionsPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof PermissionOptionsPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<string>}
     * @memberof PermissionOptionsPagination
     */
    'data': Array<string>;
}
/**
 *
 * @export
 * @interface PermissionPagination
 */
export interface PermissionPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof PermissionPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof PermissionPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<Permission>}
     * @memberof PermissionPagination
     */
    'data': Array<Permission>;
}
/**
 *
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface PolicyExtended
 */
export interface PolicyExtended {
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof PolicyExtended
     */
    'modified': string;
    /**
     *
     * @type {GroupOut}
     * @memberof PolicyExtended
     */
    'group': GroupOut;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof PolicyExtended
     */
    'roles': Array<RoleOut>;
}
/**
 *
 * @export
 * @interface PolicyIn
 */
export interface PolicyIn {
    /**
     *
     * @type {string}
     * @memberof PolicyIn
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof PolicyIn
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof PolicyIn
     */
    'group': string;
    /**
     *
     * @type {Array<string>}
     * @memberof PolicyIn
     */
    'roles': Array<string>;
}
/**
 *
 * @export
 * @interface PolicyPagination
 */
export interface PolicyPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof PolicyPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof PolicyPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<PolicyExtended>}
     * @memberof PolicyPagination
     */
    'data': Array<PolicyExtended>;
}
/**
 *
 * @export
 * @interface Principal
 */
export interface Principal {
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    'first_name'?: string;
    /**
     *
     * @type {string}
     * @memberof Principal
     */
    'last_name'?: string;
    /**
     *
     * @type {boolean}
     * @memberof Principal
     */
    'is_active'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Principal
     */
    'is_org_admin'?: boolean;
    /**
     *
     * @type {PrincipalExternalSourceId}
     * @memberof Principal
     */
    'external_source_id'?: PrincipalExternalSourceId;
}
/**
 * @type PrincipalExternalSourceId
 * @export
 */
export type PrincipalExternalSourceId = number | string;

/**
 *
 * @export
 * @interface PrincipalIn
 */
export interface PrincipalIn {
    /**
     *
     * @type {string}
     * @memberof PrincipalIn
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PrincipalMinimal
 */
export interface PrincipalMinimal {
    /**
     *
     * @type {string}
     * @memberof PrincipalMinimal
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PrincipalOut
 */
export interface PrincipalOut {
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    'first_name'?: string;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    'last_name'?: string;
    /**
     *
     * @type {boolean}
     * @memberof PrincipalOut
     */
    'is_active'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PrincipalOut
     */
    'is_org_admin'?: boolean;
    /**
     *
     * @type {PrincipalExternalSourceId}
     * @memberof PrincipalOut
     */
    'external_source_id'?: PrincipalExternalSourceId;
    /**
     *
     * @type {string}
     * @memberof PrincipalOut
     */
    'uuid': string;
}
/**
 *
 * @export
 * @interface PrincipalPagination
 */
export interface PrincipalPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof PrincipalPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof PrincipalPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<PrincipalPaginationAllOfDataInner>}
     * @memberof PrincipalPagination
     */
    'data': Array<PrincipalPaginationAllOfDataInner>;
}
/**
 * @type PrincipalPaginationAllOfDataInner
 * @export
 */
export type PrincipalPaginationAllOfDataInner = Principal | PrincipalMinimal;

/**
 *
 * @export
 * @interface ResourceDefinition
 */
export interface ResourceDefinition {
    /**
     *
     * @type {ResourceDefinitionFilter}
     * @memberof ResourceDefinition
     */
    'attributeFilter': ResourceDefinitionFilter;
}
/**
 *
 * @export
 * @interface ResourceDefinitionFilter
 */
export interface ResourceDefinitionFilter {
    /**
     *
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    'key': string;
    /**
     *
     * @type {string}
     * @memberof ResourceDefinitionFilter
     */
    'operation': ResourceDefinitionFilterOperationEnum;
    /**
     *
     * @type {ResourceDefinitionFilterValue}
     * @memberof ResourceDefinitionFilter
     */
    'value': ResourceDefinitionFilterValue;
}

export const ResourceDefinitionFilterOperationEnum = {
    Equal: 'equal',
    In: 'in'
} as const;

export type ResourceDefinitionFilterOperationEnum = typeof ResourceDefinitionFilterOperationEnum[keyof typeof ResourceDefinitionFilterOperationEnum];

/**
 * @type ResourceDefinitionFilterValue
 * @export
 */
export type ResourceDefinitionFilterValue = Array<ResourceDefinitionFilterValueObject> | string;

/**
 * @type ResourceDefinitionFilterValueObject
 * @export
 */
export type ResourceDefinitionFilterValueObject = string;

/**
 *
 * @export
 * @interface Role
 */
export interface Role {
    /**
     *
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Role
     */
    'display_name'?: string;
    /**
     *
     * @type {string}
     * @memberof Role
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface RoleIn
 */
export interface RoleIn {
    /**
     *
     * @type {string}
     * @memberof RoleIn
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof RoleIn
     */
    'display_name'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleIn
     */
    'description'?: string;
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleIn
     */
    'access': Array<Access>;
}
/**
 *
 * @export
 * @interface RoleOut
 */
export interface RoleOut {
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    'display_name'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    'modified': string;
    /**
     *
     * @type {number}
     * @memberof RoleOut
     */
    'policyCount'?: number;
    /**
     *
     * @type {number}
     * @memberof RoleOut
     */
    'accessCount'?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOut
     */
    'applications'?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOut
     */
    'system'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOut
     */
    'platform_default'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOut
     */
    'admin_default'?: boolean;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    'external_role_id'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOut
     */
    'external_tenant'?: string;
}
/**
 *
 * @export
 * @interface RoleOutDynamic
 */
export interface RoleOutDynamic {
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    'display_name'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    'modified': string;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    'policyCount': number;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    'accessCount': number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleOutDynamic
     */
    'applications': Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamic
     */
    'system': boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamic
     */
    'platform_default': boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleOutDynamic
     */
    'admin_default': boolean;
    /**
     *
     * @type {number}
     * @memberof RoleOutDynamic
     */
    'groups_in_count'?: number;
    /**
     *
     * @type {Array<AdditionalGroup>}
     * @memberof RoleOutDynamic
     */
    'groups_in'?: Array<AdditionalGroup>;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    'external_role_id'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleOutDynamic
     */
    'external_tenant'?: string;
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleOutDynamic
     */
    'access'?: Array<Access>;
}
/**
 *
 * @export
 * @interface RolePagination
 */
export interface RolePagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof RolePagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof RolePagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<RoleOut>}
     * @memberof RolePagination
     */
    'data': Array<RoleOut>;
}
/**
 *
 * @export
 * @interface RolePaginationDynamic
 */
export interface RolePaginationDynamic {
    /**
     *
     * @type {PaginationMeta}
     * @memberof RolePaginationDynamic
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof RolePaginationDynamic
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<RoleOutDynamic>}
     * @memberof RolePaginationDynamic
     */
    'data': Array<RoleOutDynamic>;
}
/**
 *
 * @export
 * @interface RolePatch
 */
export interface RolePatch {
    /**
     *
     * @type {string}
     * @memberof RolePatch
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof RolePatch
     */
    'display_name'?: string;
    /**
     *
     * @type {string}
     * @memberof RolePatch
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface RolePut
 */
export interface RolePut {
    /**
     *
     * @type {string}
     * @memberof RolePut
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof RolePut
     */
    'display_name'?: string;
    /**
     *
     * @type {string}
     * @memberof RolePut
     */
    'description'?: string;
    /**
     * List of access permissions. This array can be empty.
     * @type {Array<Access>}
     * @memberof RolePut
     */
    'access': Array<Access>;
}
/**
 *
 * @export
 * @interface RoleWithAccess
 */
export interface RoleWithAccess {
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    'display_name'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    'uuid': string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    'modified': string;
    /**
     *
     * @type {number}
     * @memberof RoleWithAccess
     */
    'policyCount'?: number;
    /**
     *
     * @type {number}
     * @memberof RoleWithAccess
     */
    'accessCount'?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof RoleWithAccess
     */
    'applications'?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof RoleWithAccess
     */
    'system'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleWithAccess
     */
    'platform_default'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof RoleWithAccess
     */
    'admin_default'?: boolean;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    'external_role_id'?: string;
    /**
     *
     * @type {string}
     * @memberof RoleWithAccess
     */
    'external_tenant'?: string;
    /**
     *
     * @type {Array<Access>}
     * @memberof RoleWithAccess
     */
    'access': Array<Access>;
}
/**
 *
 * @export
 * @interface ServiceAccount
 */
export interface ServiceAccount {
    /**
     *
     * @type {string}
     * @memberof ServiceAccount
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof ServiceAccount
     */
    'type': ServiceAccountTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ServiceAccount
     */
    'clientId': string;
    /**
     *
     * @type {string}
     * @memberof ServiceAccount
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceAccount
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof ServiceAccount
     */
    'owner'?: string;
    /**
     *
     * @type {number}
     * @memberof ServiceAccount
     */
    'time_created'?: number;
}

export const ServiceAccountTypeEnum = {
    ServiceAccount: 'service-account'
} as const;

export type ServiceAccountTypeEnum = typeof ServiceAccountTypeEnum[keyof typeof ServiceAccountTypeEnum];

/**
 *
 * @export
 * @interface ServiceAccountIn
 */
export interface ServiceAccountIn {
    /**
     *
     * @type {string}
     * @memberof ServiceAccountIn
     */
    'type': ServiceAccountInTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ServiceAccountIn
     */
    'clientId': string;
}

export const ServiceAccountInTypeEnum = {
    ServiceAccount: 'service-account'
} as const;

export type ServiceAccountInTypeEnum = typeof ServiceAccountInTypeEnum[keyof typeof ServiceAccountInTypeEnum];

/**
 *
 * @export
 * @interface ServiceAccountInGroupResponse
 */
export interface ServiceAccountInGroupResponse {
    /**
     *
     * @type {PaginationMeta}
     * @memberof ServiceAccountInGroupResponse
     */
    'meta'?: PaginationMeta;
    /**
     * The links object for this particular response will be empty, since there is no pagination available for the query parameter
     * @type {object}
     * @memberof ServiceAccountInGroupResponse
     */
    'links'?: object;
    /**
     * Object which indicates whether the given service account UUIDs in the query parameter are present in the specified group or not
     * @type {{ [key: string]: boolean; }}
     * @memberof ServiceAccountInGroupResponse
     */
    'data'?: { [key: string]: boolean; };
}
/**
 *
 * @export
 * @interface ServiceAccountPagination
 */
export interface ServiceAccountPagination {
    /**
     *
     * @type {PaginationMeta}
     * @memberof ServiceAccountPagination
     */
    'meta'?: PaginationMeta;
    /**
     *
     * @type {PaginationLinks}
     * @memberof ServiceAccountPagination
     */
    'links'?: PaginationLinks;
    /**
     *
     * @type {Array<ServiceAccount>}
     * @memberof ServiceAccountPagination
     */
    'data': Array<ServiceAccount>;
}
/**
 *
 * @export
 * @interface Status
 */
export interface Status {
    /**
     *
     * @type {number}
     * @memberof Status
     */
    'api_version': number;
    /**
     *
     * @type {string}
     * @memberof Status
     */
    'commit'?: string;
}
/**
 *
 * @export
 * @interface Timestamped
 */
export interface Timestamped {
    /**
     *
     * @type {string}
     * @memberof Timestamped
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof Timestamped
     */
    'modified': string;
}
/**
 *
 * @export
 * @interface UUID
 */
export interface UUID {
    /**
     *
     * @type {string}
     * @memberof UUID
     */
    'uuid': string;
}

/**
 * AddPrincipalToGroupApi - axios parameter creator
 * @export
 */
export const AddPrincipalToGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup: async (uuid: string, groupPrincipalIn: GroupPrincipalIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('addPrincipalToGroup', 'uuid', uuid)
            // verify required parameter 'groupPrincipalIn' is not null or undefined
            assertParamExists('addPrincipalToGroup', 'groupPrincipalIn', groupPrincipalIn)
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupPrincipalIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddPrincipalToGroupApi - functional programming interface
 * @export
 */
export const AddPrincipalToGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddPrincipalToGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWithPrincipalsAndRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPrincipalToGroup(uuid, groupPrincipalIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddPrincipalToGroupApi - factory interface
 * @export
 */
export const AddPrincipalToGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddPrincipalToGroupApiFp(configuration)
    return {
        /**
         *
         * @summary Add a principal to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: any): AxiosPromise<GroupWithPrincipalsAndRoles> {
            return localVarFp.addPrincipalToGroup(uuid, groupPrincipalIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddPrincipalToGroupApi - object-oriented interface
 * @export
 * @class AddPrincipalToGroupApi
 * @extends {BaseAPI}
 */
export class AddPrincipalToGroupApi extends BaseAPI {
    /**
     *
     * @summary Add a principal to a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {GroupPrincipalIn} groupPrincipalIn Principal to add to a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddPrincipalToGroupApi
     */
    public addPrincipalToGroup(uuid: string, groupPrincipalIn: GroupPrincipalIn, options?: AxiosRequestConfig) {
        return AddPrincipalToGroupApiFp(this.configuration).addPrincipalToGroup(uuid, groupPrincipalIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddRoleToGroupApi - axios parameter creator
 * @export
 */
export const AddRoleToGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToGroup: async (uuid: string, groupRoleIn: GroupRoleIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('addRoleToGroup', 'uuid', uuid)
            // verify required parameter 'groupRoleIn' is not null or undefined
            assertParamExists('addRoleToGroup', 'groupRoleIn', groupRoleIn)
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupRoleIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddRoleToGroupApi - functional programming interface
 * @export
 */
export const AddRoleToGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddRoleToGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddRoleToGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRoleToGroup(uuid, groupRoleIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddRoleToGroupApi - factory interface
 * @export
 */
export const AddRoleToGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddRoleToGroupApiFp(configuration)
    return {
        /**
         *
         * @summary Add a role to a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {GroupRoleIn} groupRoleIn Role to add to a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: any): AxiosPromise<AddRoleToGroup200Response> {
            return localVarFp.addRoleToGroup(uuid, groupRoleIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddRoleToGroupApi - object-oriented interface
 * @export
 * @class AddRoleToGroupApi
 * @extends {BaseAPI}
 */
export class AddRoleToGroupApi extends BaseAPI {
    /**
     *
     * @summary Add a role to a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {GroupRoleIn} groupRoleIn Role to add to a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddRoleToGroupApi
     */
    public addRoleToGroup(uuid: string, groupRoleIn: GroupRoleIn, options?: AxiosRequestConfig) {
        return AddRoleToGroupApiFp(this.configuration).addRoleToGroup(uuid, groupRoleIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CreateCrossAccountRequestsApi - axios parameter creator
 * @export
 */
export const CreateCrossAccountRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a cross account request
         * @param {CrossAccountRequestIn} crossAccountRequestIn CrossAccountRequest to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCrossAccountRequests: async (crossAccountRequestIn: CrossAccountRequestIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'crossAccountRequestIn' is not null or undefined
            assertParamExists('createCrossAccountRequests', 'crossAccountRequestIn', crossAccountRequestIn)
            const localVarPath = `/cross-account-requests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crossAccountRequestIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateCrossAccountRequestsApi - functional programming interface
 * @export
 */
export const CreateCrossAccountRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateCrossAccountRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create a cross account request
         * @param {CrossAccountRequestIn} crossAccountRequestIn CrossAccountRequest to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCrossAccountRequests(crossAccountRequestIn: CrossAccountRequestIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCrossAccountRequests(crossAccountRequestIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateCrossAccountRequestsApi - factory interface
 * @export
 */
export const CreateCrossAccountRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateCrossAccountRequestsApiFp(configuration)
    return {
        /**
         *
         * @summary Create a cross account request
         * @param {CrossAccountRequestIn} crossAccountRequestIn CrossAccountRequest to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCrossAccountRequests(crossAccountRequestIn: CrossAccountRequestIn, options?: any): AxiosPromise<CrossAccountRequestOut> {
            return localVarFp.createCrossAccountRequests(crossAccountRequestIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateCrossAccountRequestsApi - object-oriented interface
 * @export
 * @class CreateCrossAccountRequestsApi
 * @extends {BaseAPI}
 */
export class CreateCrossAccountRequestsApi extends BaseAPI {
    /**
     *
     * @summary Create a cross account request
     * @param {CrossAccountRequestIn} crossAccountRequestIn CrossAccountRequest to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateCrossAccountRequestsApi
     */
    public createCrossAccountRequests(crossAccountRequestIn: CrossAccountRequestIn, options?: AxiosRequestConfig) {
        return CreateCrossAccountRequestsApiFp(this.configuration).createCrossAccountRequests(crossAccountRequestIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CreateGroupApi - axios parameter creator
 * @export
 */
export const CreateGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (group: Group, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('createGroup', 'group', group)
            const localVarPath = `/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateGroupApi - functional programming interface
 * @export
 */
export const CreateGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(group: Group, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateGroupApi - factory interface
 * @export
 */
export const CreateGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateGroupApiFp(configuration)
    return {
        /**
         *
         * @summary Create a group in a tenant
         * @param {Group} group Group to create in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(group: Group, options?: any): AxiosPromise<GroupOut> {
            return localVarFp.createGroup(group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateGroupApi - object-oriented interface
 * @export
 * @class CreateGroupApi
 * @extends {BaseAPI}
 */
export class CreateGroupApi extends BaseAPI {
    /**
     *
     * @summary Create a group in a tenant
     * @param {Group} group Group to create in tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateGroupApi
     */
    public createGroup(group: Group, options?: AxiosRequestConfig) {
        return CreateGroupApiFp(this.configuration).createGroup(group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CreateRoleApi - axios parameter creator
 * @export
 */
export const CreateRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a role for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (roleIn: RoleIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleIn' is not null or undefined
            assertParamExists('createRole', 'roleIn', roleIn)
            const localVarPath = `/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateRoleApi - functional programming interface
 * @export
 */
export const CreateRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateRoleApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create a role for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(roleIn: RoleIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(roleIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateRoleApi - factory interface
 * @export
 */
export const CreateRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateRoleApiFp(configuration)
    return {
        /**
         *
         * @summary Create a role for a tenant
         * @param {RoleIn} roleIn Role to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(roleIn: RoleIn, options?: any): AxiosPromise<RoleWithAccess> {
            return localVarFp.createRole(roleIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateRoleApi - object-oriented interface
 * @export
 * @class CreateRoleApi
 * @extends {BaseAPI}
 */
export class CreateRoleApi extends BaseAPI {
    /**
     *
     * @summary Create a role for a tenant
     * @param {RoleIn} roleIn Role to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateRoleApi
     */
    public createRole(roleIn: RoleIn, options?: AxiosRequestConfig) {
        return CreateRoleApiFp(this.configuration).createRole(roleIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeleteGroupApi - axios parameter creator
 * @export
 */
export const DeleteGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteGroup', 'uuid', uuid)
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeleteGroupApi - functional programming interface
 * @export
 */
export const DeleteGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeleteGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeleteGroupApi - factory interface
 * @export
 */
export const DeleteGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeleteGroupApiFp(configuration)
    return {
        /**
         *
         * @summary Delete a group in the tenant
         * @param {string} uuid ID of group to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeleteGroupApi - object-oriented interface
 * @export
 * @class DeleteGroupApi
 * @extends {BaseAPI}
 */
export class DeleteGroupApi extends BaseAPI {
    /**
     *
     * @summary Delete a group in the tenant
     * @param {string} uuid ID of group to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeleteGroupApi
     */
    public deleteGroup(uuid: string, options?: AxiosRequestConfig) {
        return DeleteGroupApiFp(this.configuration).deleteGroup(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeletePrincipalFromGroupApi - axios parameter creator
 * @export
 */
export const DeletePrincipalFromGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} [usernames] A comma separated list of usernames for principals to remove from the group
         * @param {string} [serviceAccounts] A comma separated list of client IDs for service accounts to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup: async (uuid: string, usernames?: string, serviceAccounts?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deletePrincipalFromGroup', 'uuid', uuid)
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (usernames !== undefined) {
                localVarQueryParameter['usernames'] = usernames;
            }

            if (serviceAccounts !== undefined) {
                localVarQueryParameter['service-accounts'] = serviceAccounts;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeletePrincipalFromGroupApi - functional programming interface
 * @export
 */
export const DeletePrincipalFromGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeletePrincipalFromGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} [usernames] A comma separated list of usernames for principals to remove from the group
         * @param {string} [serviceAccounts] A comma separated list of client IDs for service accounts to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrincipalFromGroup(uuid: string, usernames?: string, serviceAccounts?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrincipalFromGroup(uuid, usernames, serviceAccounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeletePrincipalFromGroupApi - factory interface
 * @export
 */
export const DeletePrincipalFromGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeletePrincipalFromGroupApiFp(configuration)
    return {
        /**
         *
         * @summary Remove a principal from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} [usernames] A comma separated list of usernames for principals to remove from the group
         * @param {string} [serviceAccounts] A comma separated list of client IDs for service accounts to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrincipalFromGroup(uuid: string, usernames?: string, serviceAccounts?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePrincipalFromGroup(uuid, usernames, serviceAccounts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeletePrincipalFromGroupApi - object-oriented interface
 * @export
 * @class DeletePrincipalFromGroupApi
 * @extends {BaseAPI}
 */
export class DeletePrincipalFromGroupApi extends BaseAPI {
    /**
     *
     * @summary Remove a principal from a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {string} [usernames] A comma separated list of usernames for principals to remove from the group
     * @param {string} [serviceAccounts] A comma separated list of client IDs for service accounts to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletePrincipalFromGroupApi
     */
    public deletePrincipalFromGroup(uuid: string, usernames?: string, serviceAccounts?: string, options?: AxiosRequestConfig) {
        return DeletePrincipalFromGroupApiFp(this.configuration).deletePrincipalFromGroup(uuid, usernames, serviceAccounts, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeleteRoleApi - axios parameter creator
 * @export
 */
export const DeleteRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteRole', 'uuid', uuid)
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeleteRoleApi - functional programming interface
 * @export
 */
export const DeleteRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeleteRoleApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeleteRoleApi - factory interface
 * @export
 */
export const DeleteRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeleteRoleApiFp(configuration)
    return {
        /**
         *
         * @summary Delete a role in the tenant
         * @param {string} uuid ID of role to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(uuid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRole(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeleteRoleApi - object-oriented interface
 * @export
 * @class DeleteRoleApi
 * @extends {BaseAPI}
 */
export class DeleteRoleApi extends BaseAPI {
    /**
     *
     * @summary Delete a role in the tenant
     * @param {string} uuid ID of role to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeleteRoleApi
     */
    public deleteRole(uuid: string, options?: AxiosRequestConfig) {
        return DeleteRoleApiFp(this.configuration).deleteRole(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeleteRoleFromGroupApi - axios parameter creator
 * @export
 */
export const DeleteRoleFromGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleFromGroup: async (uuid: string, roles: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteRoleFromGroup', 'uuid', uuid)
            // verify required parameter 'roles' is not null or undefined
            assertParamExists('deleteRoleFromGroup', 'roles', roles)
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (roles !== undefined) {
                localVarQueryParameter['roles'] = roles;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeleteRoleFromGroupApi - functional programming interface
 * @export
 */
export const DeleteRoleFromGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeleteRoleFromGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleFromGroup(uuid: string, roles: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleFromGroup(uuid, roles, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeleteRoleFromGroupApi - factory interface
 * @export
 */
export const DeleteRoleFromGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeleteRoleFromGroupApiFp(configuration)
    return {
        /**
         *
         * @summary Remove a role from a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleFromGroup(uuid: string, roles: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoleFromGroup(uuid, roles, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeleteRoleFromGroupApi - object-oriented interface
 * @export
 * @class DeleteRoleFromGroupApi
 * @extends {BaseAPI}
 */
export class DeleteRoleFromGroupApi extends BaseAPI {
    /**
     *
     * @summary Remove a role from a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {string} roles A comma separated list of role UUIDs for roles to remove from the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeleteRoleFromGroupApi
     */
    public deleteRoleFromGroup(uuid: string, roles: string, options?: AxiosRequestConfig) {
        return DeleteRoleFromGroupApiFp(this.configuration).deleteRoleFromGroup(uuid, roles, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GetCrossAccountRequestApi - axios parameter creator
 * @export
 */
export const GetCrossAccountRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {GetCrossAccountRequestQueryByEnum} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {GetCrossAccountRequestApprovedOnlyEnum} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossAccountRequest: async (uuid: string, queryBy?: GetCrossAccountRequestQueryByEnum, account?: string, approvedOnly?: GetCrossAccountRequestApprovedOnlyEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getCrossAccountRequest', 'uuid', uuid)
            const localVarPath = `/cross-account-requests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (queryBy !== undefined) {
                localVarQueryParameter['query_by'] = queryBy;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (approvedOnly !== undefined) {
                localVarQueryParameter['approved_only'] = approvedOnly;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetCrossAccountRequestApi - functional programming interface
 * @export
 */
export const GetCrossAccountRequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetCrossAccountRequestApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Get a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {GetCrossAccountRequestQueryByEnum} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {GetCrossAccountRequestApprovedOnlyEnum} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCrossAccountRequest(uuid: string, queryBy?: GetCrossAccountRequestQueryByEnum, account?: string, approvedOnly?: GetCrossAccountRequestApprovedOnlyEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCrossAccountRequest(uuid, queryBy, account, approvedOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetCrossAccountRequestApi - factory interface
 * @export
 */
export const GetCrossAccountRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetCrossAccountRequestApiFp(configuration)
    return {
        /**
         *
         * @summary Get a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {GetCrossAccountRequestQueryByEnum} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {GetCrossAccountRequestApprovedOnlyEnum} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCrossAccountRequest(uuid: string, queryBy?: GetCrossAccountRequestQueryByEnum, account?: string, approvedOnly?: GetCrossAccountRequestApprovedOnlyEnum, options?: any): AxiosPromise<CrossAccountRequestDetail> {
            return localVarFp.getCrossAccountRequest(uuid, queryBy, account, approvedOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetCrossAccountRequestApi - object-oriented interface
 * @export
 * @class GetCrossAccountRequestApi
 * @extends {BaseAPI}
 */
export class GetCrossAccountRequestApi extends BaseAPI {
    /**
     *
     * @summary Get a cross account request
     * @param {string} uuid ID of cross account request to get
     * @param {GetCrossAccountRequestQueryByEnum} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
     * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
     * @param {GetCrossAccountRequestApprovedOnlyEnum} [approvedOnly] Parameter for filtering resource which have been approved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetCrossAccountRequestApi
     */
    public getCrossAccountRequest(uuid: string, queryBy?: GetCrossAccountRequestQueryByEnum, account?: string, approvedOnly?: GetCrossAccountRequestApprovedOnlyEnum, options?: AxiosRequestConfig) {
        return GetCrossAccountRequestApiFp(this.configuration).getCrossAccountRequest(uuid, queryBy, account, approvedOnly, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetCrossAccountRequestQueryByEnum = {
    UserId: 'user_id',
    TargetOrg: 'target_org'
} as const;
export type GetCrossAccountRequestQueryByEnum = typeof GetCrossAccountRequestQueryByEnum[keyof typeof GetCrossAccountRequestQueryByEnum];
/**
 * @export
 */
export const GetCrossAccountRequestApprovedOnlyEnum = {
    True: 'true'
} as const;
export type GetCrossAccountRequestApprovedOnlyEnum = typeof GetCrossAccountRequestApprovedOnlyEnum[keyof typeof GetCrossAccountRequestApprovedOnlyEnum];


/**
 * GetGroupApi - axios parameter creator
 * @export
 */
export const GetGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getGroup', 'uuid', uuid)
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetGroupApi - functional programming interface
 * @export
 */
export const GetGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupWithPrincipalsAndRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetGroupApi - factory interface
 * @export
 */
export const GetGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetGroupApiFp(configuration)
    return {
        /**
         *
         * @summary Get a group in the tenant
         * @param {string} uuid ID of group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(uuid: string, options?: any): AxiosPromise<GroupWithPrincipalsAndRoles> {
            return localVarFp.getGroup(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetGroupApi - object-oriented interface
 * @export
 * @class GetGroupApi
 * @extends {BaseAPI}
 */
export class GetGroupApi extends BaseAPI {
    /**
     *
     * @summary Get a group in the tenant
     * @param {string} uuid ID of group to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetGroupApi
     */
    public getGroup(uuid: string, options?: AxiosRequestConfig) {
        return GetGroupApiFp(this.configuration).getGroup(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GetPrincipalAccessApi - axios parameter creator
 * @export
 */
export const GetPrincipalAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {GetPrincipalAccessOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {GetPrincipalAccessStatusEnum} [status] Set the status of users to get back.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess: async (application: string, username?: string, orderBy?: GetPrincipalAccessOrderByEnum, status?: GetPrincipalAccessStatusEnum, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'application' is not null or undefined
            assertParamExists('getPrincipalAccess', 'application', application)
            const localVarPath = `/access/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetPrincipalAccessApi - functional programming interface
 * @export
 */
export const GetPrincipalAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetPrincipalAccessApiAxiosParamCreator(configuration)
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {GetPrincipalAccessOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {GetPrincipalAccessStatusEnum} [status] Set the status of users to get back.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrincipalAccess(application: string, username?: string, orderBy?: GetPrincipalAccessOrderByEnum, status?: GetPrincipalAccessStatusEnum, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrincipalAccess(application, username, orderBy, status, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetPrincipalAccessApi - factory interface
 * @export
 */
export const GetPrincipalAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetPrincipalAccessApiFp(configuration)
    return {
        /**
         * Access responses are sorted in ascending order by an ID internal to the database
         * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
         * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {GetPrincipalAccessOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {GetPrincipalAccessStatusEnum} [status] Set the status of users to get back.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalAccess(application: string, username?: string, orderBy?: GetPrincipalAccessOrderByEnum, status?: GetPrincipalAccessStatusEnum, limit?: number, offset?: number, options?: any): AxiosPromise<AccessPagination> {
            return localVarFp.getPrincipalAccess(application, username, orderBy, status, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetPrincipalAccessApi - object-oriented interface
 * @export
 * @class GetPrincipalAccessApi
 * @extends {BaseAPI}
 */
export class GetPrincipalAccessApi extends BaseAPI {
    /**
     * Access responses are sorted in ascending order by an ID internal to the database
     * @summary Get the permitted access for a principal in the tenant (defaults to principal from the identity header)
     * @param {string} application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
     * @param {string} [username] Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
     * @param {GetPrincipalAccessOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
     * @param {GetPrincipalAccessStatusEnum} [status] Set the status of users to get back.
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetPrincipalAccessApi
     */
    public getPrincipalAccess(application: string, username?: string, orderBy?: GetPrincipalAccessOrderByEnum, status?: GetPrincipalAccessStatusEnum, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return GetPrincipalAccessApiFp(this.configuration).getPrincipalAccess(application, username, orderBy, status, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetPrincipalAccessOrderByEnum = {
    Application: 'application',
    ResourceType: 'resource_type',
    Verb: 'verb'
} as const;
export type GetPrincipalAccessOrderByEnum = typeof GetPrincipalAccessOrderByEnum[keyof typeof GetPrincipalAccessOrderByEnum];
/**
 * @export
 */
export const GetPrincipalAccessStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    All: 'all'
} as const;
export type GetPrincipalAccessStatusEnum = typeof GetPrincipalAccessStatusEnum[keyof typeof GetPrincipalAccessStatusEnum];


/**
 * GetPrincipalsFromGroupApi - axios parameter creator
 * @export
 */
export const GetPrincipalsFromGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {boolean} [adminOnly] Get only admin users within an account.
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {GetPrincipalsFromGroupOrderByEnum} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {GetPrincipalsFromGroupPrincipalTypeEnum} [principalType] Parameter for selecting the type of principal to be returned.
         * @param {string} [serviceAccountClientIds] By specifying a comma separated list of client IDs with this query parameter, RBAC will return an object with the specified client ID and it\&#39;s matching boolean value to flag whether the client ID is present in the group or not. This query parameter cannot be used along with any other query parameter.
         * @param {string} [serviceAccountDescription] Parameter for filtering the service accounts by their description.
         * @param {string} [serviceAccountName] Parameter for filtering the service accounts by their name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalsFromGroup: async (uuid: string, adminOnly?: boolean, principalUsername?: string, limit?: number, offset?: number, orderBy?: GetPrincipalsFromGroupOrderByEnum, usernameOnly?: boolean, principalType?: GetPrincipalsFromGroupPrincipalTypeEnum, serviceAccountClientIds?: string, serviceAccountDescription?: string, serviceAccountName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getPrincipalsFromGroup', 'uuid', uuid)
            const localVarPath = `/groups/{uuid}/principals/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (adminOnly !== undefined) {
                localVarQueryParameter['admin_only'] = adminOnly;
            }

            if (principalUsername !== undefined) {
                localVarQueryParameter['principal_username'] = principalUsername;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (usernameOnly !== undefined) {
                localVarQueryParameter['username_only'] = usernameOnly;
            }

            if (principalType !== undefined) {
                localVarQueryParameter['principal_type'] = principalType;
            }

            if (serviceAccountClientIds !== undefined) {
                localVarQueryParameter['service_account_client_ids'] = serviceAccountClientIds;
            }

            if (serviceAccountDescription !== undefined) {
                localVarQueryParameter['service_account_description'] = serviceAccountDescription;
            }

            if (serviceAccountName !== undefined) {
                localVarQueryParameter['service_account_name'] = serviceAccountName;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetPrincipalsFromGroupApi - functional programming interface
 * @export
 */
export const GetPrincipalsFromGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetPrincipalsFromGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {boolean} [adminOnly] Get only admin users within an account.
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {GetPrincipalsFromGroupOrderByEnum} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {GetPrincipalsFromGroupPrincipalTypeEnum} [principalType] Parameter for selecting the type of principal to be returned.
         * @param {string} [serviceAccountClientIds] By specifying a comma separated list of client IDs with this query parameter, RBAC will return an object with the specified client ID and it\&#39;s matching boolean value to flag whether the client ID is present in the group or not. This query parameter cannot be used along with any other query parameter.
         * @param {string} [serviceAccountDescription] Parameter for filtering the service accounts by their description.
         * @param {string} [serviceAccountName] Parameter for filtering the service accounts by their name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrincipalsFromGroup(uuid: string, adminOnly?: boolean, principalUsername?: string, limit?: number, offset?: number, orderBy?: GetPrincipalsFromGroupOrderByEnum, usernameOnly?: boolean, principalType?: GetPrincipalsFromGroupPrincipalTypeEnum, serviceAccountClientIds?: string, serviceAccountDescription?: string, serviceAccountName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPrincipalsFromGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrincipalsFromGroup(uuid, adminOnly, principalUsername, limit, offset, orderBy, usernameOnly, principalType, serviceAccountClientIds, serviceAccountDescription, serviceAccountName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetPrincipalsFromGroupApi - factory interface
 * @export
 */
export const GetPrincipalsFromGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetPrincipalsFromGroupApiFp(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary Get a list of principals from a group in the tenant
         * @param {string} uuid ID of group from which to get principals
         * @param {boolean} [adminOnly] Get only admin users within an account.
         * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {GetPrincipalsFromGroupOrderByEnum} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {GetPrincipalsFromGroupPrincipalTypeEnum} [principalType] Parameter for selecting the type of principal to be returned.
         * @param {string} [serviceAccountClientIds] By specifying a comma separated list of client IDs with this query parameter, RBAC will return an object with the specified client ID and it\&#39;s matching boolean value to flag whether the client ID is present in the group or not. This query parameter cannot be used along with any other query parameter.
         * @param {string} [serviceAccountDescription] Parameter for filtering the service accounts by their description.
         * @param {string} [serviceAccountName] Parameter for filtering the service accounts by their name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrincipalsFromGroup(uuid: string, adminOnly?: boolean, principalUsername?: string, limit?: number, offset?: number, orderBy?: GetPrincipalsFromGroupOrderByEnum, usernameOnly?: boolean, principalType?: GetPrincipalsFromGroupPrincipalTypeEnum, serviceAccountClientIds?: string, serviceAccountDescription?: string, serviceAccountName?: string, options?: any): AxiosPromise<GetPrincipalsFromGroup200Response> {
            return localVarFp.getPrincipalsFromGroup(uuid, adminOnly, principalUsername, limit, offset, orderBy, usernameOnly, principalType, serviceAccountClientIds, serviceAccountDescription, serviceAccountName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetPrincipalsFromGroupApi - object-oriented interface
 * @export
 * @class GetPrincipalsFromGroupApi
 * @extends {BaseAPI}
 */
export class GetPrincipalsFromGroupApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by username
     * @summary Get a list of principals from a group in the tenant
     * @param {string} uuid ID of group from which to get principals
     * @param {boolean} [adminOnly] Get only admin users within an account.
     * @param {string} [principalUsername] Parameter for filtering group principals by principal &#x60;username&#x60; using string contains search.
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {GetPrincipalsFromGroupOrderByEnum} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
     * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
     * @param {GetPrincipalsFromGroupPrincipalTypeEnum} [principalType] Parameter for selecting the type of principal to be returned.
     * @param {string} [serviceAccountClientIds] By specifying a comma separated list of client IDs with this query parameter, RBAC will return an object with the specified client ID and it\&#39;s matching boolean value to flag whether the client ID is present in the group or not. This query parameter cannot be used along with any other query parameter.
     * @param {string} [serviceAccountDescription] Parameter for filtering the service accounts by their description.
     * @param {string} [serviceAccountName] Parameter for filtering the service accounts by their name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetPrincipalsFromGroupApi
     */
    public getPrincipalsFromGroup(uuid: string, adminOnly?: boolean, principalUsername?: string, limit?: number, offset?: number, orderBy?: GetPrincipalsFromGroupOrderByEnum, usernameOnly?: boolean, principalType?: GetPrincipalsFromGroupPrincipalTypeEnum, serviceAccountClientIds?: string, serviceAccountDescription?: string, serviceAccountName?: string, options?: AxiosRequestConfig) {
        return GetPrincipalsFromGroupApiFp(this.configuration).getPrincipalsFromGroup(uuid, adminOnly, principalUsername, limit, offset, orderBy, usernameOnly, principalType, serviceAccountClientIds, serviceAccountDescription, serviceAccountName, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetPrincipalsFromGroupOrderByEnum = {
    Username: 'username'
} as const;
export type GetPrincipalsFromGroupOrderByEnum = typeof GetPrincipalsFromGroupOrderByEnum[keyof typeof GetPrincipalsFromGroupOrderByEnum];
/**
 * @export
 */
export const GetPrincipalsFromGroupPrincipalTypeEnum = {
    ServiceAccount: 'service-account',
    User: 'user'
} as const;
export type GetPrincipalsFromGroupPrincipalTypeEnum = typeof GetPrincipalsFromGroupPrincipalTypeEnum[keyof typeof GetPrincipalsFromGroupPrincipalTypeEnum];


/**
 * GetRoleApi - axios parameter creator
 * @export
 */
export const GetRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {GetRoleScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (uuid: string, scope?: GetRoleScopeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRole', 'uuid', uuid)
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetRoleApi - functional programming interface
 * @export
 */
export const GetRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetRoleApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {GetRoleScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(uuid: string, scope?: GetRoleScopeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(uuid, scope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetRoleApi - factory interface
 * @export
 */
export const GetRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetRoleApiFp(configuration)
    return {
        /**
         *
         * @summary Get a role in the tenant
         * @param {string} uuid ID of role to get
         * @param {GetRoleScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(uuid: string, scope?: GetRoleScopeEnum, options?: any): AxiosPromise<RoleWithAccess> {
            return localVarFp.getRole(uuid, scope, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetRoleApi - object-oriented interface
 * @export
 * @class GetRoleApi
 * @extends {BaseAPI}
 */
export class GetRoleApi extends BaseAPI {
    /**
     *
     * @summary Get a role in the tenant
     * @param {string} uuid ID of role to get
     * @param {GetRoleScopeEnum} [scope] Parameter for filtering resource by scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetRoleApi
     */
    public getRole(uuid: string, scope?: GetRoleScopeEnum, options?: AxiosRequestConfig) {
        return GetRoleApiFp(this.configuration).getRole(uuid, scope, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRoleScopeEnum = {
    OrgId: 'org_id',
    Principal: 'principal'
} as const;
export type GetRoleScopeEnum = typeof GetRoleScopeEnum[keyof typeof GetRoleScopeEnum];


/**
 * GetRoleAccessApi - axios parameter creator
 * @export
 */
export const GetRoleAccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAccess: async (uuid: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRoleAccess', 'uuid', uuid)
            const localVarPath = `/roles/{uuid}/access/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetRoleAccessApi - functional programming interface
 * @export
 */
export const GetRoleAccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetRoleAccessApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAccess(uuid: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAccess(uuid, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetRoleAccessApi - factory interface
 * @export
 */
export const GetRoleAccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetRoleAccessApiFp(configuration)
    return {
        /**
         *
         * @summary Get access for a role in the tenant
         * @param {string} uuid ID of the role
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAccess(uuid: string, limit?: number, offset?: number, options?: any): AxiosPromise<AccessPagination> {
            return localVarFp.getRoleAccess(uuid, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetRoleAccessApi - object-oriented interface
 * @export
 * @class GetRoleAccessApi
 * @extends {BaseAPI}
 */
export class GetRoleAccessApi extends BaseAPI {
    /**
     *
     * @summary Get access for a role in the tenant
     * @param {string} uuid ID of the role
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetRoleAccessApi
     */
    public getRoleAccess(uuid: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return GetRoleAccessApiFp(this.configuration).getRoleAccess(uuid, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GetStatusApi - axios parameter creator
 * @export
 */
export const GetStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetStatusApi - functional programming interface
 * @export
 */
export const GetStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetStatusApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetStatusApi - factory interface
 * @export
 */
export const GetStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetStatusApiFp(configuration)
    return {
        /**
         *
         * @summary Obtain server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<Status> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetStatusApi - object-oriented interface
 * @export
 * @class GetStatusApi
 * @extends {BaseAPI}
 */
export class GetStatusApi extends BaseAPI {
    /**
     *
     * @summary Obtain server status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetStatusApi
     */
    public getStatus(options?: AxiosRequestConfig) {
        return GetStatusApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ListCrossAccountRequestsApi - axios parameter creator
 * @export
 */
export const ListCrossAccountRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by created_at
         * @summary List the cross account requests for a user or account
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListCrossAccountRequestsQueryByEnum} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {string} [orgId] Parameter for filtering resource by an org id. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by org id.
         * @param {ListCrossAccountRequestsApprovedOnlyEnum} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {ListCrossAccountRequestsStatusEnum} [status] Parameter for filtering resource based on status.
         * @param {ListCrossAccountRequestsOrderByEnum} [orderBy] Parameter for ordering by field. For inverse ordering, use \&#39;-\&#39;, e.g. ?order_by&#x3D;-start_date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrossAccountRequests: async (limit?: number, offset?: number, queryBy?: ListCrossAccountRequestsQueryByEnum, account?: string, orgId?: string, approvedOnly?: ListCrossAccountRequestsApprovedOnlyEnum, status?: ListCrossAccountRequestsStatusEnum, orderBy?: ListCrossAccountRequestsOrderByEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cross-account-requests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (queryBy !== undefined) {
                localVarQueryParameter['query_by'] = queryBy;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['org_id'] = orgId;
            }

            if (approvedOnly !== undefined) {
                localVarQueryParameter['approved_only'] = approvedOnly;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListCrossAccountRequestsApi - functional programming interface
 * @export
 */
export const ListCrossAccountRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListCrossAccountRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by created_at
         * @summary List the cross account requests for a user or account
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListCrossAccountRequestsQueryByEnum} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {string} [orgId] Parameter for filtering resource by an org id. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by org id.
         * @param {ListCrossAccountRequestsApprovedOnlyEnum} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {ListCrossAccountRequestsStatusEnum} [status] Parameter for filtering resource based on status.
         * @param {ListCrossAccountRequestsOrderByEnum} [orderBy] Parameter for ordering by field. For inverse ordering, use \&#39;-\&#39;, e.g. ?order_by&#x3D;-start_date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCrossAccountRequests(limit?: number, offset?: number, queryBy?: ListCrossAccountRequestsQueryByEnum, account?: string, orgId?: string, approvedOnly?: ListCrossAccountRequestsApprovedOnlyEnum, status?: ListCrossAccountRequestsStatusEnum, orderBy?: ListCrossAccountRequestsOrderByEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCrossAccountRequests(limit, offset, queryBy, account, orgId, approvedOnly, status, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListCrossAccountRequestsApi - factory interface
 * @export
 */
export const ListCrossAccountRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListCrossAccountRequestsApiFp(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by created_at
         * @summary List the cross account requests for a user or account
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListCrossAccountRequestsQueryByEnum} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
         * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
         * @param {string} [orgId] Parameter for filtering resource by an org id. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by org id.
         * @param {ListCrossAccountRequestsApprovedOnlyEnum} [approvedOnly] Parameter for filtering resource which have been approved.
         * @param {ListCrossAccountRequestsStatusEnum} [status] Parameter for filtering resource based on status.
         * @param {ListCrossAccountRequestsOrderByEnum} [orderBy] Parameter for ordering by field. For inverse ordering, use \&#39;-\&#39;, e.g. ?order_by&#x3D;-start_date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCrossAccountRequests(limit?: number, offset?: number, queryBy?: ListCrossAccountRequestsQueryByEnum, account?: string, orgId?: string, approvedOnly?: ListCrossAccountRequestsApprovedOnlyEnum, status?: ListCrossAccountRequestsStatusEnum, orderBy?: ListCrossAccountRequestsOrderByEnum, options?: any): AxiosPromise<CrossAccountRequestPagination> {
            return localVarFp.listCrossAccountRequests(limit, offset, queryBy, account, orgId, approvedOnly, status, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListCrossAccountRequestsApi - object-oriented interface
 * @export
 * @class ListCrossAccountRequestsApi
 * @extends {BaseAPI}
 */
export class ListCrossAccountRequestsApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by created_at
     * @summary List the cross account requests for a user or account
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {ListCrossAccountRequestsQueryByEnum} [queryBy] Parameter for filtering resource by either a user\&#39;s ID, or a client\&#39;s org. The default value is target_org.
     * @param {string} [account] Parameter for filtering resource by an account number. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by account number.
     * @param {string} [orgId] Parameter for filtering resource by an org id. Value can be a comma-separated list of ids. To be used in tandem with ?query_by&#x3D;user_id to further filter a user\&#39;s requests by org id.
     * @param {ListCrossAccountRequestsApprovedOnlyEnum} [approvedOnly] Parameter for filtering resource which have been approved.
     * @param {ListCrossAccountRequestsStatusEnum} [status] Parameter for filtering resource based on status.
     * @param {ListCrossAccountRequestsOrderByEnum} [orderBy] Parameter for ordering by field. For inverse ordering, use \&#39;-\&#39;, e.g. ?order_by&#x3D;-start_date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListCrossAccountRequestsApi
     */
    public listCrossAccountRequests(limit?: number, offset?: number, queryBy?: ListCrossAccountRequestsQueryByEnum, account?: string, orgId?: string, approvedOnly?: ListCrossAccountRequestsApprovedOnlyEnum, status?: ListCrossAccountRequestsStatusEnum, orderBy?: ListCrossAccountRequestsOrderByEnum, options?: AxiosRequestConfig) {
        return ListCrossAccountRequestsApiFp(this.configuration).listCrossAccountRequests(limit, offset, queryBy, account, orgId, approvedOnly, status, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListCrossAccountRequestsQueryByEnum = {
    UserId: 'user_id',
    TargetOrg: 'target_org'
} as const;
export type ListCrossAccountRequestsQueryByEnum = typeof ListCrossAccountRequestsQueryByEnum[keyof typeof ListCrossAccountRequestsQueryByEnum];
/**
 * @export
 */
export const ListCrossAccountRequestsApprovedOnlyEnum = {
    True: 'true'
} as const;
export type ListCrossAccountRequestsApprovedOnlyEnum = typeof ListCrossAccountRequestsApprovedOnlyEnum[keyof typeof ListCrossAccountRequestsApprovedOnlyEnum];
/**
 * @export
 */
export const ListCrossAccountRequestsStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Denied: 'denied',
    Cancelled: 'cancelled',
    Expired: 'expired'
} as const;
export type ListCrossAccountRequestsStatusEnum = typeof ListCrossAccountRequestsStatusEnum[keyof typeof ListCrossAccountRequestsStatusEnum];
/**
 * @export
 */
export const ListCrossAccountRequestsOrderByEnum = {
    RequestId: 'request_id',
    StartDate: 'start_date',
    EndDate: 'end_date',
    Created: 'created',
    Modified: 'modified',
    Status: 'status'
} as const;
export type ListCrossAccountRequestsOrderByEnum = typeof ListCrossAccountRequestsOrderByEnum[keyof typeof ListCrossAccountRequestsOrderByEnum];


/**
 * ListGroupsApi - axios parameter creator
 * @export
 */
export const ListGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {ListGroupsNameMatchEnum} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {ListGroupsScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [excludeUsername] A username for a principal to filter for groups where principal is not a member and can be added manually
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {ListGroupsRoleDiscriminatorEnum} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {ListGroupsOrderByEnum} [orderBy] Parameter for ordering groups by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {boolean} [platformDefault] An optional flag to return either platform default or non-platform default groups.
         * @param {boolean} [adminDefault] An optional flag to return either admin default or non-admin default groups.
         * @param {boolean} [system] An optional flag to return either system or non-system groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (limit?: number, offset?: number, name?: string, nameMatch?: ListGroupsNameMatchEnum, scope?: ListGroupsScopeEnum, username?: string, excludeUsername?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: ListGroupsRoleDiscriminatorEnum, orderBy?: ListGroupsOrderByEnum, platformDefault?: boolean, adminDefault?: boolean, system?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameMatch !== undefined) {
                localVarQueryParameter['name_match'] = nameMatch;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (excludeUsername !== undefined) {
                localVarQueryParameter['exclude_username'] = excludeUsername;
            }

            if (uuid) {
                localVarQueryParameter['uuid'] = uuid.join(COLLECTION_FORMATS.csv);
            }

            if (roleNames) {
                localVarQueryParameter['role_names'] = roleNames.join(COLLECTION_FORMATS.csv);
            }

            if (roleDiscriminator !== undefined) {
                localVarQueryParameter['role_discriminator'] = roleDiscriminator;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (platformDefault !== undefined) {
                localVarQueryParameter['platform_default'] = platformDefault;
            }

            if (adminDefault !== undefined) {
                localVarQueryParameter['admin_default'] = adminDefault;
            }

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListGroupsApi - functional programming interface
 * @export
 */
export const ListGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {ListGroupsNameMatchEnum} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {ListGroupsScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [excludeUsername] A username for a principal to filter for groups where principal is not a member and can be added manually
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {ListGroupsRoleDiscriminatorEnum} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {ListGroupsOrderByEnum} [orderBy] Parameter for ordering groups by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {boolean} [platformDefault] An optional flag to return either platform default or non-platform default groups.
         * @param {boolean} [adminDefault] An optional flag to return either admin default or non-admin default groups.
         * @param {boolean} [system] An optional flag to return either system or non-system groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(limit?: number, offset?: number, name?: string, nameMatch?: ListGroupsNameMatchEnum, scope?: ListGroupsScopeEnum, username?: string, excludeUsername?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: ListGroupsRoleDiscriminatorEnum, orderBy?: ListGroupsOrderByEnum, platformDefault?: boolean, adminDefault?: boolean, system?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(limit, offset, name, nameMatch, scope, username, excludeUsername, uuid, roleNames, roleDiscriminator, orderBy, platformDefault, adminDefault, system, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListGroupsApi - factory interface
 * @export
 */
export const ListGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListGroupsApiFp(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by group name
         * @summary List the groups for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {ListGroupsNameMatchEnum} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {ListGroupsScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {string} [username] A username for a principal to filter for groups
         * @param {string} [excludeUsername] A username for a principal to filter for groups where principal is not a member and can be added manually
         * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
         * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
         * @param {ListGroupsRoleDiscriminatorEnum} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
         * @param {ListGroupsOrderByEnum} [orderBy] Parameter for ordering groups by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {boolean} [platformDefault] An optional flag to return either platform default or non-platform default groups.
         * @param {boolean} [adminDefault] An optional flag to return either admin default or non-admin default groups.
         * @param {boolean} [system] An optional flag to return either system or non-system groups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, name?: string, nameMatch?: ListGroupsNameMatchEnum, scope?: ListGroupsScopeEnum, username?: string, excludeUsername?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: ListGroupsRoleDiscriminatorEnum, orderBy?: ListGroupsOrderByEnum, platformDefault?: boolean, adminDefault?: boolean, system?: boolean, options?: any): AxiosPromise<GroupPagination> {
            return localVarFp.listGroups(limit, offset, name, nameMatch, scope, username, excludeUsername, uuid, roleNames, roleDiscriminator, orderBy, platformDefault, adminDefault, system, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListGroupsApi - object-oriented interface
 * @export
 * @class ListGroupsApi
 * @extends {BaseAPI}
 */
export class ListGroupsApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by group name
     * @summary List the groups for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {ListGroupsNameMatchEnum} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
     * @param {ListGroupsScopeEnum} [scope] Parameter for filtering resource by scope.
     * @param {string} [username] A username for a principal to filter for groups
     * @param {string} [excludeUsername] A username for a principal to filter for groups where principal is not a member and can be added manually
     * @param {Array<string>} [uuid] A list of UUIDs to filter listed groups.
     * @param {Array<string>} [roleNames] List of role name to filter for groups. It is exact match but case-insensitive
     * @param {ListGroupsRoleDiscriminatorEnum} [roleDiscriminator] Discriminator that works with role_names to indicate matching all/any of the role names
     * @param {ListGroupsOrderByEnum} [orderBy] Parameter for ordering groups by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {boolean} [platformDefault] An optional flag to return either platform default or non-platform default groups.
     * @param {boolean} [adminDefault] An optional flag to return either admin default or non-admin default groups.
     * @param {boolean} [system] An optional flag to return either system or non-system groups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListGroupsApi
     */
    public listGroups(limit?: number, offset?: number, name?: string, nameMatch?: ListGroupsNameMatchEnum, scope?: ListGroupsScopeEnum, username?: string, excludeUsername?: string, uuid?: Array<string>, roleNames?: Array<string>, roleDiscriminator?: ListGroupsRoleDiscriminatorEnum, orderBy?: ListGroupsOrderByEnum, platformDefault?: boolean, adminDefault?: boolean, system?: boolean, options?: AxiosRequestConfig) {
        return ListGroupsApiFp(this.configuration).listGroups(limit, offset, name, nameMatch, scope, username, excludeUsername, uuid, roleNames, roleDiscriminator, orderBy, platformDefault, adminDefault, system, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListGroupsNameMatchEnum = {
    Partial: 'partial',
    Exact: 'exact'
} as const;
export type ListGroupsNameMatchEnum = typeof ListGroupsNameMatchEnum[keyof typeof ListGroupsNameMatchEnum];
/**
 * @export
 */
export const ListGroupsScopeEnum = {
    OrgId: 'org_id',
    Principal: 'principal'
} as const;
export type ListGroupsScopeEnum = typeof ListGroupsScopeEnum[keyof typeof ListGroupsScopeEnum];
/**
 * @export
 */
export const ListGroupsRoleDiscriminatorEnum = {
    All: 'all',
    Any: 'any'
} as const;
export type ListGroupsRoleDiscriminatorEnum = typeof ListGroupsRoleDiscriminatorEnum[keyof typeof ListGroupsRoleDiscriminatorEnum];
/**
 * @export
 */
export const ListGroupsOrderByEnum = {
    Name: 'name',
    Modified: 'modified',
    PrincipalCount: 'principalCount',
    PolicyCount: 'policyCount'
} as const;
export type ListGroupsOrderByEnum = typeof ListGroupsOrderByEnum[keyof typeof ListGroupsOrderByEnum];


/**
 * ListPermissionOptionsApi - axios parameter creator
 * @export
 */
export const ListPermissionOptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, options of application is returned. And could be resource_type or verb on demand.
         * @summary List the available options for fields of permissions for a tenant
         * @param {ListPermissionOptionsFieldEnum} field specify which fields of permission to display
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [application] Filter returned options based on application. You may also use a comma-separated list to filter on multiple applications.
         * @param {string} [resourceType] Filter returned options based on resource_type. You may also use a comma-separated list to filter on multiple resource_types.
         * @param {string} [verb] Filter returned options based on verb. You may also use a comma-separated list to filter on multiple verbs.
         * @param {ListPermissionOptionsExcludeGlobalsEnum} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission option with a global allowance on the supplied \&#39;?field&#x3D;\&#39; value of \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {ListPermissionOptionsAllowedOnlyEnum} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionOptions: async (field: ListPermissionOptionsFieldEnum, limit?: number, offset?: number, application?: string, resourceType?: string, verb?: string, excludeGlobals?: ListPermissionOptionsExcludeGlobalsEnum, allowedOnly?: ListPermissionOptionsAllowedOnlyEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'field' is not null or undefined
            assertParamExists('listPermissionOptions', 'field', field)
            const localVarPath = `/permissions/options/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (field !== undefined) {
                localVarQueryParameter['field'] = field;
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (verb !== undefined) {
                localVarQueryParameter['verb'] = verb;
            }

            if (excludeGlobals !== undefined) {
                localVarQueryParameter['exclude_globals'] = excludeGlobals;
            }

            if (allowedOnly !== undefined) {
                localVarQueryParameter['allowed_only'] = allowedOnly;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListPermissionOptionsApi - functional programming interface
 * @export
 */
export const ListPermissionOptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListPermissionOptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * By default, options of application is returned. And could be resource_type or verb on demand.
         * @summary List the available options for fields of permissions for a tenant
         * @param {ListPermissionOptionsFieldEnum} field specify which fields of permission to display
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [application] Filter returned options based on application. You may also use a comma-separated list to filter on multiple applications.
         * @param {string} [resourceType] Filter returned options based on resource_type. You may also use a comma-separated list to filter on multiple resource_types.
         * @param {string} [verb] Filter returned options based on verb. You may also use a comma-separated list to filter on multiple verbs.
         * @param {ListPermissionOptionsExcludeGlobalsEnum} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission option with a global allowance on the supplied \&#39;?field&#x3D;\&#39; value of \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {ListPermissionOptionsAllowedOnlyEnum} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissionOptions(field: ListPermissionOptionsFieldEnum, limit?: number, offset?: number, application?: string, resourceType?: string, verb?: string, excludeGlobals?: ListPermissionOptionsExcludeGlobalsEnum, allowedOnly?: ListPermissionOptionsAllowedOnlyEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionOptionsPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissionOptions(field, limit, offset, application, resourceType, verb, excludeGlobals, allowedOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListPermissionOptionsApi - factory interface
 * @export
 */
export const ListPermissionOptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListPermissionOptionsApiFp(configuration)
    return {
        /**
         * By default, options of application is returned. And could be resource_type or verb on demand.
         * @summary List the available options for fields of permissions for a tenant
         * @param {ListPermissionOptionsFieldEnum} field specify which fields of permission to display
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [application] Filter returned options based on application. You may also use a comma-separated list to filter on multiple applications.
         * @param {string} [resourceType] Filter returned options based on resource_type. You may also use a comma-separated list to filter on multiple resource_types.
         * @param {string} [verb] Filter returned options based on verb. You may also use a comma-separated list to filter on multiple verbs.
         * @param {ListPermissionOptionsExcludeGlobalsEnum} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission option with a global allowance on the supplied \&#39;?field&#x3D;\&#39; value of \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {ListPermissionOptionsAllowedOnlyEnum} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissionOptions(field: ListPermissionOptionsFieldEnum, limit?: number, offset?: number, application?: string, resourceType?: string, verb?: string, excludeGlobals?: ListPermissionOptionsExcludeGlobalsEnum, allowedOnly?: ListPermissionOptionsAllowedOnlyEnum, options?: any): AxiosPromise<PermissionOptionsPagination> {
            return localVarFp.listPermissionOptions(field, limit, offset, application, resourceType, verb, excludeGlobals, allowedOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListPermissionOptionsApi - object-oriented interface
 * @export
 * @class ListPermissionOptionsApi
 * @extends {BaseAPI}
 */
export class ListPermissionOptionsApi extends BaseAPI {
    /**
     * By default, options of application is returned. And could be resource_type or verb on demand.
     * @summary List the available options for fields of permissions for a tenant
     * @param {ListPermissionOptionsFieldEnum} field specify which fields of permission to display
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [application] Filter returned options based on application. You may also use a comma-separated list to filter on multiple applications.
     * @param {string} [resourceType] Filter returned options based on resource_type. You may also use a comma-separated list to filter on multiple resource_types.
     * @param {string} [verb] Filter returned options based on verb. You may also use a comma-separated list to filter on multiple verbs.
     * @param {ListPermissionOptionsExcludeGlobalsEnum} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission option with a global allowance on the supplied \&#39;?field&#x3D;\&#39; value of \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
     * @param {ListPermissionOptionsAllowedOnlyEnum} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListPermissionOptionsApi
     */
    public listPermissionOptions(field: ListPermissionOptionsFieldEnum, limit?: number, offset?: number, application?: string, resourceType?: string, verb?: string, excludeGlobals?: ListPermissionOptionsExcludeGlobalsEnum, allowedOnly?: ListPermissionOptionsAllowedOnlyEnum, options?: AxiosRequestConfig) {
        return ListPermissionOptionsApiFp(this.configuration).listPermissionOptions(field, limit, offset, application, resourceType, verb, excludeGlobals, allowedOnly, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListPermissionOptionsFieldEnum = {
    Application: 'application',
    ResourceType: 'resource_type',
    Verb: 'verb'
} as const;
export type ListPermissionOptionsFieldEnum = typeof ListPermissionOptionsFieldEnum[keyof typeof ListPermissionOptionsFieldEnum];
/**
 * @export
 */
export const ListPermissionOptionsExcludeGlobalsEnum = {
    True: 'true',
    False: 'false'
} as const;
export type ListPermissionOptionsExcludeGlobalsEnum = typeof ListPermissionOptionsExcludeGlobalsEnum[keyof typeof ListPermissionOptionsExcludeGlobalsEnum];
/**
 * @export
 */
export const ListPermissionOptionsAllowedOnlyEnum = {
    True: 'true',
    False: 'false'
} as const;
export type ListPermissionOptionsAllowedOnlyEnum = typeof ListPermissionOptionsAllowedOnlyEnum[keyof typeof ListPermissionOptionsAllowedOnlyEnum];


/**
 * ListPermissionsApi - axios parameter creator
 * @export
 */
export const ListPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by permission application.
         * @summary List the permissions for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListPermissionsOrderByEnum} [orderBy] Parameter for ordering permissions by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {string} [application] Exact match for the application name of a permission. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [resourceType] Exact match for the resource type name of a permission. You may also use a comma-separated list to match on multiple resource_types.
         * @param {string} [verb] Exact match for the operation verb name of a permission You may also use a comma-separated list to match on multiple verbs.
         * @param {string} [permission] Partial match for the aggregate permission value name of a permission object.
         * @param {ListPermissionsExcludeGlobalsEnum} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission with a global allowance on either \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {string} [excludeRoles] An optional string filter which accepts one or more role UUIDs, comma-separated, to return permissions not associated with the supplied role(s).
         * @param {ListPermissionsAllowedOnlyEnum} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: async (limit?: number, offset?: number, orderBy?: ListPermissionsOrderByEnum, application?: string, resourceType?: string, verb?: string, permission?: string, excludeGlobals?: ListPermissionsExcludeGlobalsEnum, excludeRoles?: string, allowedOnly?: ListPermissionsAllowedOnlyEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (verb !== undefined) {
                localVarQueryParameter['verb'] = verb;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }

            if (excludeGlobals !== undefined) {
                localVarQueryParameter['exclude_globals'] = excludeGlobals;
            }

            if (excludeRoles !== undefined) {
                localVarQueryParameter['exclude_roles'] = excludeRoles;
            }

            if (allowedOnly !== undefined) {
                localVarQueryParameter['allowed_only'] = allowedOnly;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListPermissionsApi - functional programming interface
 * @export
 */
export const ListPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by permission application.
         * @summary List the permissions for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListPermissionsOrderByEnum} [orderBy] Parameter for ordering permissions by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {string} [application] Exact match for the application name of a permission. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [resourceType] Exact match for the resource type name of a permission. You may also use a comma-separated list to match on multiple resource_types.
         * @param {string} [verb] Exact match for the operation verb name of a permission You may also use a comma-separated list to match on multiple verbs.
         * @param {string} [permission] Partial match for the aggregate permission value name of a permission object.
         * @param {ListPermissionsExcludeGlobalsEnum} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission with a global allowance on either \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {string} [excludeRoles] An optional string filter which accepts one or more role UUIDs, comma-separated, to return permissions not associated with the supplied role(s).
         * @param {ListPermissionsAllowedOnlyEnum} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissions(limit?: number, offset?: number, orderBy?: ListPermissionsOrderByEnum, application?: string, resourceType?: string, verb?: string, permission?: string, excludeGlobals?: ListPermissionsExcludeGlobalsEnum, excludeRoles?: string, allowedOnly?: ListPermissionsAllowedOnlyEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissions(limit, offset, orderBy, application, resourceType, verb, permission, excludeGlobals, excludeRoles, allowedOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListPermissionsApi - factory interface
 * @export
 */
export const ListPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListPermissionsApiFp(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by permission application.
         * @summary List the permissions for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListPermissionsOrderByEnum} [orderBy] Parameter for ordering permissions by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
         * @param {string} [application] Exact match for the application name of a permission. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [resourceType] Exact match for the resource type name of a permission. You may also use a comma-separated list to match on multiple resource_types.
         * @param {string} [verb] Exact match for the operation verb name of a permission You may also use a comma-separated list to match on multiple verbs.
         * @param {string} [permission] Partial match for the aggregate permission value name of a permission object.
         * @param {ListPermissionsExcludeGlobalsEnum} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission with a global allowance on either \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
         * @param {string} [excludeRoles] An optional string filter which accepts one or more role UUIDs, comma-separated, to return permissions not associated with the supplied role(s).
         * @param {ListPermissionsAllowedOnlyEnum} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(limit?: number, offset?: number, orderBy?: ListPermissionsOrderByEnum, application?: string, resourceType?: string, verb?: string, permission?: string, excludeGlobals?: ListPermissionsExcludeGlobalsEnum, excludeRoles?: string, allowedOnly?: ListPermissionsAllowedOnlyEnum, options?: any): AxiosPromise<PermissionPagination> {
            return localVarFp.listPermissions(limit, offset, orderBy, application, resourceType, verb, permission, excludeGlobals, excludeRoles, allowedOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListPermissionsApi - object-oriented interface
 * @export
 * @class ListPermissionsApi
 * @extends {BaseAPI}
 */
export class ListPermissionsApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by permission application.
     * @summary List the permissions for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {ListPermissionsOrderByEnum} [orderBy] Parameter for ordering permissions by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-application
     * @param {string} [application] Exact match for the application name of a permission. You may also use a comma-separated list to match on multiple applications.
     * @param {string} [resourceType] Exact match for the resource type name of a permission. You may also use a comma-separated list to match on multiple resource_types.
     * @param {string} [verb] Exact match for the operation verb name of a permission You may also use a comma-separated list to match on multiple verbs.
     * @param {string} [permission] Partial match for the aggregate permission value name of a permission object.
     * @param {ListPermissionsExcludeGlobalsEnum} [excludeGlobals] If set to \&#39;true\&#39;, this will exclude any permission with a global allowance on either \&#39;application\&#39;, \&#39;resource_type\&#39; or \&#39;verb\&#39;. The default is \&#39;false\&#39;.
     * @param {string} [excludeRoles] An optional string filter which accepts one or more role UUIDs, comma-separated, to return permissions not associated with the supplied role(s).
     * @param {ListPermissionsAllowedOnlyEnum} [allowedOnly] If set to \&#39;true\&#39;, this will exclude any permission with a role where the \&#39;application\&#39; is not in the role create allow list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListPermissionsApi
     */
    public listPermissions(limit?: number, offset?: number, orderBy?: ListPermissionsOrderByEnum, application?: string, resourceType?: string, verb?: string, permission?: string, excludeGlobals?: ListPermissionsExcludeGlobalsEnum, excludeRoles?: string, allowedOnly?: ListPermissionsAllowedOnlyEnum, options?: AxiosRequestConfig) {
        return ListPermissionsApiFp(this.configuration).listPermissions(limit, offset, orderBy, application, resourceType, verb, permission, excludeGlobals, excludeRoles, allowedOnly, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListPermissionsOrderByEnum = {
    Application: 'application',
    ResourceType: 'resource_type',
    Verb: 'verb',
    Permission: 'permission'
} as const;
export type ListPermissionsOrderByEnum = typeof ListPermissionsOrderByEnum[keyof typeof ListPermissionsOrderByEnum];
/**
 * @export
 */
export const ListPermissionsExcludeGlobalsEnum = {
    True: 'true',
    False: 'false'
} as const;
export type ListPermissionsExcludeGlobalsEnum = typeof ListPermissionsExcludeGlobalsEnum[keyof typeof ListPermissionsExcludeGlobalsEnum];
/**
 * @export
 */
export const ListPermissionsAllowedOnlyEnum = {
    True: 'true',
    False: 'false'
} as const;
export type ListPermissionsAllowedOnlyEnum = typeof ListPermissionsAllowedOnlyEnum[keyof typeof ListPermissionsAllowedOnlyEnum];


/**
 * ListPrincipalsApi - axios parameter creator
 * @export
 */
export const ListPrincipalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListPrincipalsMatchCriteriaEnum} [matchCriteria] Parameter for specifying the matching criteria for an object\&#39;s name and/or email. Currently, match_criteria of partial searches for a username/email using \&quot;starts with\&quot; pattern.
         * @param {string} [usernames] Comma separated usernames of principals to get. If match_criteria is specified, only the first username will be picked up for search.
         * @param {ListPrincipalsSortOrderEnum} [sortOrder] The sort order of the query, either ascending or descending. Defaults to ascending.
         * @param {string} [email] E-mail address of principal to search for. Could be combined with match_criteria for searching.
         * @param {ListPrincipalsStatusEnum} [status] Set the status of users to get back.
         * @param {boolean} [adminOnly] Get only admin users within an account. Setting this would ignore the parameters: usernames, email
         * @param {ListPrincipalsOrderByEnum} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {ListPrincipalsTypeEnum} [type] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals: async (limit?: number, offset?: number, matchCriteria?: ListPrincipalsMatchCriteriaEnum, usernames?: string, sortOrder?: ListPrincipalsSortOrderEnum, email?: string, status?: ListPrincipalsStatusEnum, adminOnly?: boolean, orderBy?: ListPrincipalsOrderByEnum, usernameOnly?: boolean, type?: ListPrincipalsTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/principals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (matchCriteria !== undefined) {
                localVarQueryParameter['match_criteria'] = matchCriteria;
            }

            if (usernames !== undefined) {
                localVarQueryParameter['usernames'] = usernames;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (adminOnly !== undefined) {
                localVarQueryParameter['admin_only'] = adminOnly;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (usernameOnly !== undefined) {
                localVarQueryParameter['username_only'] = usernameOnly;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListPrincipalsApi - functional programming interface
 * @export
 */
export const ListPrincipalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListPrincipalsApiAxiosParamCreator(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListPrincipalsMatchCriteriaEnum} [matchCriteria] Parameter for specifying the matching criteria for an object\&#39;s name and/or email. Currently, match_criteria of partial searches for a username/email using \&quot;starts with\&quot; pattern.
         * @param {string} [usernames] Comma separated usernames of principals to get. If match_criteria is specified, only the first username will be picked up for search.
         * @param {ListPrincipalsSortOrderEnum} [sortOrder] The sort order of the query, either ascending or descending. Defaults to ascending.
         * @param {string} [email] E-mail address of principal to search for. Could be combined with match_criteria for searching.
         * @param {ListPrincipalsStatusEnum} [status] Set the status of users to get back.
         * @param {boolean} [adminOnly] Get only admin users within an account. Setting this would ignore the parameters: usernames, email
         * @param {ListPrincipalsOrderByEnum} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {ListPrincipalsTypeEnum} [type] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPrincipals(limit?: number, offset?: number, matchCriteria?: ListPrincipalsMatchCriteriaEnum, usernames?: string, sortOrder?: ListPrincipalsSortOrderEnum, email?: string, status?: ListPrincipalsStatusEnum, adminOnly?: boolean, orderBy?: ListPrincipalsOrderByEnum, usernameOnly?: boolean, type?: ListPrincipalsTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPrincipals200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPrincipals(limit, offset, matchCriteria, usernames, sortOrder, email, status, adminOnly, orderBy, usernameOnly, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListPrincipalsApi - factory interface
 * @export
 */
export const ListPrincipalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListPrincipalsApiFp(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by username
         * @summary List the principals for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListPrincipalsMatchCriteriaEnum} [matchCriteria] Parameter for specifying the matching criteria for an object\&#39;s name and/or email. Currently, match_criteria of partial searches for a username/email using \&quot;starts with\&quot; pattern.
         * @param {string} [usernames] Comma separated usernames of principals to get. If match_criteria is specified, only the first username will be picked up for search.
         * @param {ListPrincipalsSortOrderEnum} [sortOrder] The sort order of the query, either ascending or descending. Defaults to ascending.
         * @param {string} [email] E-mail address of principal to search for. Could be combined with match_criteria for searching.
         * @param {ListPrincipalsStatusEnum} [status] Set the status of users to get back.
         * @param {boolean} [adminOnly] Get only admin users within an account. Setting this would ignore the parameters: usernames, email
         * @param {ListPrincipalsOrderByEnum} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
         * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
         * @param {ListPrincipalsTypeEnum} [type] Parameter for selecting the type of principal to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPrincipals(limit?: number, offset?: number, matchCriteria?: ListPrincipalsMatchCriteriaEnum, usernames?: string, sortOrder?: ListPrincipalsSortOrderEnum, email?: string, status?: ListPrincipalsStatusEnum, adminOnly?: boolean, orderBy?: ListPrincipalsOrderByEnum, usernameOnly?: boolean, type?: ListPrincipalsTypeEnum, options?: any): AxiosPromise<ListPrincipals200Response> {
            return localVarFp.listPrincipals(limit, offset, matchCriteria, usernames, sortOrder, email, status, adminOnly, orderBy, usernameOnly, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListPrincipalsApi - object-oriented interface
 * @export
 * @class ListPrincipalsApi
 * @extends {BaseAPI}
 */
export class ListPrincipalsApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by username
     * @summary List the principals for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {ListPrincipalsMatchCriteriaEnum} [matchCriteria] Parameter for specifying the matching criteria for an object\&#39;s name and/or email. Currently, match_criteria of partial searches for a username/email using \&quot;starts with\&quot; pattern.
     * @param {string} [usernames] Comma separated usernames of principals to get. If match_criteria is specified, only the first username will be picked up for search.
     * @param {ListPrincipalsSortOrderEnum} [sortOrder] The sort order of the query, either ascending or descending. Defaults to ascending.
     * @param {string} [email] E-mail address of principal to search for. Could be combined with match_criteria for searching.
     * @param {ListPrincipalsStatusEnum} [status] Set the status of users to get back.
     * @param {boolean} [adminOnly] Get only admin users within an account. Setting this would ignore the parameters: usernames, email
     * @param {ListPrincipalsOrderByEnum} [orderBy] Parameter for ordering principals by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-username
     * @param {boolean} [usernameOnly] Parameter for optionally returning only usernames for principals, bypassing a call to IT.
     * @param {ListPrincipalsTypeEnum} [type] Parameter for selecting the type of principal to be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListPrincipalsApi
     */
    public listPrincipals(limit?: number, offset?: number, matchCriteria?: ListPrincipalsMatchCriteriaEnum, usernames?: string, sortOrder?: ListPrincipalsSortOrderEnum, email?: string, status?: ListPrincipalsStatusEnum, adminOnly?: boolean, orderBy?: ListPrincipalsOrderByEnum, usernameOnly?: boolean, type?: ListPrincipalsTypeEnum, options?: AxiosRequestConfig) {
        return ListPrincipalsApiFp(this.configuration).listPrincipals(limit, offset, matchCriteria, usernames, sortOrder, email, status, adminOnly, orderBy, usernameOnly, type, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListPrincipalsMatchCriteriaEnum = {
    Partial: 'partial',
    Exact: 'exact'
} as const;
export type ListPrincipalsMatchCriteriaEnum = typeof ListPrincipalsMatchCriteriaEnum[keyof typeof ListPrincipalsMatchCriteriaEnum];
/**
 * @export
 */
export const ListPrincipalsSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListPrincipalsSortOrderEnum = typeof ListPrincipalsSortOrderEnum[keyof typeof ListPrincipalsSortOrderEnum];
/**
 * @export
 */
export const ListPrincipalsStatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled',
    All: 'all'
} as const;
export type ListPrincipalsStatusEnum = typeof ListPrincipalsStatusEnum[keyof typeof ListPrincipalsStatusEnum];
/**
 * @export
 */
export const ListPrincipalsOrderByEnum = {
    Username: 'username'
} as const;
export type ListPrincipalsOrderByEnum = typeof ListPrincipalsOrderByEnum[keyof typeof ListPrincipalsOrderByEnum];
/**
 * @export
 */
export const ListPrincipalsTypeEnum = {
    ServiceAccount: 'service-account',
    User: 'user'
} as const;
export type ListPrincipalsTypeEnum = typeof ListPrincipalsTypeEnum[keyof typeof ListPrincipalsTypeEnum];


/**
 * ListRolesApi - axios parameter creator
 * @export
 */
export const ListRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {boolean} [system] Parameter for filtering resource by system flag.
         * @param {string} [displayName] Parameter for filtering resource by display_name using string contains search.
         * @param {ListRolesNameMatchEnum} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {ListRolesScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {ListRolesOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<ListRolesAddFieldsEnum>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {string} [application] The application name(s) to filter roles by, from permissions or external tenant name. This is an exact match. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [permission] The permission(s) to filter roles by. This is an exact match. You may also use a comma-separated list to match on multiple permissions.
         * @param {string} [externalTenant] Parameter for filtering roles by external tenant name using string search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (limit?: number, offset?: number, name?: string, system?: boolean, displayName?: string, nameMatch?: ListRolesNameMatchEnum, scope?: ListRolesScopeEnum, orderBy?: ListRolesOrderByEnum, addFields?: Array<ListRolesAddFieldsEnum>, username?: string, application?: string, permission?: string, externalTenant?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (nameMatch !== undefined) {
                localVarQueryParameter['name_match'] = nameMatch;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (addFields) {
                localVarQueryParameter['add_fields'] = addFields.join(COLLECTION_FORMATS.csv);
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (application !== undefined) {
                localVarQueryParameter['application'] = application;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }

            if (externalTenant !== undefined) {
                localVarQueryParameter['external_tenant'] = externalTenant;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListRolesApi - functional programming interface
 * @export
 */
export const ListRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {boolean} [system] Parameter for filtering resource by system flag.
         * @param {string} [displayName] Parameter for filtering resource by display_name using string contains search.
         * @param {ListRolesNameMatchEnum} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {ListRolesScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {ListRolesOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<ListRolesAddFieldsEnum>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {string} [application] The application name(s) to filter roles by, from permissions or external tenant name. This is an exact match. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [permission] The permission(s) to filter roles by. This is an exact match. You may also use a comma-separated list to match on multiple permissions.
         * @param {string} [externalTenant] Parameter for filtering roles by external tenant name using string search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(limit?: number, offset?: number, name?: string, system?: boolean, displayName?: string, nameMatch?: ListRolesNameMatchEnum, scope?: ListRolesScopeEnum, orderBy?: ListRolesOrderByEnum, addFields?: Array<ListRolesAddFieldsEnum>, username?: string, application?: string, permission?: string, externalTenant?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolePaginationDynamic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(limit, offset, name, system, displayName, nameMatch, scope, orderBy, addFields, username, application, permission, externalTenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListRolesApi - factory interface
 * @export
 */
export const ListRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListRolesApiFp(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a tenant
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {string} [name] Parameter for filtering resource by name using string contains search.
         * @param {boolean} [system] Parameter for filtering resource by system flag.
         * @param {string} [displayName] Parameter for filtering resource by display_name using string contains search.
         * @param {ListRolesNameMatchEnum} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
         * @param {ListRolesScopeEnum} [scope] Parameter for filtering resource by scope.
         * @param {ListRolesOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {Array<ListRolesAddFieldsEnum>} [addFields] Parameter for add list of fields to display for roles.
         * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
         * @param {string} [application] The application name(s) to filter roles by, from permissions or external tenant name. This is an exact match. You may also use a comma-separated list to match on multiple applications.
         * @param {string} [permission] The permission(s) to filter roles by. This is an exact match. You may also use a comma-separated list to match on multiple permissions.
         * @param {string} [externalTenant] Parameter for filtering roles by external tenant name using string search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(limit?: number, offset?: number, name?: string, system?: boolean, displayName?: string, nameMatch?: ListRolesNameMatchEnum, scope?: ListRolesScopeEnum, orderBy?: ListRolesOrderByEnum, addFields?: Array<ListRolesAddFieldsEnum>, username?: string, application?: string, permission?: string, externalTenant?: string, options?: any): AxiosPromise<RolePaginationDynamic> {
            return localVarFp.listRoles(limit, offset, name, system, displayName, nameMatch, scope, orderBy, addFields, username, application, permission, externalTenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListRolesApi - object-oriented interface
 * @export
 * @class ListRolesApi
 * @extends {BaseAPI}
 */
export class ListRolesApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by role name
     * @summary List the roles for a tenant
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {string} [name] Parameter for filtering resource by name using string contains search.
     * @param {boolean} [system] Parameter for filtering resource by system flag.
     * @param {string} [displayName] Parameter for filtering resource by display_name using string contains search.
     * @param {ListRolesNameMatchEnum} [nameMatch] Parameter for specifying the matching criteria for an object\&#39;s name or display_name.
     * @param {ListRolesScopeEnum} [scope] Parameter for filtering resource by scope.
     * @param {ListRolesOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {Array<ListRolesAddFieldsEnum>} [addFields] Parameter for add list of fields to display for roles.
     * @param {string} [username] Unique username of the principal to obtain roles for (only available for admins, and if supplied, takes precedence over the identity header).
     * @param {string} [application] The application name(s) to filter roles by, from permissions or external tenant name. This is an exact match. You may also use a comma-separated list to match on multiple applications.
     * @param {string} [permission] The permission(s) to filter roles by. This is an exact match. You may also use a comma-separated list to match on multiple permissions.
     * @param {string} [externalTenant] Parameter for filtering roles by external tenant name using string search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListRolesApi
     */
    public listRoles(limit?: number, offset?: number, name?: string, system?: boolean, displayName?: string, nameMatch?: ListRolesNameMatchEnum, scope?: ListRolesScopeEnum, orderBy?: ListRolesOrderByEnum, addFields?: Array<ListRolesAddFieldsEnum>, username?: string, application?: string, permission?: string, externalTenant?: string, options?: AxiosRequestConfig) {
        return ListRolesApiFp(this.configuration).listRoles(limit, offset, name, system, displayName, nameMatch, scope, orderBy, addFields, username, application, permission, externalTenant, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListRolesNameMatchEnum = {
    Partial: 'partial',
    Exact: 'exact'
} as const;
export type ListRolesNameMatchEnum = typeof ListRolesNameMatchEnum[keyof typeof ListRolesNameMatchEnum];
/**
 * @export
 */
export const ListRolesScopeEnum = {
    OrgId: 'org_id',
    Principal: 'principal'
} as const;
export type ListRolesScopeEnum = typeof ListRolesScopeEnum[keyof typeof ListRolesScopeEnum];
/**
 * @export
 */
export const ListRolesOrderByEnum = {
    Name: 'name',
    DisplayName: 'display_name',
    Modified: 'modified',
    PolicyCount: 'policyCount'
} as const;
export type ListRolesOrderByEnum = typeof ListRolesOrderByEnum[keyof typeof ListRolesOrderByEnum];
/**
 * @export
 */
export const ListRolesAddFieldsEnum = {
    GroupsIn: 'groups_in',
    GroupsInCount: 'groups_in_count',
    Access: 'access'
} as const;
export type ListRolesAddFieldsEnum = typeof ListRolesAddFieldsEnum[keyof typeof ListRolesAddFieldsEnum];


/**
 * ListRolesForGroupApi - axios parameter creator
 * @export
 */
export const ListRolesForGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDisplayName] Parameter for filtering group roles by role &#x60;display_name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {boolean} [roleSystem] Parameter for filtering group roles by system flag.
         * @param {string} [roleExternalTenant] Parameter for filtering group roles by role &#x60;external_tenant&#x60; using string search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListRolesForGroupOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRolesForGroup: async (uuid: string, exclude?: boolean, roleName?: string, roleDisplayName?: string, roleDescription?: string, roleSystem?: boolean, roleExternalTenant?: string, limit?: number, offset?: number, orderBy?: ListRolesForGroupOrderByEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('listRolesForGroup', 'uuid', uuid)
            const localVarPath = `/groups/{uuid}/roles/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (roleName !== undefined) {
                localVarQueryParameter['role_name'] = roleName;
            }

            if (roleDisplayName !== undefined) {
                localVarQueryParameter['role_display_name'] = roleDisplayName;
            }

            if (roleDescription !== undefined) {
                localVarQueryParameter['role_description'] = roleDescription;
            }

            if (roleSystem !== undefined) {
                localVarQueryParameter['role_system'] = roleSystem;
            }

            if (roleExternalTenant !== undefined) {
                localVarQueryParameter['role_external_tenant'] = roleExternalTenant;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListRolesForGroupApi - functional programming interface
 * @export
 */
export const ListRolesForGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListRolesForGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDisplayName] Parameter for filtering group roles by role &#x60;display_name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {boolean} [roleSystem] Parameter for filtering group roles by system flag.
         * @param {string} [roleExternalTenant] Parameter for filtering group roles by role &#x60;external_tenant&#x60; using string search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListRolesForGroupOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDisplayName?: string, roleDescription?: string, roleSystem?: boolean, roleExternalTenant?: string, limit?: number, offset?: number, orderBy?: ListRolesForGroupOrderByEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRolesPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRolesForGroup(uuid, exclude, roleName, roleDisplayName, roleDescription, roleSystem, roleExternalTenant, limit, offset, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListRolesForGroupApi - factory interface
 * @export
 */
export const ListRolesForGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListRolesForGroupApiFp(configuration)
    return {
        /**
         * By default, responses are sorted in ascending order by role name
         * @summary List the roles for a group in the tenant
         * @param {string} uuid ID of group
         * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
         * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
         * @param {string} [roleDisplayName] Parameter for filtering group roles by role &#x60;display_name&#x60; using string contains search.
         * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
         * @param {boolean} [roleSystem] Parameter for filtering group roles by system flag.
         * @param {string} [roleExternalTenant] Parameter for filtering group roles by role &#x60;external_tenant&#x60; using string search.
         * @param {number} [limit] Parameter for selecting the amount of data returned.
         * @param {number} [offset] Parameter for selecting the offset of data.
         * @param {ListRolesForGroupOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDisplayName?: string, roleDescription?: string, roleSystem?: boolean, roleExternalTenant?: string, limit?: number, offset?: number, orderBy?: ListRolesForGroupOrderByEnum, options?: any): AxiosPromise<GroupRolesPagination> {
            return localVarFp.listRolesForGroup(uuid, exclude, roleName, roleDisplayName, roleDescription, roleSystem, roleExternalTenant, limit, offset, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListRolesForGroupApi - object-oriented interface
 * @export
 * @class ListRolesForGroupApi
 * @extends {BaseAPI}
 */
export class ListRolesForGroupApi extends BaseAPI {
    /**
     * By default, responses are sorted in ascending order by role name
     * @summary List the roles for a group in the tenant
     * @param {string} uuid ID of group
     * @param {boolean} [exclude] If this is set to true, the result would be roles excluding the ones in the group
     * @param {string} [roleName] Parameter for filtering group roles by role &#x60;name&#x60; using string contains search.
     * @param {string} [roleDisplayName] Parameter for filtering group roles by role &#x60;display_name&#x60; using string contains search.
     * @param {string} [roleDescription] Parameter for filtering group roles by role &#x60;description&#x60; using string contains search.
     * @param {boolean} [roleSystem] Parameter for filtering group roles by system flag.
     * @param {string} [roleExternalTenant] Parameter for filtering group roles by role &#x60;external_tenant&#x60; using string search.
     * @param {number} [limit] Parameter for selecting the amount of data returned.
     * @param {number} [offset] Parameter for selecting the offset of data.
     * @param {ListRolesForGroupOrderByEnum} [orderBy] Parameter for ordering roles by value. For inverse ordering, supply \&#39;-\&#39; before the param value, such as: ?order_by&#x3D;-name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListRolesForGroupApi
     */
    public listRolesForGroup(uuid: string, exclude?: boolean, roleName?: string, roleDisplayName?: string, roleDescription?: string, roleSystem?: boolean, roleExternalTenant?: string, limit?: number, offset?: number, orderBy?: ListRolesForGroupOrderByEnum, options?: AxiosRequestConfig) {
        return ListRolesForGroupApiFp(this.configuration).listRolesForGroup(uuid, exclude, roleName, roleDisplayName, roleDescription, roleSystem, roleExternalTenant, limit, offset, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListRolesForGroupOrderByEnum = {
    Name: 'name',
    DisplayName: 'display_name',
    Modified: 'modified',
    PolicyCount: 'policyCount'
} as const;
export type ListRolesForGroupOrderByEnum = typeof ListRolesForGroupOrderByEnum[keyof typeof ListRolesForGroupOrderByEnum];


/**
 * PatchCrossAccountRequestApi - axios parameter creator
 * @export
 */
export const PatchCrossAccountRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Patch the start_date/end_date/roles of an existing request. Could be used by TAM requestor to cancel request or target account admin to approve/deny request.
         * @summary Patch a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestPatch} crossAccountRequestPatch Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCrossAccountRequest: async (uuid: string, crossAccountRequestPatch: CrossAccountRequestPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('patchCrossAccountRequest', 'uuid', uuid)
            // verify required parameter 'crossAccountRequestPatch' is not null or undefined
            assertParamExists('patchCrossAccountRequest', 'crossAccountRequestPatch', crossAccountRequestPatch)
            const localVarPath = `/cross-account-requests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crossAccountRequestPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatchCrossAccountRequestApi - functional programming interface
 * @export
 */
export const PatchCrossAccountRequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PatchCrossAccountRequestApiAxiosParamCreator(configuration)
    return {
        /**
         * Patch the start_date/end_date/roles of an existing request. Could be used by TAM requestor to cancel request or target account admin to approve/deny request.
         * @summary Patch a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestPatch} crossAccountRequestPatch Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCrossAccountRequest(uuid: string, crossAccountRequestPatch: CrossAccountRequestPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCrossAccountRequest(uuid, crossAccountRequestPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PatchCrossAccountRequestApi - factory interface
 * @export
 */
export const PatchCrossAccountRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PatchCrossAccountRequestApiFp(configuration)
    return {
        /**
         * Patch the start_date/end_date/roles of an existing request. Could be used by TAM requestor to cancel request or target account admin to approve/deny request.
         * @summary Patch a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestPatch} crossAccountRequestPatch Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCrossAccountRequest(uuid: string, crossAccountRequestPatch: CrossAccountRequestPatch, options?: any): AxiosPromise<CrossAccountRequestDetail> {
            return localVarFp.patchCrossAccountRequest(uuid, crossAccountRequestPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PatchCrossAccountRequestApi - object-oriented interface
 * @export
 * @class PatchCrossAccountRequestApi
 * @extends {BaseAPI}
 */
export class PatchCrossAccountRequestApi extends BaseAPI {
    /**
     * Patch the start_date/end_date/roles of an existing request. Could be used by TAM requestor to cancel request or target account admin to approve/deny request.
     * @summary Patch a cross account request
     * @param {string} uuid ID of cross account request to get
     * @param {CrossAccountRequestPatch} crossAccountRequestPatch Updates to CrossAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatchCrossAccountRequestApi
     */
    public patchCrossAccountRequest(uuid: string, crossAccountRequestPatch: CrossAccountRequestPatch, options?: AxiosRequestConfig) {
        return PatchCrossAccountRequestApiFp(this.configuration).patchCrossAccountRequest(uuid, crossAccountRequestPatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PatchRoleApi - axios parameter creator
 * @export
 */
export const PatchRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Patch a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePatch} [rolePatch] Patch to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: async (uuid: string, rolePatch?: RolePatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('patchRole', 'uuid', uuid)
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rolePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatchRoleApi - functional programming interface
 * @export
 */
export const PatchRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PatchRoleApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Patch a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePatch} [rolePatch] Patch to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRole(uuid: string, rolePatch?: RolePatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleWithAccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRole(uuid, rolePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PatchRoleApi - factory interface
 * @export
 */
export const PatchRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PatchRoleApiFp(configuration)
    return {
        /**
         *
         * @summary Patch a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePatch} [rolePatch] Patch to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRole(uuid: string, rolePatch?: RolePatch, options?: any): AxiosPromise<RoleWithAccess> {
            return localVarFp.patchRole(uuid, rolePatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PatchRoleApi - object-oriented interface
 * @export
 * @class PatchRoleApi
 * @extends {BaseAPI}
 */
export class PatchRoleApi extends BaseAPI {
    /**
     *
     * @summary Patch a role in the tenant
     * @param {string} uuid ID of role to update
     * @param {RolePatch} [rolePatch] Patch to a role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatchRoleApi
     */
    public patchRole(uuid: string, rolePatch?: RolePatch, options?: AxiosRequestConfig) {
        return PatchRoleApiFp(this.configuration).patchRole(uuid, rolePatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PutCrossAccountRequestApi - axios parameter creator
 * @export
 */
export const PutCrossAccountRequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For TAM requestor to update the start_date/end_date/roles of an existing cross account request.
         * @summary Update a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestUpdateIn} crossAccountRequestUpdateIn Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCrossAccountRequest: async (uuid: string, crossAccountRequestUpdateIn: CrossAccountRequestUpdateIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('putCrossAccountRequest', 'uuid', uuid)
            // verify required parameter 'crossAccountRequestUpdateIn' is not null or undefined
            assertParamExists('putCrossAccountRequest', 'crossAccountRequestUpdateIn', crossAccountRequestUpdateIn)
            const localVarPath = `/cross-account-requests/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crossAccountRequestUpdateIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PutCrossAccountRequestApi - functional programming interface
 * @export
 */
export const PutCrossAccountRequestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PutCrossAccountRequestApiAxiosParamCreator(configuration)
    return {
        /**
         * For TAM requestor to update the start_date/end_date/roles of an existing cross account request.
         * @summary Update a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestUpdateIn} crossAccountRequestUpdateIn Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCrossAccountRequest(uuid: string, crossAccountRequestUpdateIn: CrossAccountRequestUpdateIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrossAccountRequestDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCrossAccountRequest(uuid, crossAccountRequestUpdateIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PutCrossAccountRequestApi - factory interface
 * @export
 */
export const PutCrossAccountRequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PutCrossAccountRequestApiFp(configuration)
    return {
        /**
         * For TAM requestor to update the start_date/end_date/roles of an existing cross account request.
         * @summary Update a cross account request
         * @param {string} uuid ID of cross account request to get
         * @param {CrossAccountRequestUpdateIn} crossAccountRequestUpdateIn Updates to CrossAccountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCrossAccountRequest(uuid: string, crossAccountRequestUpdateIn: CrossAccountRequestUpdateIn, options?: any): AxiosPromise<CrossAccountRequestDetail> {
            return localVarFp.putCrossAccountRequest(uuid, crossAccountRequestUpdateIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PutCrossAccountRequestApi - object-oriented interface
 * @export
 * @class PutCrossAccountRequestApi
 * @extends {BaseAPI}
 */
export class PutCrossAccountRequestApi extends BaseAPI {
    /**
     * For TAM requestor to update the start_date/end_date/roles of an existing cross account request.
     * @summary Update a cross account request
     * @param {string} uuid ID of cross account request to get
     * @param {CrossAccountRequestUpdateIn} crossAccountRequestUpdateIn Updates to CrossAccountRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PutCrossAccountRequestApi
     */
    public putCrossAccountRequest(uuid: string, crossAccountRequestUpdateIn: CrossAccountRequestUpdateIn, options?: AxiosRequestConfig) {
        return PutCrossAccountRequestApiFp(this.configuration).putCrossAccountRequest(uuid, crossAccountRequestUpdateIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UpdateGroupApi - axios parameter creator
 * @export
 */
export const UpdateGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Update a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (uuid: string, group: Group, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateGroup', 'uuid', uuid)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('updateGroup', 'group', group)
            const localVarPath = `/groups/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateGroupApi - functional programming interface
 * @export
 */
export const UpdateGroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdateGroupApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Update a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(uuid: string, group: Group, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(uuid, group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdateGroupApi - factory interface
 * @export
 */
export const UpdateGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdateGroupApiFp(configuration)
    return {
        /**
         *
         * @summary Update a group in the tenant
         * @param {string} uuid ID of group to update
         * @param {Group} group Group to update in tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(uuid: string, group: Group, options?: any): AxiosPromise<GroupOut> {
            return localVarFp.updateGroup(uuid, group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdateGroupApi - object-oriented interface
 * @export
 * @class UpdateGroupApi
 * @extends {BaseAPI}
 */
export class UpdateGroupApi extends BaseAPI {
    /**
     *
     * @summary Update a group in the tenant
     * @param {string} uuid ID of group to update
     * @param {Group} group Group to update in tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateGroupApi
     */
    public updateGroup(uuid: string, group: Group, options?: AxiosRequestConfig) {
        return UpdateGroupApiFp(this.configuration).updateGroup(uuid, group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UpdateRoleApi - axios parameter creator
 * @export
 */
export const UpdateRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Update a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePut} rolePut Update to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (uuid: string, rolePut: RolePut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateRole', 'uuid', uuid)
            // verify required parameter 'rolePut' is not null or undefined
            assertParamExists('updateRole', 'rolePut', rolePut)
            const localVarPath = `/roles/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic_auth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rolePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateRoleApi - functional programming interface
 * @export
 */
export const UpdateRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdateRoleApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Update a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePut} rolePut Update to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(uuid: string, rolePut: RolePut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(uuid, rolePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdateRoleApi - factory interface
 * @export
 */
export const UpdateRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdateRoleApiFp(configuration)
    return {
        /**
         *
         * @summary Update a role in the tenant
         * @param {string} uuid ID of role to update
         * @param {RolePut} rolePut Update to a role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(uuid: string, rolePut: RolePut, options?: any): AxiosPromise<void> {
            return localVarFp.updateRole(uuid, rolePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdateRoleApi - object-oriented interface
 * @export
 * @class UpdateRoleApi
 * @extends {BaseAPI}
 */
export class UpdateRoleApi extends BaseAPI {
    /**
     *
     * @summary Update a role in the tenant
     * @param {string} uuid ID of role to update
     * @param {RolePut} rolePut Update to a role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateRoleApi
     */
    public updateRole(uuid: string, rolePut: RolePut, options?: AxiosRequestConfig) {
        return UpdateRoleApiFp(this.configuration).updateRole(uuid, rolePut, options).then((request) => request(this.axios, this.basePath));
    }
}



