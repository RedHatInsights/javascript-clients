// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Advisor API
 * The API of the Advisor project in Insights
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cloud.redhat.com/api/insights/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AccountSetting
 */
export interface AccountSetting {
    /**
     *
     * @type {boolean}
     * @memberof AccountSetting
     */
    showSatelliteHosts?: boolean;
}

/**
 *
 * @export
 * @interface Ack
 */
export interface Ack {
    /**
     *
     * @type {string}
     * @memberof Ack
     */
    rule?: string;
    /**
     * The reason the rule was acked
     * @type {string}
     * @memberof Ack
     */
    justification?: string;
    /**
     * The user who created the ack
     * @type {string}
     * @memberof Ack
     */
    createdBy?: string;
    /**
     *
     * @type {Date}
     * @memberof Ack
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Ack
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface AckInput
 */
export interface AckInput {
    /**
     *
     * @type {string}
     * @memberof AckInput
     */
    ruleId: string;
    /**
     *
     * @type {string}
     * @memberof AckInput
     */
    justification?: string;
}

/**
 *
 * @export
 * @interface AckJustification
 */
export interface AckJustification {
    /**
     * The reason the rule was acked
     * @type {string}
     * @memberof AckJustification
     */
    justification?: string;
}

/**
 *
 * @export
 * @interface HostAck
 */
export interface HostAck {
    /**
     *
     * @type {number}
     * @memberof HostAck
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    rule: string;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    systemUuid: string;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    justification?: string;
    /**
     * The username that created this acknowledgement
     * @type {string}
     * @memberof HostAck
     */
    createdBy?: string;
    /**
     *
     * @type {Date}
     * @memberof HostAck
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof HostAck
     */
    updatedAt?: Date;
}

/**
 *
 * @export
 * @interface HostAckJustification
 */
export interface HostAckJustification {
    /**
     *
     * @type {number}
     * @memberof HostAckJustification
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof HostAckJustification
     */
    justification?: string;
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse200
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse200
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<Ack>}
     * @memberof InlineResponse200
     */
    data: Array<Ack>;
}

/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    hostname?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    uuid?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    lastSeen?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    solutionUrl?: string;
    /**
     *
     * @type {number}
     * @memberof InlineResponse2001
     */
    totalRisk?: number;
    /**
     *
     * @type {number}
     * @memberof InlineResponse2001
     */
    likelihood?: number;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    publishDate?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    resultsUrl?: string;
}

/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse2002
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse2002
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<HostAck>}
     * @memberof InlineResponse2002
     */
    data: Array<HostAck>;
}

/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse2003
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse2003
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<RuleForAccount>}
     * @memberof InlineResponse2003
     */
    data: Array<RuleForAccount>;
}

/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse2004
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse2004
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<System>}
     * @memberof InlineResponse2004
     */
    data: Array<System>;
}

/**
 *
 * @export
 * @interface InlineResponse200Links
 */
export interface InlineResponse200Links {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Links
     */
    first?: string | null;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Links
     */
    previous?: string | null;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Links
     */
    next?: string | null;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Links
     */
    last?: string | null;
}

/**
 *
 * @export
 * @interface InlineResponse200Meta
 */
export interface InlineResponse200Meta {
    /**
     *
     * @type {number}
     * @memberof InlineResponse200Meta
     */
    count: number;
}

/**
 *
 * @export
 * @interface Resolution
 */
export interface Resolution {
    /**
     *
     * @type {number}
     * @memberof Resolution
     */
    systemType: number;
    /**
     *
     * @type {string}
     * @memberof Resolution
     */
    resolution: string;
    /**
     *
     * @type {ResolutionRisk}
     * @memberof Resolution
     */
    resolutionRisk?: ResolutionRisk;
    /**
     *
     * @type {boolean}
     * @memberof Resolution
     */
    hasPlaybook?: boolean;
}

/**
 *
 * @export
 * @interface ResolutionRisk
 */
export interface ResolutionRisk {
    /**
     *
     * @type {string}
     * @memberof ResolutionRisk
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof ResolutionRisk
     */
    risk?: number;
}

/**
 *
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * Rule ID from Insights
     * @type {string}
     * @memberof Rule
     */
    ruleId: string;
    /**
     *
     * @type {Date}
     * @memberof Rule
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Rule
     */
    updatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof Rule
     */
    deletedAt?: Date;
    /**
     *
     * @type {RuleSet}
     * @memberof Rule
     */
    ruleset: RuleSet;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    description: string;
    /**
     *
     * @type {boolean}
     * @memberof Rule
     */
    active?: boolean;
    /**
     *
     * @type {RuleCategory}
     * @memberof Rule
     */
    category: RuleCategory;
    /**
     *
     * @type {RuleImpact}
     * @memberof Rule
     */
    impact: RuleImpact;
    /**
     *
     * @type {number}
     * @memberof Rule
     */
    likelihood?: number;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    nodeId?: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    tags?: string;
    /**
     *
     * @type {boolean}
     * @memberof Rule
     */
    rebootRequired?: boolean;
    /**
     *
     * @type {Date}
     * @memberof Rule
     */
    publishDate?: Date | null;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    summary: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    generic: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    reason: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    moreInfo?: string;
    /**
     *
     * @type {Array<Resolution>}
     * @memberof Rule
     */
    resolutionSet: Array<Resolution>;
    /**
     *
     * @type {number}
     * @memberof Rule
     */
    totalRisk?: number;
}

/**
 *
 * @export
 * @interface RuleCategory
 */
export interface RuleCategory {
    /**
     *
     * @type {number}
     * @memberof RuleCategory
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof RuleCategory
     */
    name: string;
}

/**
 *
 * @export
 * @interface RuleForAccount
 */
export interface RuleForAccount {
    /**
     * Rule ID from Insights
     * @type {string}
     * @memberof RuleForAccount
     */
    ruleId: string;
    /**
     *
     * @type {Date}
     * @memberof RuleForAccount
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof RuleForAccount
     */
    updatedAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof RuleForAccount
     */
    deletedAt?: Date;
    /**
     *
     * @type {RuleSet}
     * @memberof RuleForAccount
     */
    ruleset: RuleSet;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    description: string;
    /**
     *
     * @type {boolean}
     * @memberof RuleForAccount
     */
    active?: boolean;
    /**
     *
     * @type {RuleCategory}
     * @memberof RuleForAccount
     */
    category: RuleCategory;
    /**
     *
     * @type {RuleImpact}
     * @memberof RuleForAccount
     */
    impact: RuleImpact;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    likelihood?: number;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    nodeId?: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    tags?: string;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    playbookCount?: number;
    /**
     *
     * @type {boolean}
     * @memberof RuleForAccount
     */
    rebootRequired?: boolean;
    /**
     *
     * @type {Date}
     * @memberof RuleForAccount
     */
    publishDate?: Date | null;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    summary: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    generic: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    reason: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    moreInfo?: string;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    impactedSystemsCount?: number;
    /**
     *
     * @type {boolean}
     * @memberof RuleForAccount
     */
    reportsShown?: boolean;
    /**
     *
     * @type {Array<Resolution>}
     * @memberof RuleForAccount
     */
    resolutionSet: Array<Resolution>;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    totalRisk?: number;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    hostsAckedCount?: number;
}

/**
 *
 * @export
 * @interface RuleImpact
 */
export interface RuleImpact {
    /**
     *
     * @type {string}
     * @memberof RuleImpact
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof RuleImpact
     */
    impact?: number;
}

/**
 *
 * @export
 * @interface RuleSet
 */
export interface RuleSet {
    /**
     *
     * @type {Date}
     * @memberof RuleSet
     */
    createdAt?: Date;
    /**
     *
     * @type {Date}
     * @memberof RuleSet
     */
    updatedAt?: Date;
    /**
     *
     * @type {string}
     * @memberof RuleSet
     */
    ruleSource: string;
    /**
     *
     * @type {string}
     * @memberof RuleSet
     */
    description: string;
}

/**
 *
 * @export
 * @interface StatTimeSeries
 */
export interface StatTimeSeries {
    /**
     *
     * @type {Date}
     * @memberof StatTimeSeries
     */
    checkedDay: Date;
    /**
     *
     * @type {number}
     * @memberof StatTimeSeries
     */
    count: number;
}

/**
 *
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     *
     * @type {number}
     * @memberof Stats
     */
    total: number;
    /**
     *
     * @type {{ [key: string]: number; }}
     * @memberof Stats
     */
    totalRisk: { [key: string]: number; };
    /**
     *
     * @type {{ [key: string]: number; }}
     * @memberof Stats
     */
    category: { [key: string]: number; };
}

/**
 *
 * @export
 * @interface System
 */
export interface System {
    /**
     *
     * @type {number}
     * @memberof System
     */
    hits?: number;
    /**
     *
     * @type {string}
     * @memberof System
     */
    systemUuid?: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    displayName?: string | null;
    /**
     *
     * @type {Date}
     * @memberof System
     */
    lastSeen?: Date;
}

/**
 *
 * @export
 * @interface SystemType
 */
export interface SystemType {
    /**
     *
     * @type {number}
     * @memberof SystemType
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof SystemType
     */
    role: string;
    /**
     *
     * @type {string}
     * @memberof SystemType
     */
    productCode: string;
}

/**
 *
 * @export
 * @interface SystemsForRule
 */
export interface SystemsForRule {
    /**
     *
     * @type {Array<string>}
     * @memberof SystemsForRule
     */
    hostIds: Array<string>;
}

/**
 *
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     *
     * @type {string}
     * @memberof Topic
     */
    name: string;
    /**
     * Rule topic slug
     * @type {string}
     * @memberof Topic
     */
    slug: string;
    /**
     *
     * @type {string}
     * @memberof Topic
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof Topic
     */
    tag: string;
    /**
     *
     * @type {boolean}
     * @memberof Topic
     */
    featured?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Topic
     */
    enabled?: boolean;
    /**
     *
     * @type {number}
     * @memberof Topic
     */
    impactedSystemsCount?: number;
}

/**
 *
 * @export
 * @interface WeeklyReportSubscription
 */
export interface WeeklyReportSubscription {
    /**
     *
     * @type {boolean}
     * @memberof WeeklyReportSubscription
     */
    isSubscribed: boolean;
}


/**
 * AccountSettingApi - axios parameter creator
 * @export
 */
export const AccountSettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update this account's settings, and return the updated settings.
         * @param {AccountSetting} accountSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingCreate(accountSetting: AccountSetting, options: any = {}): RequestArgs {
            // verify required parameter 'accountSetting' is not null or undefined
            if (accountSetting === null || accountSetting === undefined) {
                throw new RequiredError('accountSetting','Required parameter accountSetting was null or undefined when calling accountSettingCreate.');
            }
            const localVarPath = `/account_setting/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccountSetting" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(accountSetting || {}) : (accountSetting || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show this account's settings, or the defaults.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingList(options: any = {}): RequestArgs {
            const localVarPath = `/account_setting/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountSettingApi - functional programming interface
 * @export
 */
export const AccountSettingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Update this account's settings, and return the updated settings.
         * @param {AccountSetting} accountSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingCreate(accountSetting: AccountSetting, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSetting> {
            const localVarAxiosArgs = AccountSettingApiAxiosParamCreator(configuration).accountSettingCreate(accountSetting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show this account's settings, or the defaults.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = AccountSettingApiAxiosParamCreator(configuration).accountSettingList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountSettingApi - factory interface
 * @export
 */
export const AccountSettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Update this account's settings, and return the updated settings.
         * @param {AccountSetting} accountSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingCreate(accountSetting: AccountSetting, options?: any) {
            return AccountSettingApiFp(configuration).accountSettingCreate(accountSetting, options)(axios, basePath);
        },
        /**
         * Show this account's settings, or the defaults.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingList(options?: any) {
            return AccountSettingApiFp(configuration).accountSettingList(options)(axios, basePath);
        },
    };
};

/**
 * AccountSettingApi - object-oriented interface
 * @export
 * @class AccountSettingApi
 * @extends {BaseAPI}
 */
export class AccountSettingApi extends BaseAPI {
    /**
     * Update this account's settings, and return the updated settings.
     * @param {AccountSetting} accountSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountSettingApi
     */
    public accountSettingCreate(accountSetting: AccountSetting, options?: any) {
        return AccountSettingApiFp(this.configuration).accountSettingCreate(accountSetting, options)(this.axios, this.basePath);
    }

    /**
     * Show this account's settings, or the defaults.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountSettingApi
     */
    public accountSettingList(options?: any) {
        return AccountSettingApiFp(this.configuration).accountSettingList(options)(this.axios, this.basePath);
    }

}

/**
 * AckApi - axios parameter creator
 * @export
 */
export const AckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an acknowledgement for a rule, by rule ID, and return the new ack.  If there's already an acknowledgement of this rule by this account, then return that.
         * @param {AckInput} ackInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackCreate(ackInput: AckInput, options: any = {}): RequestArgs {
            // verify required parameter 'ackInput' is not null or undefined
            if (ackInput === null || ackInput === undefined) {
                throw new RequiredError('ackInput','Required parameter ackInput was null or undefined when calling ackCreate.');
            }
            const localVarPath = `/ack/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AckInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ackInput || {}) : (ackInput || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an acknowledgement for a rule, by its rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackDelete(ruleId: string, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ackDelete.');
            }
            const localVarPath = `/ack/{rule_id}/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List acks from this account where the rule is active
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackList(limit?: number, offset?: number, options: any = {}): RequestArgs {
            const localVarPath = `/ack/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This view handles listing, retrieving, creating and deleting acks.  Acks are created and deleted by Insights rule ID, not by their own ack ID.
         * @summary Acks acknowledge (and therefore hide) a rule from view in an account.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackRead(ruleId: string, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ackRead.');
            }
            const localVarPath = `/ack/{rule_id}/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an acknowledgement for a rule, by rule ID, and return the updated ack.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {AckJustification} ackJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackUpdate(ruleId: string, ackJustification: AckJustification, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ackUpdate.');
            }
            // verify required parameter 'ackJustification' is not null or undefined
            if (ackJustification === null || ackJustification === undefined) {
                throw new RequiredError('ackJustification','Required parameter ackJustification was null or undefined when calling ackUpdate.');
            }
            const localVarPath = `/ack/{rule_id}/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AckJustification" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ackJustification || {}) : (ackJustification || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AckApi - functional programming interface
 * @export
 */
export const AckApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add an acknowledgement for a rule, by rule ID, and return the new ack.  If there's already an acknowledgement of this rule by this account, then return that.
         * @param {AckInput} ackInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackCreate(ackInput: AckInput, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ack> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackCreate(ackInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an acknowledgement for a rule, by its rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackDelete(ruleId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackDelete(ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List acks from this account where the rule is active
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackList(limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackList(limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This view handles listing, retrieving, creating and deleting acks.  Acks are created and deleted by Insights rule ID, not by their own ack ID.
         * @summary Acks acknowledge (and therefore hide) a rule from view in an account.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackRead(ruleId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ack> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackRead(ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an acknowledgement for a rule, by rule ID, and return the updated ack.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {AckJustification} ackJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackUpdate(ruleId: string, ackJustification: AckJustification, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ack> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackUpdate(ruleId, ackJustification, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AckApi - factory interface
 * @export
 */
export const AckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add an acknowledgement for a rule, by rule ID, and return the new ack.  If there's already an acknowledgement of this rule by this account, then return that.
         * @param {AckInput} ackInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackCreate(ackInput: AckInput, options?: any) {
            return AckApiFp(configuration).ackCreate(ackInput, options)(axios, basePath);
        },
        /**
         * Delete an acknowledgement for a rule, by its rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackDelete(ruleId: string, options?: any) {
            return AckApiFp(configuration).ackDelete(ruleId, options)(axios, basePath);
        },
        /**
         * List acks from this account where the rule is active
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackList(limit?: number, offset?: number, options?: any) {
            return AckApiFp(configuration).ackList(limit, offset, options)(axios, basePath);
        },
        /**
         * This view handles listing, retrieving, creating and deleting acks.  Acks are created and deleted by Insights rule ID, not by their own ack ID.
         * @summary Acks acknowledge (and therefore hide) a rule from view in an account.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackRead(ruleId: string, options?: any) {
            return AckApiFp(configuration).ackRead(ruleId, options)(axios, basePath);
        },
        /**
         * Update an acknowledgement for a rule, by rule ID, and return the updated ack.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {AckJustification} ackJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackUpdate(ruleId: string, ackJustification: AckJustification, options?: any) {
            return AckApiFp(configuration).ackUpdate(ruleId, ackJustification, options)(axios, basePath);
        },
    };
};

/**
 * AckApi - object-oriented interface
 * @export
 * @class AckApi
 * @extends {BaseAPI}
 */
export class AckApi extends BaseAPI {
    /**
     * Add an acknowledgement for a rule, by rule ID, and return the new ack.  If there's already an acknowledgement of this rule by this account, then return that.
     * @param {AckInput} ackInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackCreate(ackInput: AckInput, options?: any) {
        return AckApiFp(this.configuration).ackCreate(ackInput, options)(this.axios, this.basePath);
    }

    /**
     * Delete an acknowledgement for a rule, by its rule ID.
     * @param {string} ruleId Rule ID defined by Insights ruleset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackDelete(ruleId: string, options?: any) {
        return AckApiFp(this.configuration).ackDelete(ruleId, options)(this.axios, this.basePath);
    }

    /**
     * List acks from this account where the rule is active
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackList(limit?: number, offset?: number, options?: any) {
        return AckApiFp(this.configuration).ackList(limit, offset, options)(this.axios, this.basePath);
    }

    /**
     * This view handles listing, retrieving, creating and deleting acks.  Acks are created and deleted by Insights rule ID, not by their own ack ID.
     * @summary Acks acknowledge (and therefore hide) a rule from view in an account.
     * @param {string} ruleId Rule ID defined by Insights ruleset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackRead(ruleId: string, options?: any) {
        return AckApiFp(this.configuration).ackRead(ruleId, options)(this.axios, this.basePath);
    }

    /**
     * Update an acknowledgement for a rule, by rule ID, and return the updated ack.
     * @param {string} ruleId Rule ID defined by Insights ruleset
     * @param {AckJustification} ackJustification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackUpdate(ruleId: string, ackJustification: AckJustification, options?: any) {
        return AckApiFp(this.configuration).ackUpdate(ruleId, ackJustification, options)(this.axios, this.basePath);
    }

}

/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get each host and all rules currently affecting it.  This will eventually require a request to the Inventory service to list the host name and Insights UUID (as opposed to the Inventory UUID which we store).  We also only present active, non-acked (on an account AND host level) rules.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportHitsList(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options: any = {}): RequestArgs {
            const localVarPath = `/export/hits/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category) {
                localVarQueryParameter['category'] = category.join(COLLECTION_FORMATS["csv"]);
            }

            if (impact) {
                localVarQueryParameter['impact'] = impact.join(COLLECTION_FORMATS["csv"]);
            }

            if (likelihood) {
                localVarQueryParameter['likelihood'] = likelihood.join(COLLECTION_FORMATS["csv"]);
            }

            if (resRisk) {
                localVarQueryParameter['res_risk'] = resRisk.join(COLLECTION_FORMATS["csv"]);
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (totalRisk) {
                localVarQueryParameter['total_risk'] = totalRisk.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export the hosts and rules listing as CSV or JSON
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options: any = {}): RequestArgs {
            const localVarPath = `/export/hits.csv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category) {
                localVarQueryParameter['category'] = category.join(COLLECTION_FORMATS["csv"]);
            }

            if (impact) {
                localVarQueryParameter['impact'] = impact.join(COLLECTION_FORMATS["csv"]);
            }

            if (likelihood) {
                localVarQueryParameter['likelihood'] = likelihood.join(COLLECTION_FORMATS["csv"]);
            }

            if (resRisk) {
                localVarQueryParameter['res_risk'] = resRisk.join(COLLECTION_FORMATS["csv"]);
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (totalRisk) {
                localVarQueryParameter['total_risk'] = totalRisk.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export the hosts and rules listing as CSV or JSON
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options: any = {}): RequestArgs {
            const localVarPath = `/export/hits.json`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category) {
                localVarQueryParameter['category'] = category.join(COLLECTION_FORMATS["csv"]);
            }

            if (impact) {
                localVarQueryParameter['impact'] = impact.join(COLLECTION_FORMATS["csv"]);
            }

            if (likelihood) {
                localVarQueryParameter['likelihood'] = likelihood.join(COLLECTION_FORMATS["csv"]);
            }

            if (resRisk) {
                localVarQueryParameter['res_risk'] = resRisk.join(COLLECTION_FORMATS["csv"]);
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (totalRisk) {
                localVarQueryParameter['total_risk'] = totalRisk.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get each host and all rules currently affecting it.  This will eventually require a request to the Inventory service to list the host name and Insights UUID (as opposed to the Inventory UUID which we store).  We also only present active, non-acked (on an account AND host level) rules.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportHitsList(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2001>> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportHitsList(category, impact, likelihood, resRisk, text, totalRisk, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Export the hosts and rules listing as CSV or JSON
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportListCsv(category, impact, likelihood, resRisk, text, totalRisk, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Export the hosts and rules listing as CSV or JSON
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2001>> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportListJson(category, impact, likelihood, resRisk, text, totalRisk, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get each host and all rules currently affecting it.  This will eventually require a request to the Inventory service to list the host name and Insights UUID (as opposed to the Inventory UUID which we store).  We also only present active, non-acked (on an account AND host level) rules.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportHitsList(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any) {
            return ExportApiFp(configuration).exportHitsList(category, impact, likelihood, resRisk, text, totalRisk, options)(axios, basePath);
        },
        /**
         * Export the hosts and rules listing as CSV or JSON
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any) {
            return ExportApiFp(configuration).exportListCsv(category, impact, likelihood, resRisk, text, totalRisk, options)(axios, basePath);
        },
        /**
         * Export the hosts and rules listing as CSV or JSON
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any) {
            return ExportApiFp(configuration).exportListJson(category, impact, likelihood, resRisk, text, totalRisk, options)(axios, basePath);
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * Get each host and all rules currently affecting it.  This will eventually require a request to the Inventory service to list the host name and Insights UUID (as opposed to the Inventory UUID which we store).  We also only present active, non-acked (on an account AND host level) rules.
     * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
     * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
     * @param {string} [text] Display rules with this text in their text fields
     * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportHitsList(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any) {
        return ExportApiFp(this.configuration).exportHitsList(category, impact, likelihood, resRisk, text, totalRisk, options)(this.axios, this.basePath);
    }

    /**
     * Export the hosts and rules listing as CSV or JSON
     * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
     * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
     * @param {string} [text] Display rules with this text in their text fields
     * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportListCsv(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any) {
        return ExportApiFp(this.configuration).exportListCsv(category, impact, likelihood, resRisk, text, totalRisk, options)(this.axios, this.basePath);
    }

    /**
     * Export the hosts and rules listing as CSV or JSON
     * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
     * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
     * @param {string} [text] Display rules with this text in their text fields
     * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportListJson(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any) {
        return ExportApiFp(this.configuration).exportListJson(category, impact, likelihood, resRisk, text, totalRisk, options)(this.axios, this.basePath);
    }

}

/**
 * HostackApi - axios parameter creator
 * @export
 */
export const HostackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the new hostack.  If there's already an acknowledgement of this rule by this account for a system, then return that.  This does not take an 'id' number.
         * @summary Add an acknowledgement for a rule, by rule ID, system, and account.
         * @param {HostAck} hostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackCreate(hostAck: HostAck, options: any = {}): RequestArgs {
            // verify required parameter 'hostAck' is not null or undefined
            if (hostAck === null || hostAck === undefined) {
                throw new RequiredError('hostAck','Required parameter hostAck was null or undefined when calling hostackCreate.');
            }
            const localVarPath = `/hostack/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HostAck" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hostAck || {}) : (hostAck || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes the hostack ID (given in the hostack list) as an identifier.
         * @summary Delete an acknowledgement for a rule, for a system, for an account, by its ID.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackDelete(id: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling hostackDelete.');
            }
            const localVarPath = `/hostack/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hostacks are retrieved, edited and deleted by the 'id' field.
         * @summary List host acks from this account for a system where the rule is active.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<string>} [ruleId] Display host acknowledgement of this/these rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackList(limit?: number, offset?: number, ruleId?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/hostack/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ruleId) {
                localVarQueryParameter['rule_id'] = ruleId.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This view handles listing, retrieving, creating and deleting hostacks.
         * @summary HostAcks acknowledge (and therefore hide) a rule from view in an account for a specific system.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackRead(id: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling hostackRead.');
            }
            const localVarPath = `/hostack/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The justification is taken from the request body.  The created_by field is taken from the username in the x-rh-identity field, and the updated_at field is set to the current time.
         * @summary Update the justification for this host acknowledgement.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {HostAckJustification} hostAckJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackUpdate(id: number, hostAckJustification: HostAckJustification, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling hostackUpdate.');
            }
            // verify required parameter 'hostAckJustification' is not null or undefined
            if (hostAckJustification === null || hostAckJustification === undefined) {
                throw new RequiredError('hostAckJustification','Required parameter hostAckJustification was null or undefined when calling hostackUpdate.');
            }
            const localVarPath = `/hostack/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HostAckJustification" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hostAckJustification || {}) : (hostAckJustification || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostackApi - functional programming interface
 * @export
 */
export const HostackApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the new hostack.  If there's already an acknowledgement of this rule by this account for a system, then return that.  This does not take an 'id' number.
         * @summary Add an acknowledgement for a rule, by rule ID, system, and account.
         * @param {HostAck} hostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackCreate(hostAck: HostAck, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostAck> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackCreate(hostAck, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Takes the hostack ID (given in the hostack list) as an identifier.
         * @summary Delete an acknowledgement for a rule, for a system, for an account, by its ID.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackDelete(id: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Hostacks are retrieved, edited and deleted by the 'id' field.
         * @summary List host acks from this account for a system where the rule is active.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<string>} [ruleId] Display host acknowledgement of this/these rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackList(limit?: number, offset?: number, ruleId?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackList(limit, offset, ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This view handles listing, retrieving, creating and deleting hostacks.
         * @summary HostAcks acknowledge (and therefore hide) a rule from view in an account for a specific system.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackRead(id: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostAck> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The justification is taken from the request body.  The created_by field is taken from the username in the x-rh-identity field, and the updated_at field is set to the current time.
         * @summary Update the justification for this host acknowledgement.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {HostAckJustification} hostAckJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackUpdate(id: number, hostAckJustification: HostAckJustification, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostAckJustification> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackUpdate(id, hostAckJustification, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HostackApi - factory interface
 * @export
 */
export const HostackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return the new hostack.  If there's already an acknowledgement of this rule by this account for a system, then return that.  This does not take an 'id' number.
         * @summary Add an acknowledgement for a rule, by rule ID, system, and account.
         * @param {HostAck} hostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackCreate(hostAck: HostAck, options?: any) {
            return HostackApiFp(configuration).hostackCreate(hostAck, options)(axios, basePath);
        },
        /**
         * Takes the hostack ID (given in the hostack list) as an identifier.
         * @summary Delete an acknowledgement for a rule, for a system, for an account, by its ID.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackDelete(id: number, options?: any) {
            return HostackApiFp(configuration).hostackDelete(id, options)(axios, basePath);
        },
        /**
         * Hostacks are retrieved, edited and deleted by the 'id' field.
         * @summary List host acks from this account for a system where the rule is active.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<string>} [ruleId] Display host acknowledgement of this/these rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackList(limit?: number, offset?: number, ruleId?: Array<string>, options?: any) {
            return HostackApiFp(configuration).hostackList(limit, offset, ruleId, options)(axios, basePath);
        },
        /**
         * This view handles listing, retrieving, creating and deleting hostacks.
         * @summary HostAcks acknowledge (and therefore hide) a rule from view in an account for a specific system.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackRead(id: number, options?: any) {
            return HostackApiFp(configuration).hostackRead(id, options)(axios, basePath);
        },
        /**
         * The justification is taken from the request body.  The created_by field is taken from the username in the x-rh-identity field, and the updated_at field is set to the current time.
         * @summary Update the justification for this host acknowledgement.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {HostAckJustification} hostAckJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackUpdate(id: number, hostAckJustification: HostAckJustification, options?: any) {
            return HostackApiFp(configuration).hostackUpdate(id, hostAckJustification, options)(axios, basePath);
        },
    };
};

/**
 * HostackApi - object-oriented interface
 * @export
 * @class HostackApi
 * @extends {BaseAPI}
 */
export class HostackApi extends BaseAPI {
    /**
     * Return the new hostack.  If there's already an acknowledgement of this rule by this account for a system, then return that.  This does not take an 'id' number.
     * @summary Add an acknowledgement for a rule, by rule ID, system, and account.
     * @param {HostAck} hostAck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackCreate(hostAck: HostAck, options?: any) {
        return HostackApiFp(this.configuration).hostackCreate(hostAck, options)(this.axios, this.basePath);
    }

    /**
     * Takes the hostack ID (given in the hostack list) as an identifier.
     * @summary Delete an acknowledgement for a rule, for a system, for an account, by its ID.
     * @param {number} id A unique integer value identifying this host ack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackDelete(id: number, options?: any) {
        return HostackApiFp(this.configuration).hostackDelete(id, options)(this.axios, this.basePath);
    }

    /**
     * Hostacks are retrieved, edited and deleted by the 'id' field.
     * @summary List host acks from this account for a system where the rule is active.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<string>} [ruleId] Display host acknowledgement of this/these rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackList(limit?: number, offset?: number, ruleId?: Array<string>, options?: any) {
        return HostackApiFp(this.configuration).hostackList(limit, offset, ruleId, options)(this.axios, this.basePath);
    }

    /**
     * This view handles listing, retrieving, creating and deleting hostacks.
     * @summary HostAcks acknowledge (and therefore hide) a rule from view in an account for a specific system.
     * @param {number} id A unique integer value identifying this host ack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackRead(id: number, options?: any) {
        return HostackApiFp(this.configuration).hostackRead(id, options)(this.axios, this.basePath);
    }

    /**
     * The justification is taken from the request body.  The created_by field is taken from the username in the x-rh-identity field, and the updated_at field is set to the current time.
     * @summary Update the justification for this host acknowledgement.
     * @param {number} id A unique integer value identifying this host ack.
     * @param {HostAckJustification} hostAckJustification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackUpdate(id: number, hostAckJustification: HostAckJustification, options?: any) {
        return HostackApiFp(this.configuration).hostackUpdate(id, hostAckJustification, options)(this.axios, this.basePath);
    }

}

/**
 * ResolutionRiskApi - axios parameter creator
 * @export
 */
export const ResolutionRiskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolutionRiskList(options: any = {}): RequestArgs {
            const localVarPath = `/resolution_risk/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResolutionRiskApi - functional programming interface
 * @export
 */
export const ResolutionRiskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolutionRiskList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ResolutionRiskApiAxiosParamCreator(configuration).resolutionRiskList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResolutionRiskApi - factory interface
 * @export
 */
export const ResolutionRiskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolutionRiskList(options?: any) {
            return ResolutionRiskApiFp(configuration).resolutionRiskList(options)(axios, basePath);
        },
    };
};

/**
 * ResolutionRiskApi - object-oriented interface
 * @export
 * @class ResolutionRiskApi
 * @extends {BaseAPI}
 */
export class ResolutionRiskApi extends BaseAPI {
    /**
     * List all total risk values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionRiskApi
     */
    public resolutionRiskList(options?: any) {
        return ResolutionRiskApiFp(this.configuration).resolutionRiskList(options)(this.axios, this.basePath);
    }

}

/**
 * RuleApi - axios parameter creator
 * @export
 */
export const RuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all active rules for this account.  If 'acked' is False or not given, then only rules that are not acked will be shown.  If acked is set and 'true' as a string or evaluates to a true value, then all rules including those that are acked will be shown.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<string>} [hasTag] Display rules that have (one or more) tags
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {boolean} [impacting] Display only rules that are impacting systems currently
         * @param {boolean} [incident] Display only rules that cause an incident
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {boolean} [reportsShown] Display rules where reports are shown or not
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'} [sort] Order by this field
         * @param {string} [text] Display rules with this text in their text fields
         * @param {string} [topic] Display rules in this topic (slug)
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleList(limit?: number, offset?: number, category?: Array<1 | 2 | 3 | 4>, hasTag?: Array<string>, impact?: Array<1 | 2 | 3 | 4>, impacting?: boolean, incident?: boolean, likelihood?: Array<1 | 2 | 3 | 4>, reportsShown?: boolean, resRisk?: Array<1 | 2 | 3 | 4>, sort?: 'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk', text?: string, topic?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options: any = {}): RequestArgs {
            const localVarPath = `/rule/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (category) {
                localVarQueryParameter['category'] = category.join(COLLECTION_FORMATS["csv"]);
            }

            if (hasTag) {
                localVarQueryParameter['has_tag'] = hasTag.join(COLLECTION_FORMATS["csv"]);
            }

            if (impact) {
                localVarQueryParameter['impact'] = impact.join(COLLECTION_FORMATS["csv"]);
            }

            if (impacting !== undefined) {
                localVarQueryParameter['impacting'] = impacting;
            }

            if (incident !== undefined) {
                localVarQueryParameter['incident'] = incident;
            }

            if (likelihood) {
                localVarQueryParameter['likelihood'] = likelihood.join(COLLECTION_FORMATS["csv"]);
            }

            if (reportsShown !== undefined) {
                localVarQueryParameter['reports_shown'] = reportsShown;
            }

            if (resRisk) {
                localVarQueryParameter['res_risk'] = resRisk.join(COLLECTION_FORMATS["csv"]);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (totalRisk) {
                localVarQueryParameter['total_risk'] = totalRisk.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single rule and its associated details.
         * @param {string} ruleId Rule ID from Insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleRead(ruleId: string, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ruleRead.');
            }
            const localVarPath = `/rule/{rule_id}/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all systems affected by this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleSystems(ruleId: string, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ruleSystems.');
            }
            const localVarPath = `/rule/{rule_id}/systems/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleApi - functional programming interface
 * @export
 */
export const RuleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all active rules for this account.  If 'acked' is False or not given, then only rules that are not acked will be shown.  If acked is set and 'true' as a string or evaluates to a true value, then all rules including those that are acked will be shown.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<string>} [hasTag] Display rules that have (one or more) tags
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {boolean} [impacting] Display only rules that are impacting systems currently
         * @param {boolean} [incident] Display only rules that cause an incident
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {boolean} [reportsShown] Display rules where reports are shown or not
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'} [sort] Order by this field
         * @param {string} [text] Display rules with this text in their text fields
         * @param {string} [topic] Display rules in this topic (slug)
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleList(limit?: number, offset?: number, category?: Array<1 | 2 | 3 | 4>, hasTag?: Array<string>, impact?: Array<1 | 2 | 3 | 4>, impacting?: boolean, incident?: boolean, likelihood?: Array<1 | 2 | 3 | 4>, reportsShown?: boolean, resRisk?: Array<1 | 2 | 3 | 4>, sort?: 'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk', text?: string, topic?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003> {
            const localVarAxiosArgs = RuleApiAxiosParamCreator(configuration).ruleList(limit, offset, category, hasTag, impact, impacting, incident, likelihood, reportsShown, resRisk, sort, text, topic, totalRisk, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a single rule and its associated details.
         * @param {string} ruleId Rule ID from Insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleRead(ruleId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleForAccount> {
            const localVarAxiosArgs = RuleApiAxiosParamCreator(configuration).ruleRead(ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all systems affected by this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleSystems(ruleId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemsForRule> {
            const localVarAxiosArgs = RuleApiAxiosParamCreator(configuration).ruleSystems(ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RuleApi - factory interface
 * @export
 */
export const RuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List all active rules for this account.  If 'acked' is False or not given, then only rules that are not acked will be shown.  If acked is set and 'true' as a string or evaluates to a true value, then all rules including those that are acked will be shown.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<string>} [hasTag] Display rules that have (one or more) tags
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {boolean} [impacting] Display only rules that are impacting systems currently
         * @param {boolean} [incident] Display only rules that cause an incident
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {boolean} [reportsShown] Display rules where reports are shown or not
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'} [sort] Order by this field
         * @param {string} [text] Display rules with this text in their text fields
         * @param {string} [topic] Display rules in this topic (slug)
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleList(limit?: number, offset?: number, category?: Array<1 | 2 | 3 | 4>, hasTag?: Array<string>, impact?: Array<1 | 2 | 3 | 4>, impacting?: boolean, incident?: boolean, likelihood?: Array<1 | 2 | 3 | 4>, reportsShown?: boolean, resRisk?: Array<1 | 2 | 3 | 4>, sort?: 'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk', text?: string, topic?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any) {
            return RuleApiFp(configuration).ruleList(limit, offset, category, hasTag, impact, impacting, incident, likelihood, reportsShown, resRisk, sort, text, topic, totalRisk, options)(axios, basePath);
        },
        /**
         * Retrieve a single rule and its associated details.
         * @param {string} ruleId Rule ID from Insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleRead(ruleId: string, options?: any) {
            return RuleApiFp(configuration).ruleRead(ruleId, options)(axios, basePath);
        },
        /**
         * List all systems affected by this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleSystems(ruleId: string, options?: any) {
            return RuleApiFp(configuration).ruleSystems(ruleId, options)(axios, basePath);
        },
    };
};

/**
 * RuleApi - object-oriented interface
 * @export
 * @class RuleApi
 * @extends {BaseAPI}
 */
export class RuleApi extends BaseAPI {
    /**
     * List all active rules for this account.  If 'acked' is False or not given, then only rules that are not acked will be shown.  If acked is set and 'true' as a string or evaluates to a true value, then all rules including those that are acked will be shown.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
     * @param {Array<string>} [hasTag] Display rules that have (one or more) tags
     * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
     * @param {boolean} [impacting] Display only rules that are impacting systems currently
     * @param {boolean} [incident] Display only rules that cause an incident
     * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
     * @param {boolean} [reportsShown] Display rules where reports are shown or not
     * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
     * @param {'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'} [sort] Order by this field
     * @param {string} [text] Display rules with this text in their text fields
     * @param {string} [topic] Display rules in this topic (slug)
     * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public ruleList(limit?: number, offset?: number, category?: Array<1 | 2 | 3 | 4>, hasTag?: Array<string>, impact?: Array<1 | 2 | 3 | 4>, impacting?: boolean, incident?: boolean, likelihood?: Array<1 | 2 | 3 | 4>, reportsShown?: boolean, resRisk?: Array<1 | 2 | 3 | 4>, sort?: 'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk', text?: string, topic?: string, totalRisk?: Array<1 | 2 | 3 | 4>, options?: any) {
        return RuleApiFp(this.configuration).ruleList(limit, offset, category, hasTag, impact, impacting, incident, likelihood, reportsShown, resRisk, sort, text, topic, totalRisk, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve a single rule and its associated details.
     * @param {string} ruleId Rule ID from Insights
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public ruleRead(ruleId: string, options?: any) {
        return RuleApiFp(this.configuration).ruleRead(ruleId, options)(this.axios, this.basePath);
    }

    /**
     * List all systems affected by this rule.
     * @param {string} ruleId Rule ID from Insights
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public ruleSystems(ruleId: string, options?: any) {
        return RuleApiFp(this.configuration).ruleSystems(ruleId, options)(this.axios, this.basePath);
    }

}

/**
 * RulecategoryApi - axios parameter creator
 * @export
 */
export const RulecategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Rules are divided into categories, the usual being Availability, Stability, Security and Performance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryList(options: any = {}): RequestArgs {
            const localVarPath = `/rulecategory/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rules are divided into categories, the usual being Availability, Stability, Security and Performance
         * @param {number} id A unique integer value identifying this rule category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryRead(id: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rulecategoryRead.');
            }
            const localVarPath = `/rulecategory/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulecategoryApi - functional programming interface
 * @export
 */
export const RulecategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Rules are divided into categories, the usual being Availability, Stability, Security and Performance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleCategory>> {
            const localVarAxiosArgs = RulecategoryApiAxiosParamCreator(configuration).rulecategoryList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Rules are divided into categories, the usual being Availability, Stability, Security and Performance
         * @param {number} id A unique integer value identifying this rule category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryRead(id: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleCategory> {
            const localVarAxiosArgs = RulecategoryApiAxiosParamCreator(configuration).rulecategoryRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RulecategoryApi - factory interface
 * @export
 */
export const RulecategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Rules are divided into categories, the usual being Availability, Stability, Security and Performance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryList(options?: any) {
            return RulecategoryApiFp(configuration).rulecategoryList(options)(axios, basePath);
        },
        /**
         * Rules are divided into categories, the usual being Availability, Stability, Security and Performance
         * @param {number} id A unique integer value identifying this rule category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryRead(id: number, options?: any) {
            return RulecategoryApiFp(configuration).rulecategoryRead(id, options)(axios, basePath);
        },
    };
};

/**
 * RulecategoryApi - object-oriented interface
 * @export
 * @class RulecategoryApi
 * @extends {BaseAPI}
 */
export class RulecategoryApi extends BaseAPI {
    /**
     * Rules are divided into categories, the usual being Availability, Stability, Security and Performance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulecategoryApi
     */
    public rulecategoryList(options?: any) {
        return RulecategoryApiFp(this.configuration).rulecategoryList(options)(this.axios, this.basePath);
    }

    /**
     * Rules are divided into categories, the usual being Availability, Stability, Security and Performance
     * @param {number} id A unique integer value identifying this rule category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulecategoryApi
     */
    public rulecategoryRead(id: number, options?: any) {
        return RulecategoryApiFp(this.configuration).rulecategoryRead(id, options)(this.axios, this.basePath);
    }

}

/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Simple time series of day and number of hits (per system-rule tuple) per day.
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsHitsSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options: any = {}): RequestArgs {
            const localVarPath = `/stats/hits_series/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any).toISOString();
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any).toISOString();
            }

            if (grain !== undefined) {
                localVarQueryParameter['grain'] = grain;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a simple list of URLs contained here.  Copied sort-of from the APIRootView's `get` method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsList(options: any = {}): RequestArgs {
            const localVarPath = `/stats/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsReports(options: any = {}): RequestArgs {
            const localVarPath = `/stats/reports/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRules(options: any = {}): RequestArgs {
            const localVarPath = `/stats/rules/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple time series of day and number of systems impacted by any rule
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRulesHitSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options: any = {}): RequestArgs {
            const localVarPath = `/stats/rules_hit_series/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any).toISOString();
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any).toISOString();
            }

            if (grain !== undefined) {
                localVarQueryParameter['grain'] = grain;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystems(options: any = {}): RequestArgs {
            const localVarPath = `/stats/systems/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple time series of day and number of systems impacted by any rule
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystemsImpactedSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options: any = {}): RequestArgs {
            const localVarPath = `/stats/systems_impacted_series/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any).toISOString();
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any).toISOString();
            }

            if (grain !== undefined) {
                localVarQueryParameter['grain'] = grain;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simple time series of day and number of systems having uploaded that day.
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystemsReportingSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options: any = {}): RequestArgs {
            const localVarPath = `/stats/systems_reporting_series/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any).toISOString();
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any).toISOString();
            }

            if (grain !== undefined) {
                localVarQueryParameter['grain'] = grain;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Simple time series of day and number of hits (per system-rule tuple) per day.
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsHitsSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatTimeSeries>> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsHitsSeries(start, end, grain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provide a simple list of URLs contained here.  Copied sort-of from the APIRootView's `get` method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsReports(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsReports(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRules(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsRules(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Simple time series of day and number of systems impacted by any rule
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRulesHitSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatTimeSeries>> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsRulesHitSeries(start, end, grain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystems(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsSystems(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Simple time series of day and number of systems impacted by any rule
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystemsImpactedSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatTimeSeries>> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsSystemsImpactedSeries(start, end, grain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Simple time series of day and number of systems having uploaded that day.
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystemsReportingSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatTimeSeries>> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsSystemsReportingSeries(start, end, grain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Simple time series of day and number of hits (per system-rule tuple) per day.
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsHitsSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any) {
            return StatsApiFp(configuration).statsHitsSeries(start, end, grain, options)(axios, basePath);
        },
        /**
         * Provide a simple list of URLs contained here.  Copied sort-of from the APIRootView's `get` method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsList(options?: any) {
            return StatsApiFp(configuration).statsList(options)(axios, basePath);
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsReports(options?: any) {
            return StatsApiFp(configuration).statsReports(options)(axios, basePath);
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRules(options?: any) {
            return StatsApiFp(configuration).statsRules(options)(axios, basePath);
        },
        /**
         * Simple time series of day and number of systems impacted by any rule
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRulesHitSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any) {
            return StatsApiFp(configuration).statsRulesHitSeries(start, end, grain, options)(axios, basePath);
        },
        /**
         * View the statistics for this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystems(options?: any) {
            return StatsApiFp(configuration).statsSystems(options)(axios, basePath);
        },
        /**
         * Simple time series of day and number of systems impacted by any rule
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystemsImpactedSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any) {
            return StatsApiFp(configuration).statsSystemsImpactedSeries(start, end, grain, options)(axios, basePath);
        },
        /**
         * Simple time series of day and number of systems having uploaded that day.
         * @param {string} [start] Start date for statistics range
         * @param {string} [end] End date for statistics range
         * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystemsReportingSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any) {
            return StatsApiFp(configuration).statsSystemsReportingSeries(start, end, grain, options)(axios, basePath);
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Simple time series of day and number of hits (per system-rule tuple) per day.
     * @param {string} [start] Start date for statistics range
     * @param {string} [end] End date for statistics range
     * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsHitsSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any) {
        return StatsApiFp(this.configuration).statsHitsSeries(start, end, grain, options)(this.axios, this.basePath);
    }

    /**
     * Provide a simple list of URLs contained here.  Copied sort-of from the APIRootView's `get` method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsList(options?: any) {
        return StatsApiFp(this.configuration).statsList(options)(this.axios, this.basePath);
    }

    /**
     * View the statistics for this account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsReports(options?: any) {
        return StatsApiFp(this.configuration).statsReports(options)(this.axios, this.basePath);
    }

    /**
     * View the statistics for this account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsRules(options?: any) {
        return StatsApiFp(this.configuration).statsRules(options)(this.axios, this.basePath);
    }

    /**
     * Simple time series of day and number of systems impacted by any rule
     * @param {string} [start] Start date for statistics range
     * @param {string} [end] End date for statistics range
     * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsRulesHitSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any) {
        return StatsApiFp(this.configuration).statsRulesHitSeries(start, end, grain, options)(this.axios, this.basePath);
    }

    /**
     * View the statistics for this account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsSystems(options?: any) {
        return StatsApiFp(this.configuration).statsSystems(options)(this.axios, this.basePath);
    }

    /**
     * Simple time series of day and number of systems impacted by any rule
     * @param {string} [start] Start date for statistics range
     * @param {string} [end] End date for statistics range
     * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsSystemsImpactedSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any) {
        return StatsApiFp(this.configuration).statsSystemsImpactedSeries(start, end, grain, options)(this.axios, this.basePath);
    }

    /**
     * Simple time series of day and number of systems having uploaded that day.
     * @param {string} [start] Start date for statistics range
     * @param {string} [end] End date for statistics range
     * @param {'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day'} [grain] Granularity for date queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsSystemsReportingSeries(start?: string, end?: string, grain?: 'ever' | 'year' | 'quarter' | 'month' | 'week' | 'day', options?: any) {
        return StatsApiFp(this.configuration).statsSystemsReportingSeries(start, end, grain, options)(this.axios, this.basePath);
    }

}

/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns systems with their hit count and last upload time.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemList(limit?: number, offset?: number, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', displayName?: string, options: any = {}): RequestArgs {
            const localVarPath = `/system/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List systems, or retrieve a system by UUID.
         * @param {string} uuid The system&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRead(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling systemRead.');
            }
            const localVarPath = `/system/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of latest reports for an Inventory Host ID that:  * are in the user's account  * have an active, not-deleted rule  * where the rule has not been acked by this account  If the host ID is not found, return an empty list.
         * @param {string} uuid The system&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemReports(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling systemReports.');
            }
            const localVarPath = `/system/{uuid}/reports/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns systems with their hit count and last upload time.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemList(limit?: number, offset?: number, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', displayName?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).systemList(limit, offset, sort, displayName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List systems, or retrieve a system by UUID.
         * @param {string} uuid The system&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRead(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<System> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).systemRead(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the list of latest reports for an Inventory Host ID that:  * are in the user's account  * have an active, not-deleted rule  * where the rule has not been acked by this account  If the host ID is not found, return an empty list.
         * @param {string} uuid The system&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemReports(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).systemReports(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns systems with their hit count and last upload time.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemList(limit?: number, offset?: number, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', displayName?: string, options?: any) {
            return SystemApiFp(configuration).systemList(limit, offset, sort, displayName, options)(axios, basePath);
        },
        /**
         * List systems, or retrieve a system by UUID.
         * @param {string} uuid The system&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRead(uuid: string, options?: any) {
            return SystemApiFp(configuration).systemRead(uuid, options)(axios, basePath);
        },
        /**
         * Returns the list of latest reports for an Inventory Host ID that:  * are in the user's account  * have an active, not-deleted rule  * where the rule has not been acked by this account  If the host ID is not found, return an empty list.
         * @param {string} uuid The system&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemReports(uuid: string, options?: any) {
            return SystemApiFp(configuration).systemReports(uuid, options)(axios, basePath);
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Returns systems with their hit count and last upload time.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
     * @param {string} [displayName] Display systems with this text in their display_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemList(limit?: number, offset?: number, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', displayName?: string, options?: any) {
        return SystemApiFp(this.configuration).systemList(limit, offset, sort, displayName, options)(this.axios, this.basePath);
    }

    /**
     * List systems, or retrieve a system by UUID.
     * @param {string} uuid The system&#39;s Host ID in the Inventory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemRead(uuid: string, options?: any) {
        return SystemApiFp(this.configuration).systemRead(uuid, options)(this.axios, this.basePath);
    }

    /**
     * Returns the list of latest reports for an Inventory Host ID that:  * are in the user's account  * have an active, not-deleted rule  * where the rule has not been acked by this account  If the host ID is not found, return an empty list.
     * @param {string} uuid The system&#39;s Host ID in the Inventory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemReports(uuid: string, options?: any) {
        return SystemApiFp(this.configuration).systemReports(uuid, options)(this.axios, this.basePath);
    }

}

/**
 * SystemtypeApi - axios parameter creator
 * @export
 */
export const SystemtypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all system types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeList(options: any = {}): RequestArgs {
            const localVarPath = `/systemtype/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Display a single system type
         * @param {number} id A unique integer value identifying this system type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeRead(id: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling systemtypeRead.');
            }
            const localVarPath = `/systemtype/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemtypeApi - functional programming interface
 * @export
 */
export const SystemtypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all system types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SystemType>> {
            const localVarAxiosArgs = SystemtypeApiAxiosParamCreator(configuration).systemtypeList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Display a single system type
         * @param {number} id A unique integer value identifying this system type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeRead(id: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemType> {
            const localVarAxiosArgs = SystemtypeApiAxiosParamCreator(configuration).systemtypeRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemtypeApi - factory interface
 * @export
 */
export const SystemtypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List all system types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeList(options?: any) {
            return SystemtypeApiFp(configuration).systemtypeList(options)(axios, basePath);
        },
        /**
         * Display a single system type
         * @param {number} id A unique integer value identifying this system type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeRead(id: number, options?: any) {
            return SystemtypeApiFp(configuration).systemtypeRead(id, options)(axios, basePath);
        },
    };
};

/**
 * SystemtypeApi - object-oriented interface
 * @export
 * @class SystemtypeApi
 * @extends {BaseAPI}
 */
export class SystemtypeApi extends BaseAPI {
    /**
     * List all system types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemtypeApi
     */
    public systemtypeList(options?: any) {
        return SystemtypeApiFp(this.configuration).systemtypeList(options)(this.axios, this.basePath);
    }

    /**
     * Display a single system type
     * @param {number} id A unique integer value identifying this system type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemtypeApi
     */
    public systemtypeRead(id: number, options?: any) {
        return SystemtypeApiFp(this.configuration).systemtypeRead(id, options)(this.axios, this.basePath);
    }

}

/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Normally this only shows enabled topics, but if the 'show_disabled' parameter is set to True then this will show disabled topics as well.
         * @summary List the rule topics and their impacted systems counts.
         * @param {boolean} [showDisabled] Display topics that are disabled as well as enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicList(showDisabled?: boolean, options: any = {}): RequestArgs {
            const localVarPath = `/topic/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (showDisabled !== undefined) {
                localVarQueryParameter['show_disabled'] = showDisabled;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This also lists the topic's impacted systems count.
         * @summary Retrieve a single topic by slug.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRead(slug: string, options: any = {}): RequestArgs {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling topicRead.');
            }
            const localVarPath = `/topic/{slug}/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the available rules that have this tag.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRulesWithTag(slug: string, options: any = {}): RequestArgs {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling topicRulesWithTag.');
            }
            const localVarPath = `/topic/{slug}/rules_with_tag/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Systems are just listed by their UUID.
         * @summary List all systems affected by this rule topic.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSystems(slug: string, options: any = {}): RequestArgs {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling topicSystems.');
            }
            const localVarPath = `/topic/{slug}/systems/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Normally this only shows enabled topics, but if the 'show_disabled' parameter is set to True then this will show disabled topics as well.
         * @summary List the rule topics and their impacted systems counts.
         * @param {boolean} [showDisabled] Display topics that are disabled as well as enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicList(showDisabled?: boolean, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Topic>> {
            const localVarAxiosArgs = TopicApiAxiosParamCreator(configuration).topicList(showDisabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This also lists the topic's impacted systems count.
         * @summary Retrieve a single topic by slug.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRead(slug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic> {
            const localVarAxiosArgs = TopicApiAxiosParamCreator(configuration).topicRead(slug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists the available rules that have this tag.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRulesWithTag(slug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rule>> {
            const localVarAxiosArgs = TopicApiAxiosParamCreator(configuration).topicRulesWithTag(slug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Systems are just listed by their UUID.
         * @summary List all systems affected by this rule topic.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSystems(slug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemsForRule> {
            const localVarAxiosArgs = TopicApiAxiosParamCreator(configuration).topicSystems(slug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Normally this only shows enabled topics, but if the 'show_disabled' parameter is set to True then this will show disabled topics as well.
         * @summary List the rule topics and their impacted systems counts.
         * @param {boolean} [showDisabled] Display topics that are disabled as well as enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicList(showDisabled?: boolean, options?: any) {
            return TopicApiFp(configuration).topicList(showDisabled, options)(axios, basePath);
        },
        /**
         * This also lists the topic's impacted systems count.
         * @summary Retrieve a single topic by slug.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRead(slug: string, options?: any) {
            return TopicApiFp(configuration).topicRead(slug, options)(axios, basePath);
        },
        /**
         * Lists the available rules that have this tag.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRulesWithTag(slug: string, options?: any) {
            return TopicApiFp(configuration).topicRulesWithTag(slug, options)(axios, basePath);
        },
        /**
         * Systems are just listed by their UUID.
         * @summary List all systems affected by this rule topic.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSystems(slug: string, options?: any) {
            return TopicApiFp(configuration).topicSystems(slug, options)(axios, basePath);
        },
    };
};

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI {
    /**
     * Normally this only shows enabled topics, but if the 'show_disabled' parameter is set to True then this will show disabled topics as well.
     * @summary List the rule topics and their impacted systems counts.
     * @param {boolean} [showDisabled] Display topics that are disabled as well as enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicList(showDisabled?: boolean, options?: any) {
        return TopicApiFp(this.configuration).topicList(showDisabled, options)(this.axios, this.basePath);
    }

    /**
     * This also lists the topic's impacted systems count.
     * @summary Retrieve a single topic by slug.
     * @param {string} slug Rule topic slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicRead(slug: string, options?: any) {
        return TopicApiFp(this.configuration).topicRead(slug, options)(this.axios, this.basePath);
    }

    /**
     * Lists the available rules that have this tag.
     * @param {string} slug Rule topic slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicRulesWithTag(slug: string, options?: any) {
        return TopicApiFp(this.configuration).topicRulesWithTag(slug, options)(this.axios, this.basePath);
    }

    /**
     * Systems are just listed by their UUID.
     * @summary List all systems affected by this rule topic.
     * @param {string} slug Rule topic slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicSystems(slug: string, options?: any) {
        return TopicApiFp(this.configuration).topicSystems(slug, options)(this.axios, this.basePath);
    }

}

/**
 * TotalRiskApi - axios parameter creator
 * @export
 */
export const TotalRiskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalRiskList(options: any = {}): RequestArgs {
            const localVarPath = `/total_risk/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TotalRiskApi - functional programming interface
 * @export
 */
export const TotalRiskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalRiskList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TotalRiskApiAxiosParamCreator(configuration).totalRiskList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TotalRiskApi - factory interface
 * @export
 */
export const TotalRiskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalRiskList(options?: any) {
            return TotalRiskApiFp(configuration).totalRiskList(options)(axios, basePath);
        },
    };
};

/**
 * TotalRiskApi - object-oriented interface
 * @export
 * @class TotalRiskApi
 * @extends {BaseAPI}
 */
export class TotalRiskApi extends BaseAPI {
    /**
     * List all total risk values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TotalRiskApi
     */
    public totalRiskList(options?: any) {
        return TotalRiskApiFp(this.configuration).totalRiskList(options)(this.axios, this.basePath);
    }

}

/**
 * WeeklyreportsubscriptionApi - axios parameter creator
 * @export
 */
export const WeeklyreportsubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set the subscription status of the current user to the supplied `is_subscribed` value.
         * @param {WeeklyReportSubscription} weeklyReportSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionCreate(weeklyReportSubscription: WeeklyReportSubscription, options: any = {}): RequestArgs {
            // verify required parameter 'weeklyReportSubscription' is not null or undefined
            if (weeklyReportSubscription === null || weeklyReportSubscription === undefined) {
                throw new RequiredError('weeklyReportSubscription','Required parameter weeklyReportSubscription was null or undefined when calling weeklyreportsubscriptionCreate.');
            }
            const localVarPath = `/weeklyreportsubscription/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WeeklyReportSubscription" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(weeklyReportSubscription || {}) : (weeklyReportSubscription || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the user's current subscription status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionList(options: any = {}): RequestArgs {
            const localVarPath = `/weeklyreportsubscription/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WeeklyreportsubscriptionApi - functional programming interface
 * @export
 */
export const WeeklyreportsubscriptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Set the subscription status of the current user to the supplied `is_subscribed` value.
         * @param {WeeklyReportSubscription} weeklyReportSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionCreate(weeklyReportSubscription: WeeklyReportSubscription, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeeklyReportSubscription> {
            const localVarAxiosArgs = WeeklyreportsubscriptionApiAxiosParamCreator(configuration).weeklyreportsubscriptionCreate(weeklyReportSubscription, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show the user's current subscription status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeeklyReportSubscription> {
            const localVarAxiosArgs = WeeklyreportsubscriptionApiAxiosParamCreator(configuration).weeklyreportsubscriptionList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WeeklyreportsubscriptionApi - factory interface
 * @export
 */
export const WeeklyreportsubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Set the subscription status of the current user to the supplied `is_subscribed` value.
         * @param {WeeklyReportSubscription} weeklyReportSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionCreate(weeklyReportSubscription: WeeklyReportSubscription, options?: any) {
            return WeeklyreportsubscriptionApiFp(configuration).weeklyreportsubscriptionCreate(weeklyReportSubscription, options)(axios, basePath);
        },
        /**
         * Show the user's current subscription status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionList(options?: any) {
            return WeeklyreportsubscriptionApiFp(configuration).weeklyreportsubscriptionList(options)(axios, basePath);
        },
    };
};

/**
 * WeeklyreportsubscriptionApi - object-oriented interface
 * @export
 * @class WeeklyreportsubscriptionApi
 * @extends {BaseAPI}
 */
export class WeeklyreportsubscriptionApi extends BaseAPI {
    /**
     * Set the subscription status of the current user to the supplied `is_subscribed` value.
     * @param {WeeklyReportSubscription} weeklyReportSubscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WeeklyreportsubscriptionApi
     */
    public weeklyreportsubscriptionCreate(weeklyReportSubscription: WeeklyReportSubscription, options?: any) {
        return WeeklyreportsubscriptionApiFp(this.configuration).weeklyreportsubscriptionCreate(weeklyReportSubscription, options)(this.axios, this.basePath);
    }

    /**
     * Show the user's current subscription status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WeeklyreportsubscriptionApi
     */
    public weeklyreportsubscriptionList(options?: any) {
        return WeeklyreportsubscriptionApiFp(this.configuration).weeklyreportsubscriptionList(options)(this.axios, this.basePath);
    }

}

