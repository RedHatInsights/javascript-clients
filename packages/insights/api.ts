// tslint:disable
/**
 * Advisor API
 * The API of the Advisor project in Insights
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AccountSetting
 */
export interface AccountSetting {
    /**
     *
     * @type {boolean}
     * @memberof AccountSetting
     */
    show_satellite_hosts?: boolean;
}
/**
 *
 * @export
 * @interface Ack
 */
export interface Ack {
    /**
     *
     * @type {string}
     * @memberof Ack
     */
    rule?: string;
    /**
     * The reason the rule was acked
     * @type {string}
     * @memberof Ack
     */
    justification?: string;
    /**
     * The user who created the ack
     * @type {string}
     * @memberof Ack
     */
    created_by?: string;
    /**
     *
     * @type {string}
     * @memberof Ack
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof Ack
     */
    updated_at?: string;
}
/**
 *
 * @export
 * @interface AckInput
 */
export interface AckInput {
    /**
     *
     * @type {string}
     * @memberof AckInput
     */
    rule_id: string;
    /**
     *
     * @type {string}
     * @memberof AckInput
     */
    justification?: string;
}
/**
 *
 * @export
 * @interface AckJustification
 */
export interface AckJustification {
    /**
     * The reason the rule was acked
     * @type {string}
     * @memberof AckJustification
     */
    justification?: string;
}
/**
 *
 * @export
 * @interface HostAck
 */
export interface HostAck {
    /**
     *
     * @type {number}
     * @memberof HostAck
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    rule: string;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    system_uuid: string;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    justification?: string;
    /**
     * The username that created this acknowledgement
     * @type {string}
     * @memberof HostAck
     */
    created_by?: string;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof HostAck
     */
    display_name?: string;
}
/**
 *
 * @export
 * @interface HostAckJustification
 */
export interface HostAckJustification {
    /**
     *
     * @type {number}
     * @memberof HostAckJustification
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof HostAckJustification
     */
    justification?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse200
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse200
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<Ack>}
     * @memberof InlineResponse200
     */
    data: Array<Ack>;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    hostname?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    uuid?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    last_seen?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    solution_url?: string;
    /**
     *
     * @type {number}
     * @memberof InlineResponse2001
     */
    total_risk?: number;
    /**
     *
     * @type {number}
     * @memberof InlineResponse2001
     */
    likelihood?: number;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    publish_date?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2001
     */
    results_url?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse2002
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse2002
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<HostAck>}
     * @memberof InlineResponse2002
     */
    data: Array<HostAck>;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse2003
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse2003
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<RuleRating>}
     * @memberof InlineResponse2003
     */
    data: Array<RuleRating>;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse2004
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse2004
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<RuleForAccount>}
     * @memberof InlineResponse2004
     */
    data: Array<RuleForAccount>;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     *
     * @type {InlineResponse200Meta}
     * @memberof InlineResponse2005
     */
    meta?: InlineResponse200Meta;
    /**
     *
     * @type {InlineResponse200Links}
     * @memberof InlineResponse2005
     */
    links?: InlineResponse200Links;
    /**
     *
     * @type {Array<System>}
     * @memberof InlineResponse2005
     */
    data: Array<System>;
}
/**
 *
 * @export
 * @interface InlineResponse200Links
 */
export interface InlineResponse200Links {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Links
     */
    first?: string | null;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Links
     */
    previous?: string | null;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Links
     */
    next?: string | null;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200Links
     */
    last?: string | null;
}
/**
 *
 * @export
 * @interface InlineResponse200Meta
 */
export interface InlineResponse200Meta {
    /**
     *
     * @type {number}
     * @memberof InlineResponse200Meta
     */
    count: number;
}
/**
 *
 * @export
 * @interface Kcs
 */
export interface Kcs {
    /**
     * Rule URL on C.R.C.
     * @type {string}
     * @memberof Kcs
     */
    rule_url: string;
    /**
     * KCS solution number
     * @type {string}
     * @memberof Kcs
     */
    node_id: string;
}
/**
 *
 * @export
 * @interface MultiAckResponse
 */
export interface MultiAckResponse {
    /**
     *
     * @type {number}
     * @memberof MultiAckResponse
     */
    count: number;
    /**
     *
     * @type {Array<string>}
     * @memberof MultiAckResponse
     */
    host_ids: Array<string>;
}
/**
 *
 * @export
 * @interface MultiHostAck
 */
export interface MultiHostAck {
    /**
     *
     * @type {Array<string>}
     * @memberof MultiHostAck
     */
    systems: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MultiHostAck
     */
    justification: string;
}
/**
 *
 * @export
 * @interface MultiHostUnAck
 */
export interface MultiHostUnAck {
    /**
     *
     * @type {Array<string>}
     * @memberof MultiHostUnAck
     */
    systems: Array<string>;
}
/**
 *
 * @export
 * @interface PreferencesInput
 */
export interface PreferencesInput {
    /**
     *
     * @type {boolean}
     * @memberof PreferencesInput
     */
    is_subscribed: boolean;
}
/**
 *
 * @export
 * @interface Report
 */
export interface Report {
    /**
     *
     * @type {Rule}
     * @memberof Report
     */
    rule?: Rule;
    /**
     *
     * @type {object}
     * @memberof Report
     */
    details: object;
    /**
     *
     * @type {Resolution}
     * @memberof Report
     */
    resolution?: Resolution;
}
/**
 *
 * @export
 * @interface Resolution
 */
export interface Resolution {
    /**
     *
     * @type {number}
     * @memberof Resolution
     */
    system_type: number;
    /**
     *
     * @type {string}
     * @memberof Resolution
     */
    resolution: string;
    /**
     *
     * @type {ResolutionRisk}
     * @memberof Resolution
     */
    resolution_risk?: ResolutionRisk;
    /**
     *
     * @type {boolean}
     * @memberof Resolution
     */
    has_playbook?: boolean;
}
/**
 *
 * @export
 * @interface ResolutionRisk
 */
export interface ResolutionRisk {
    /**
     *
     * @type {string}
     * @memberof ResolutionRisk
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof ResolutionRisk
     */
    risk?: number;
}
/**
 *
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * Rule ID from Insights
     * @type {string}
     * @memberof Rule
     */
    rule_id: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    deleted_at?: string;
    /**
     *
     * @type {RuleSet}
     * @memberof Rule
     */
    ruleset: RuleSet;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    description: string;
    /**
     *
     * @type {boolean}
     * @memberof Rule
     */
    active?: boolean;
    /**
     *
     * @type {RuleCategory}
     * @memberof Rule
     */
    category: RuleCategory;
    /**
     *
     * @type {RuleImpact}
     * @memberof Rule
     */
    impact: RuleImpact;
    /**
     *
     * @type {number}
     * @memberof Rule
     */
    likelihood?: number;
    /**
     * KCS solution number
     * @type {string}
     * @memberof Rule
     */
    node_id?: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    tags?: string;
    /**
     *
     * @type {boolean}
     * @memberof Rule
     */
    reboot_required?: boolean;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    publish_date?: string | null;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    summary: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    generic: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    reason: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    more_info?: string;
    /**
     *
     * @type {Array<Resolution>}
     * @memberof Rule
     */
    resolution_set: Array<Resolution>;
    /**
     *
     * @type {number}
     * @memberof Rule
     */
    total_risk?: number;
}
/**
 *
 * @export
 * @interface RuleCategory
 */
export interface RuleCategory {
    /**
     *
     * @type {number}
     * @memberof RuleCategory
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof RuleCategory
     */
    name: string;
}
/**
 *
 * @export
 * @interface RuleForAccount
 */
export interface RuleForAccount {
    /**
     * Rule ID from Insights
     * @type {string}
     * @memberof RuleForAccount
     */
    rule_id: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    deleted_at?: string;
    /**
     *
     * @type {RuleSet}
     * @memberof RuleForAccount
     */
    ruleset: RuleSet;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    description: string;
    /**
     *
     * @type {boolean}
     * @memberof RuleForAccount
     */
    active?: boolean;
    /**
     *
     * @type {RuleCategory}
     * @memberof RuleForAccount
     */
    category: RuleCategory;
    /**
     *
     * @type {RuleImpact}
     * @memberof RuleForAccount
     */
    impact: RuleImpact;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    likelihood?: number;
    /**
     * KCS solution number
     * @type {string}
     * @memberof RuleForAccount
     */
    node_id?: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    tags?: string;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    playbook_count?: number;
    /**
     *
     * @type {boolean}
     * @memberof RuleForAccount
     */
    reboot_required?: boolean;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    publish_date?: string | null;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    summary: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    generic: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    reason: string;
    /**
     *
     * @type {string}
     * @memberof RuleForAccount
     */
    more_info?: string;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    impacted_systems_count?: number;
    /**
     *
     * @type {boolean}
     * @memberof RuleForAccount
     */
    reports_shown?: boolean;
    /**
     *
     * @type {Array<Resolution>}
     * @memberof RuleForAccount
     */
    resolution_set: Array<Resolution>;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    total_risk?: number;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    hosts_acked_count?: number;
    /**
     *
     * @type {number}
     * @memberof RuleForAccount
     */
    rating?: number;
}
/**
 *
 * @export
 * @interface RuleImpact
 */
export interface RuleImpact {
    /**
     *
     * @type {string}
     * @memberof RuleImpact
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof RuleImpact
     */
    impact?: number;
}
/**
 *
 * @export
 * @interface RuleRating
 */
export interface RuleRating {
    /**
     *
     * @type {string}
     * @memberof RuleRating
     */
    rule: string;
    /**
     *
     * @type {number}
     * @memberof RuleRating
     */
    rating: RuleRatingRatingEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RuleRatingRatingEnum {
    NUMBER_MINUS_1 = -1,
    NUMBER_0 = 0,
    NUMBER_1 = 1
}

/**
 *
 * @export
 * @interface RuleSet
 */
export interface RuleSet {
    /**
     *
     * @type {string}
     * @memberof RuleSet
     */
    created_at?: string;
    /**
     *
     * @type {string}
     * @memberof RuleSet
     */
    updated_at?: string;
    /**
     *
     * @type {string}
     * @memberof RuleSet
     */
    rule_source: string;
    /**
     *
     * @type {string}
     * @memberof RuleSet
     */
    description: string;
}
/**
 *
 * @export
 * @interface SettingDDF
 */
export interface SettingDDF {
    /**
     *
     * @type {string}
     * @memberof SettingDDF
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof SettingDDF
     */
    label?: string;
    /**
     *
     * @type {string}
     * @memberof SettingDDF
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof SettingDDF
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof SettingDDF
     */
    helpText?: string;
    /**
     *
     * @type {string}
     * @memberof SettingDDF
     */
    component: string;
    /**
     *
     * @type {boolean}
     * @memberof SettingDDF
     */
    isRequired: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SettingDDF
     */
    initialValue: boolean;
}
/**
 *
 * @export
 * @interface SettingsDDF
 */
export interface SettingsDDF {
    /**
     *
     * @type {Array<SettingDDF>}
     * @memberof SettingsDDF
     */
    fields: Array<SettingDDF>;
}
/**
 *
 * @export
 * @interface SettingsInput
 */
export interface SettingsInput {
    /**
     *
     * @type {boolean}
     * @memberof SettingsInput
     */
    show_satellite_hosts: boolean;
}
/**
 *
 * @export
 * @interface StaleSystemStats
 */
export interface StaleSystemStats {
    /**
     *
     * @type {number}
     * @memberof StaleSystemStats
     */
    stale_count: number;
    /**
     *
     * @type {number}
     * @memberof StaleSystemStats
     */
    warn_count: number;
}
/**
 *
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     *
     * @type {number}
     * @memberof Stats
     */
    total: number;
    /**
     *
     * @type {{ [key: string]: number; }}
     * @memberof Stats
     */
    total_risk: { [key: string]: number; };
    /**
     *
     * @type {{ [key: string]: number; }}
     * @memberof Stats
     */
    category: { [key: string]: number; };
}
/**
 *
 * @export
 * @interface System
 */
export interface System {
    /**
     *
     * @type {string}
     * @memberof System
     */
    system_uuid: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    display_name: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    last_seen?: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    stale_at: string;
    /**
     *
     * @type {number}
     * @memberof System
     */
    hits?: number;
    /**
     *
     * @type {number}
     * @memberof System
     */
    critical_hits?: number;
    /**
     *
     * @type {number}
     * @memberof System
     */
    important_hits?: number;
    /**
     *
     * @type {number}
     * @memberof System
     */
    moderate_hits?: number;
    /**
     *
     * @type {number}
     * @memberof System
     */
    low_hits?: number;
}
/**
 *
 * @export
 * @interface SystemType
 */
export interface SystemType {
    /**
     *
     * @type {number}
     * @memberof SystemType
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof SystemType
     */
    role: string;
    /**
     *
     * @type {string}
     * @memberof SystemType
     */
    product_code: string;
}
/**
 *
 * @export
 * @interface SystemsForRule
 */
export interface SystemsForRule {
    /**
     *
     * @type {Array<string>}
     * @memberof SystemsForRule
     */
    host_ids: Array<string>;
}
/**
 *
 * @export
 * @interface TagList
 */
export interface TagList {
    /**
     *
     * @type {Array<string>}
     * @memberof TagList
     */
    tags: Array<string>;
}
/**
 *
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     *
     * @type {string}
     * @memberof Topic
     */
    name: string;
    /**
     * Rule topic slug
     * @type {string}
     * @memberof Topic
     */
    slug: string;
    /**
     *
     * @type {string}
     * @memberof Topic
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof Topic
     */
    tag: string;
    /**
     *
     * @type {boolean}
     * @memberof Topic
     */
    featured?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Topic
     */
    enabled?: boolean;
    /**
     *
     * @type {number}
     * @memberof Topic
     */
    impacted_systems_count?: number;
}
/**
 *
 * @export
 * @interface WeeklyReportSubscription
 */
export interface WeeklyReportSubscription {
    /**
     *
     * @type {boolean}
     * @memberof WeeklyReportSubscription
     */
    is_subscribed: boolean;
}

/**
 * AccountSettingApi - axios parameter creator
 * @export
 */
export const AccountSettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A new object will be created, even if the default settings are supplied.
         * @summary Update this account\'s settings, and return the updated settings.
         * @param {AccountSetting} accountSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingCreate(accountSetting: AccountSetting, options: any = {}): RequestArgs {
            // verify required parameter 'accountSetting' is not null or undefined
            if (accountSetting === null || accountSetting === undefined) {
                throw new RequiredError('accountSetting','Required parameter accountSetting was null or undefined when calling accountSettingCreate.');
            }
            const localVarPath = `/account_setting/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof accountSetting !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(accountSetting !== undefined ? accountSetting : {}) : (accountSetting || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will not create a new account settings object if none exists.
         * @summary Show this account\'s settings, or the defaults.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingList(options: any = {}): RequestArgs {
            const localVarPath = `/account_setting/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountSettingApi - functional programming interface
 * @export
 */
export const AccountSettingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A new object will be created, even if the default settings are supplied.
         * @summary Update this account\'s settings, and return the updated settings.
         * @param {AccountSetting} accountSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingCreate(accountSetting: AccountSetting, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSetting> {
            const localVarAxiosArgs = AccountSettingApiAxiosParamCreator(configuration).accountSettingCreate(accountSetting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This will not create a new account settings object if none exists.
         * @summary Show this account\'s settings, or the defaults.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = AccountSettingApiAxiosParamCreator(configuration).accountSettingList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountSettingApi - factory interface
 * @export
 */
export const AccountSettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * A new object will be created, even if the default settings are supplied.
         * @summary Update this account\'s settings, and return the updated settings.
         * @param {AccountSetting} accountSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingCreate(accountSetting: AccountSetting, options?: any): AxiosPromise<AccountSetting> {
            return AccountSettingApiFp(configuration).accountSettingCreate(accountSetting, options)(axios, basePath);
        },
        /**
         * This will not create a new account settings object if none exists.
         * @summary Show this account\'s settings, or the defaults.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountSettingList(options?: any): AxiosPromise<void> {
            return AccountSettingApiFp(configuration).accountSettingList(options)(axios, basePath);
        },
    };
};

/**
 * AccountSettingApi - object-oriented interface
 * @export
 * @class AccountSettingApi
 * @extends {BaseAPI}
 */
export class AccountSettingApi extends BaseAPI {
    /**
     * A new object will be created, even if the default settings are supplied.
     * @summary Update this account\'s settings, and return the updated settings.
     * @param {AccountSetting} accountSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountSettingApi
     */
    public accountSettingCreate(accountSetting: AccountSetting, options?: any) {
        return AccountSettingApiFp(this.configuration).accountSettingCreate(accountSetting, options)(this.axios, this.basePath);
    }

    /**
     * This will not create a new account settings object if none exists.
     * @summary Show this account\'s settings, or the defaults.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountSettingApi
     */
    public accountSettingList(options?: any) {
        return AccountSettingApiFp(this.configuration).accountSettingList(options)(this.axios, this.basePath);
    }

}


/**
 * AckApi - axios parameter creator
 * @export
 */
export const AckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there\'s already an acknowledgement of this rule by this account, then return that.  Otherwise, a new ack is created.
         * @summary Add an acknowledgement for a rule, by rule ID.
         * @param {AckInput} ackInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackCreate(ackInput: AckInput, options: any = {}): RequestArgs {
            // verify required parameter 'ackInput' is not null or undefined
            if (ackInput === null || ackInput === undefined) {
                throw new RequiredError('ackInput','Required parameter ackInput was null or undefined when calling ackCreate.');
            }
            const localVarPath = `/ack/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof ackInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ackInput !== undefined ? ackInput : {}) : (ackInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the ack existed, it is deleted and a 204 is returned.  Otherwise, a 404 is returned.
         * @summary Delete an acknowledgement for a rule, by its rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackDelete(ruleId: string, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ackDelete.');
            }
            const localVarPath = `/ack/{rule_id}/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return an empty list if this account has no acks.
         * @summary List acks from this account where the rule is active
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackList(limit?: number, offset?: number, options: any = {}): RequestArgs {
            const localVarPath = `/ack/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This view handles listing, retrieving, creating and deleting acks.  Acks are created and deleted by Insights rule ID, not by their own ack ID.
         * @summary Acks acknowledge (and therefore hide) a rule from view in an account.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackRead(ruleId: string, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ackRead.');
            }
            const localVarPath = `/ack/{rule_id}/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new justification can be supplied.  The username is taken from the authenticated request.  The updated ack is returned.
         * @summary Update an acknowledgement for a rule, by rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {AckJustification} ackJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackUpdate(ruleId: string, ackJustification: AckJustification, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ackUpdate.');
            }
            // verify required parameter 'ackJustification' is not null or undefined
            if (ackJustification === null || ackJustification === undefined) {
                throw new RequiredError('ackJustification','Required parameter ackJustification was null or undefined when calling ackUpdate.');
            }
            const localVarPath = `/ack/{rule_id}/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof ackJustification !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ackJustification !== undefined ? ackJustification : {}) : (ackJustification || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AckApi - functional programming interface
 * @export
 */
export const AckApiFp = function(configuration?: Configuration) {
    return {
        /**
         * If there\'s already an acknowledgement of this rule by this account, then return that.  Otherwise, a new ack is created.
         * @summary Add an acknowledgement for a rule, by rule ID.
         * @param {AckInput} ackInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackCreate(ackInput: AckInput, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ack> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackCreate(ackInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If the ack existed, it is deleted and a 204 is returned.  Otherwise, a 404 is returned.
         * @summary Delete an acknowledgement for a rule, by its rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackDelete(ruleId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackDelete(ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Will return an empty list if this account has no acks.
         * @summary List acks from this account where the rule is active
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackList(limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackList(limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This view handles listing, retrieving, creating and deleting acks.  Acks are created and deleted by Insights rule ID, not by their own ack ID.
         * @summary Acks acknowledge (and therefore hide) a rule from view in an account.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackRead(ruleId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ack> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackRead(ruleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A new justification can be supplied.  The username is taken from the authenticated request.  The updated ack is returned.
         * @summary Update an acknowledgement for a rule, by rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {AckJustification} ackJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackUpdate(ruleId: string, ackJustification: AckJustification, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ack> {
            const localVarAxiosArgs = AckApiAxiosParamCreator(configuration).ackUpdate(ruleId, ackJustification, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AckApi - factory interface
 * @export
 */
export const AckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * If there\'s already an acknowledgement of this rule by this account, then return that.  Otherwise, a new ack is created.
         * @summary Add an acknowledgement for a rule, by rule ID.
         * @param {AckInput} ackInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackCreate(ackInput: AckInput, options?: any): AxiosPromise<Ack> {
            return AckApiFp(configuration).ackCreate(ackInput, options)(axios, basePath);
        },
        /**
         * If the ack existed, it is deleted and a 204 is returned.  Otherwise, a 404 is returned.
         * @summary Delete an acknowledgement for a rule, by its rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackDelete(ruleId: string, options?: any): AxiosPromise<void> {
            return AckApiFp(configuration).ackDelete(ruleId, options)(axios, basePath);
        },
        /**
         * Will return an empty list if this account has no acks.
         * @summary List acks from this account where the rule is active
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackList(limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse200> {
            return AckApiFp(configuration).ackList(limit, offset, options)(axios, basePath);
        },
        /**
         * This view handles listing, retrieving, creating and deleting acks.  Acks are created and deleted by Insights rule ID, not by their own ack ID.
         * @summary Acks acknowledge (and therefore hide) a rule from view in an account.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackRead(ruleId: string, options?: any): AxiosPromise<Ack> {
            return AckApiFp(configuration).ackRead(ruleId, options)(axios, basePath);
        },
        /**
         * A new justification can be supplied.  The username is taken from the authenticated request.  The updated ack is returned.
         * @summary Update an acknowledgement for a rule, by rule ID.
         * @param {string} ruleId Rule ID defined by Insights ruleset
         * @param {AckJustification} ackJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ackUpdate(ruleId: string, ackJustification: AckJustification, options?: any): AxiosPromise<Ack> {
            return AckApiFp(configuration).ackUpdate(ruleId, ackJustification, options)(axios, basePath);
        },
    };
};

/**
 * AckApi - object-oriented interface
 * @export
 * @class AckApi
 * @extends {BaseAPI}
 */
export class AckApi extends BaseAPI {
    /**
     * If there\'s already an acknowledgement of this rule by this account, then return that.  Otherwise, a new ack is created.
     * @summary Add an acknowledgement for a rule, by rule ID.
     * @param {AckInput} ackInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackCreate(ackInput: AckInput, options?: any) {
        return AckApiFp(this.configuration).ackCreate(ackInput, options)(this.axios, this.basePath);
    }

    /**
     * If the ack existed, it is deleted and a 204 is returned.  Otherwise, a 404 is returned.
     * @summary Delete an acknowledgement for a rule, by its rule ID.
     * @param {string} ruleId Rule ID defined by Insights ruleset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackDelete(ruleId: string, options?: any) {
        return AckApiFp(this.configuration).ackDelete(ruleId, options)(this.axios, this.basePath);
    }

    /**
     * Will return an empty list if this account has no acks.
     * @summary List acks from this account where the rule is active
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackList(limit?: number, offset?: number, options?: any) {
        return AckApiFp(this.configuration).ackList(limit, offset, options)(this.axios, this.basePath);
    }

    /**
     * This view handles listing, retrieving, creating and deleting acks.  Acks are created and deleted by Insights rule ID, not by their own ack ID.
     * @summary Acks acknowledge (and therefore hide) a rule from view in an account.
     * @param {string} ruleId Rule ID defined by Insights ruleset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackRead(ruleId: string, options?: any) {
        return AckApiFp(this.configuration).ackRead(ruleId, options)(this.axios, this.basePath);
    }

    /**
     * A new justification can be supplied.  The username is taken from the authenticated request.  The updated ack is returned.
     * @summary Update an acknowledgement for a rule, by rule ID.
     * @param {string} ruleId Rule ID defined by Insights ruleset
     * @param {AckJustification} ackJustification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AckApi
     */
    public ackUpdate(ruleId: string, ackJustification: AckJustification, options?: any) {
        return AckApiFp(this.configuration).ackUpdate(ruleId, ackJustification, options)(this.axios, this.basePath);
    }

}


/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * We also only present active, non-acked (on an account AND host level) rules.  Inventory data may be requested if Advisor has not seen all the hosts. The accepted content type supplied in the request headers is used to determine the supplied content type.
         * @summary Get each host and all rules currently affecting it.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportHitsList(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/export/hits/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category) {
                localVarQueryParameter['category'] = category.join(COLLECTION_FORMATS.csv);
            }

            if (impact) {
                localVarQueryParameter['impact'] = impact.join(COLLECTION_FORMATS.csv);
            }

            if (likelihood) {
                localVarQueryParameter['likelihood'] = likelihood.join(COLLECTION_FORMATS.csv);
            }

            if (resRisk) {
                localVarQueryParameter['res_risk'] = resRisk.join(COLLECTION_FORMATS.csv);
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (totalRisk) {
                localVarQueryParameter['total_risk'] = totalRisk.join(COLLECTION_FORMATS.csv);
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in CSV format.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/export/hits.csv`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category) {
                localVarQueryParameter['category'] = category.join(COLLECTION_FORMATS.csv);
            }

            if (impact) {
                localVarQueryParameter['impact'] = impact.join(COLLECTION_FORMATS.csv);
            }

            if (likelihood) {
                localVarQueryParameter['likelihood'] = likelihood.join(COLLECTION_FORMATS.csv);
            }

            if (resRisk) {
                localVarQueryParameter['res_risk'] = resRisk.join(COLLECTION_FORMATS.csv);
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (totalRisk) {
                localVarQueryParameter['total_risk'] = totalRisk.join(COLLECTION_FORMATS.csv);
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in CSV format.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv_1(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options: any = {}): RequestArgs {
            const localVarPath = `/export/systems.csv`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in JSON format.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/export/hits.json`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category) {
                localVarQueryParameter['category'] = category.join(COLLECTION_FORMATS.csv);
            }

            if (impact) {
                localVarQueryParameter['impact'] = impact.join(COLLECTION_FORMATS.csv);
            }

            if (likelihood) {
                localVarQueryParameter['likelihood'] = likelihood.join(COLLECTION_FORMATS.csv);
            }

            if (resRisk) {
                localVarQueryParameter['res_risk'] = resRisk.join(COLLECTION_FORMATS.csv);
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (totalRisk) {
                localVarQueryParameter['total_risk'] = totalRisk.join(COLLECTION_FORMATS.csv);
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in JSON format.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson_2(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options: any = {}): RequestArgs {
            const localVarPath = `/export/systems.json`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Systems can be sorted and filtered by display name.
         * @summary List of systems with details and hit counts.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSystemsList(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options: any = {}): RequestArgs {
            const localVarPath = `/export/systems/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * We also only present active, non-acked (on an account AND host level) rules.  Inventory data may be requested if Advisor has not seen all the hosts. The accepted content type supplied in the request headers is used to determine the supplied content type.
         * @summary Get each host and all rules currently affecting it.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportHitsList(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2001>> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportHitsList(category, impact, likelihood, resRisk, text, totalRisk, tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in CSV format.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportListCsv(category, impact, likelihood, resRisk, text, totalRisk, tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in CSV format.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv_1(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportListCsv_1(displayName, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in JSON format.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2001>> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportListJson(category, impact, likelihood, resRisk, text, totalRisk, tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in JSON format.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson_2(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<System>> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportListJson_2(displayName, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Systems can be sorted and filtered by display name.
         * @summary List of systems with details and hit counts.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSystemsList(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<System>> {
            const localVarAxiosArgs = ExportApiAxiosParamCreator(configuration).exportSystemsList(displayName, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * We also only present active, non-acked (on an account AND host level) rules.  Inventory data may be requested if Advisor has not seen all the hosts. The accepted content type supplied in the request headers is used to determine the supplied content type.
         * @summary Get each host and all rules currently affecting it.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportHitsList(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any): AxiosPromise<Array<InlineResponse2001>> {
            return ExportApiFp(configuration).exportHitsList(category, impact, likelihood, resRisk, text, totalRisk, tags, options)(axios, basePath);
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in CSV format.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any): AxiosPromise<void> {
            return ExportApiFp(configuration).exportListCsv(category, impact, likelihood, resRisk, text, totalRisk, tags, options)(axios, basePath);
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in CSV format.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListCsv_1(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any): AxiosPromise<void> {
            return ExportApiFp(configuration).exportListCsv_1(displayName, sort, options)(axios, basePath);
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in JSON format.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {string} [text] Display rules with this text in their text fields
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any): AxiosPromise<Array<InlineResponse2001>> {
            return ExportApiFp(configuration).exportListJson(category, impact, likelihood, resRisk, text, totalRisk, tags, options)(axios, basePath);
        },
        /**
         * The accepted content type is not required.
         * @summary Supply the list output in JSON format.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportListJson_2(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any): AxiosPromise<Array<System>> {
            return ExportApiFp(configuration).exportListJson_2(displayName, sort, options)(axios, basePath);
        },
        /**
         * Systems can be sorted and filtered by display name.
         * @summary List of systems with details and hit counts.
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportSystemsList(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any): AxiosPromise<Array<System>> {
            return ExportApiFp(configuration).exportSystemsList(displayName, sort, options)(axios, basePath);
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * We also only present active, non-acked (on an account AND host level) rules.  Inventory data may be requested if Advisor has not seen all the hosts. The accepted content type supplied in the request headers is used to determine the supplied content type.
     * @summary Get each host and all rules currently affecting it.
     * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
     * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
     * @param {string} [text] Display rules with this text in their text fields
     * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportHitsList(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any) {
        return ExportApiFp(this.configuration).exportHitsList(category, impact, likelihood, resRisk, text, totalRisk, tags, options)(this.axios, this.basePath);
    }

    /**
     * The accepted content type is not required.
     * @summary Supply the list output in CSV format.
     * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
     * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
     * @param {string} [text] Display rules with this text in their text fields
     * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportListCsv(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any) {
        return ExportApiFp(this.configuration).exportListCsv(category, impact, likelihood, resRisk, text, totalRisk, tags, options)(this.axios, this.basePath);
    }

    /**
     * The accepted content type is not required.
     * @summary Supply the list output in CSV format.
     * @param {string} [displayName] Display systems with this text in their display_name
     * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportListCsv_1(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any) {
        return ExportApiFp(this.configuration).exportListCsv_1(displayName, sort, options)(this.axios, this.basePath);
    }

    /**
     * The accepted content type is not required.
     * @summary Supply the list output in JSON format.
     * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
     * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
     * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
     * @param {string} [text] Display rules with this text in their text fields
     * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportListJson(category?: Array<1 | 2 | 3 | 4>, impact?: Array<1 | 2 | 3 | 4>, likelihood?: Array<1 | 2 | 3 | 4>, resRisk?: Array<1 | 2 | 3 | 4>, text?: string, totalRisk?: Array<1 | 2 | 3 | 4>, tags?: Array<string>, options?: any) {
        return ExportApiFp(this.configuration).exportListJson(category, impact, likelihood, resRisk, text, totalRisk, tags, options)(this.axios, this.basePath);
    }

    /**
     * The accepted content type is not required.
     * @summary Supply the list output in JSON format.
     * @param {string} [displayName] Display systems with this text in their display_name
     * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportListJson_2(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any) {
        return ExportApiFp(this.configuration).exportListJson_2(displayName, sort, options)(this.axios, this.basePath);
    }

    /**
     * Systems can be sorted and filtered by display name.
     * @summary List of systems with details and hit counts.
     * @param {string} [displayName] Display systems with this text in their display_name
     * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportSystemsList(displayName?: string, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', options?: any) {
        return ExportApiFp(this.configuration).exportSystemsList(displayName, sort, options)(this.axios, this.basePath);
    }

}


/**
 * HostackApi - axios parameter creator
 * @export
 */
export const HostackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the new hostack.  If there\'s already an acknowledgement of this rule by this account for a system, then return that.  This does not take an \'id\' number.
         * @summary Add an acknowledgement for a rule, by rule ID, system, and account.
         * @param {HostAck} hostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackCreate(hostAck: HostAck, options: any = {}): RequestArgs {
            // verify required parameter 'hostAck' is not null or undefined
            if (hostAck === null || hostAck === undefined) {
                throw new RequiredError('hostAck','Required parameter hostAck was null or undefined when calling hostackCreate.');
            }
            const localVarPath = `/hostack/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hostAck !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hostAck !== undefined ? hostAck : {}) : (hostAck || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes the hostack ID (given in the hostack list) as an identifier.
         * @summary Delete an acknowledgement for a rule, for a system, for an account, by its ID.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackDelete(id: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling hostackDelete.');
            }
            const localVarPath = `/hostack/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hostacks are retrieved, edited and deleted by the \'id\' field.
         * @summary List host acks from this account for a system where the rule is active.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<string>} [ruleId] Display host acknowledgement of this/these rules
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackList(limit?: number, offset?: number, ruleId?: Array<string>, tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/hostack/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ruleId) {
                localVarQueryParameter['rule_id'] = ruleId.join(COLLECTION_FORMATS.csv);
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This view handles listing, retrieving, creating and deleting hostacks.
         * @summary HostAcks acknowledge (and therefore hide) a rule from view in an account for a specific system.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackRead(id: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling hostackRead.');
            }
            const localVarPath = `/hostack/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The justification is taken from the request body.  The created_by field is taken from the username in the x-rh-identity field, and the updated_at field is set to the current time.
         * @summary Update the justification for this host acknowledgement.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {HostAckJustification} hostAckJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackUpdate(id: number, hostAckJustification: HostAckJustification, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling hostackUpdate.');
            }
            // verify required parameter 'hostAckJustification' is not null or undefined
            if (hostAckJustification === null || hostAckJustification === undefined) {
                throw new RequiredError('hostAckJustification','Required parameter hostAckJustification was null or undefined when calling hostackUpdate.');
            }
            const localVarPath = `/hostack/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hostAckJustification !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hostAckJustification !== undefined ? hostAckJustification : {}) : (hostAckJustification || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostackApi - functional programming interface
 * @export
 */
export const HostackApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the new hostack.  If there\'s already an acknowledgement of this rule by this account for a system, then return that.  This does not take an \'id\' number.
         * @summary Add an acknowledgement for a rule, by rule ID, system, and account.
         * @param {HostAck} hostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackCreate(hostAck: HostAck, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostAck> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackCreate(hostAck, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Takes the hostack ID (given in the hostack list) as an identifier.
         * @summary Delete an acknowledgement for a rule, for a system, for an account, by its ID.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackDelete(id: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Hostacks are retrieved, edited and deleted by the \'id\' field.
         * @summary List host acks from this account for a system where the rule is active.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<string>} [ruleId] Display host acknowledgement of this/these rules
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackList(limit?: number, offset?: number, ruleId?: Array<string>, tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackList(limit, offset, ruleId, tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This view handles listing, retrieving, creating and deleting hostacks.
         * @summary HostAcks acknowledge (and therefore hide) a rule from view in an account for a specific system.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackRead(id: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostAck> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The justification is taken from the request body.  The created_by field is taken from the username in the x-rh-identity field, and the updated_at field is set to the current time.
         * @summary Update the justification for this host acknowledgement.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {HostAckJustification} hostAckJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackUpdate(id: number, hostAckJustification: HostAckJustification, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostAckJustification> {
            const localVarAxiosArgs = HostackApiAxiosParamCreator(configuration).hostackUpdate(id, hostAckJustification, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HostackApi - factory interface
 * @export
 */
export const HostackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return the new hostack.  If there\'s already an acknowledgement of this rule by this account for a system, then return that.  This does not take an \'id\' number.
         * @summary Add an acknowledgement for a rule, by rule ID, system, and account.
         * @param {HostAck} hostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackCreate(hostAck: HostAck, options?: any): AxiosPromise<HostAck> {
            return HostackApiFp(configuration).hostackCreate(hostAck, options)(axios, basePath);
        },
        /**
         * Takes the hostack ID (given in the hostack list) as an identifier.
         * @summary Delete an acknowledgement for a rule, for a system, for an account, by its ID.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackDelete(id: number, options?: any): AxiosPromise<void> {
            return HostackApiFp(configuration).hostackDelete(id, options)(axios, basePath);
        },
        /**
         * Hostacks are retrieved, edited and deleted by the \'id\' field.
         * @summary List host acks from this account for a system where the rule is active.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<string>} [ruleId] Display host acknowledgement of this/these rules
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackList(limit?: number, offset?: number, ruleId?: Array<string>, tags?: Array<string>, options?: any): AxiosPromise<InlineResponse2002> {
            return HostackApiFp(configuration).hostackList(limit, offset, ruleId, tags, options)(axios, basePath);
        },
        /**
         * This view handles listing, retrieving, creating and deleting hostacks.
         * @summary HostAcks acknowledge (and therefore hide) a rule from view in an account for a specific system.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackRead(id: number, options?: any): AxiosPromise<HostAck> {
            return HostackApiFp(configuration).hostackRead(id, options)(axios, basePath);
        },
        /**
         * The justification is taken from the request body.  The created_by field is taken from the username in the x-rh-identity field, and the updated_at field is set to the current time.
         * @summary Update the justification for this host acknowledgement.
         * @param {number} id A unique integer value identifying this host ack.
         * @param {HostAckJustification} hostAckJustification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostackUpdate(id: number, hostAckJustification: HostAckJustification, options?: any): AxiosPromise<HostAckJustification> {
            return HostackApiFp(configuration).hostackUpdate(id, hostAckJustification, options)(axios, basePath);
        },
    };
};

/**
 * HostackApi - object-oriented interface
 * @export
 * @class HostackApi
 * @extends {BaseAPI}
 */
export class HostackApi extends BaseAPI {
    /**
     * Return the new hostack.  If there\'s already an acknowledgement of this rule by this account for a system, then return that.  This does not take an \'id\' number.
     * @summary Add an acknowledgement for a rule, by rule ID, system, and account.
     * @param {HostAck} hostAck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackCreate(hostAck: HostAck, options?: any) {
        return HostackApiFp(this.configuration).hostackCreate(hostAck, options)(this.axios, this.basePath);
    }

    /**
     * Takes the hostack ID (given in the hostack list) as an identifier.
     * @summary Delete an acknowledgement for a rule, for a system, for an account, by its ID.
     * @param {number} id A unique integer value identifying this host ack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackDelete(id: number, options?: any) {
        return HostackApiFp(this.configuration).hostackDelete(id, options)(this.axios, this.basePath);
    }

    /**
     * Hostacks are retrieved, edited and deleted by the \'id\' field.
     * @summary List host acks from this account for a system where the rule is active.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<string>} [ruleId] Display host acknowledgement of this/these rules
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackList(limit?: number, offset?: number, ruleId?: Array<string>, tags?: Array<string>, options?: any) {
        return HostackApiFp(this.configuration).hostackList(limit, offset, ruleId, tags, options)(this.axios, this.basePath);
    }

    /**
     * This view handles listing, retrieving, creating and deleting hostacks.
     * @summary HostAcks acknowledge (and therefore hide) a rule from view in an account for a specific system.
     * @param {number} id A unique integer value identifying this host ack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackRead(id: number, options?: any) {
        return HostackApiFp(this.configuration).hostackRead(id, options)(this.axios, this.basePath);
    }

    /**
     * The justification is taken from the request body.  The created_by field is taken from the username in the x-rh-identity field, and the updated_at field is set to the current time.
     * @summary Update the justification for this host acknowledgement.
     * @param {number} id A unique integer value identifying this host ack.
     * @param {HostAckJustification} hostAckJustification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostackApi
     */
    public hostackUpdate(id: number, hostAckJustification: HostAckJustification, options?: any) {
        return HostackApiFp(this.configuration).hostackUpdate(id, hostAckJustification, options)(this.axios, this.basePath);
    }

}


/**
 * KcsApi - axios parameter creator
 * @export
 */
export const KcsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of dicts of the C.R.C rule URL and its KCS solution number
         * @summary Looks for all active rules with KCS solutions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kcsList(options: any = {}): RequestArgs {
            const localVarPath = `/kcs/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of C.R.C rule url(s) for that KCS solution
         * @summary Gets active rule(s) for a particular KCS solution (node_id)
         * @param {string} nodeId KCS solution number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kcsRead(nodeId: string, options: any = {}): RequestArgs {
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling kcsRead.');
            }
            const localVarPath = `/kcs/{node_id}/`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KcsApi - functional programming interface
 * @export
 */
export const KcsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a list of dicts of the C.R.C rule URL and its KCS solution number
         * @summary Looks for all active rules with KCS solutions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kcsList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Kcs>> {
            const localVarAxiosArgs = KcsApiAxiosParamCreator(configuration).kcsList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of C.R.C rule url(s) for that KCS solution
         * @summary Gets active rule(s) for a particular KCS solution (node_id)
         * @param {string} nodeId KCS solution number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kcsRead(nodeId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = KcsApiAxiosParamCreator(configuration).kcsRead(nodeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * KcsApi - factory interface
 * @export
 */
export const KcsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a list of dicts of the C.R.C rule URL and its KCS solution number
         * @summary Looks for all active rules with KCS solutions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kcsList(options?: any): AxiosPromise<Array<Kcs>> {
            return KcsApiFp(configuration).kcsList(options)(axios, basePath);
        },
        /**
         * Returns a list of C.R.C rule url(s) for that KCS solution
         * @summary Gets active rule(s) for a particular KCS solution (node_id)
         * @param {string} nodeId KCS solution number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kcsRead(nodeId: string, options?: any): AxiosPromise<Array<string>> {
            return KcsApiFp(configuration).kcsRead(nodeId, options)(axios, basePath);
        },
    };
};

/**
 * KcsApi - object-oriented interface
 * @export
 * @class KcsApi
 * @extends {BaseAPI}
 */
export class KcsApi extends BaseAPI {
    /**
     * Returns a list of dicts of the C.R.C rule URL and its KCS solution number
     * @summary Looks for all active rules with KCS solutions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KcsApi
     */
    public kcsList(options?: any) {
        return KcsApiFp(this.configuration).kcsList(options)(this.axios, this.basePath);
    }

    /**
     * Returns a list of C.R.C rule url(s) for that KCS solution
     * @summary Gets active rule(s) for a particular KCS solution (node_id)
     * @param {string} nodeId KCS solution number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KcsApi
     */
    public kcsRead(nodeId: string, options?: any) {
        return KcsApiFp(this.configuration).kcsRead(nodeId, options)(this.axios, this.basePath);
    }

}


/**
 * RatingApi - axios parameter creator
 * @export
 */
export const RatingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the new rating.  Any previous rating for this rule by this user is amended to the current value.  This does not attempt to delete a rating by this user of this rule if the rating is zero.
         * @summary Add or update a rating for a rule, by rule ID.
         * @param {RuleRating} ruleRating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingCreate(ruleRating: RuleRating, options: any = {}): RequestArgs {
            // verify required parameter 'ruleRating' is not null or undefined
            if (ruleRating === null || ruleRating === undefined) {
                throw new RequiredError('ruleRating','Required parameter ruleRating was null or undefined when calling ratingCreate.');
            }
            const localVarPath = `/rating/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof ruleRating !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ruleRating !== undefined ? ruleRating : {}) : (ruleRating || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only the current user\'s ratings are listed here.
         * @summary List all rules rated by the current user
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingList(limit?: number, offset?: number, options: any = {}): RequestArgs {
            const localVarPath = `/rating/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the ratings for a single rule, by Insights Rule ID
         * @summary Retrieve the ratings for a single rule
         * @param {string} rule Insights Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingRead(rule: string, options: any = {}): RequestArgs {
            // verify required parameter 'rule' is not null or undefined
            if (rule === null || rule === undefined) {
                throw new RequiredError('rule','Required parameter rule was null or undefined when calling ratingRead.');
            }
            const localVarPath = `/rating/{rule}/`
                .replace(`{${"rule"}}`, encodeURIComponent(String(rule)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RatingApi - functional programming interface
 * @export
 */
export const RatingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return the new rating.  Any previous rating for this rule by this user is amended to the current value.  This does not attempt to delete a rating by this user of this rule if the rating is zero.
         * @summary Add or update a rating for a rule, by rule ID.
         * @param {RuleRating} ruleRating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingCreate(ruleRating: RuleRating, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleRating> {
            const localVarAxiosArgs = RatingApiAxiosParamCreator(configuration).ratingCreate(ruleRating, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Only the current user\'s ratings are listed here.
         * @summary List all rules rated by the current user
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingList(limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003> {
            const localVarAxiosArgs = RatingApiAxiosParamCreator(configuration).ratingList(limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve the ratings for a single rule, by Insights Rule ID
         * @summary Retrieve the ratings for a single rule
         * @param {string} rule Insights Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingRead(rule: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleRating> {
            const localVarAxiosArgs = RatingApiAxiosParamCreator(configuration).ratingRead(rule, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RatingApi - factory interface
 * @export
 */
export const RatingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return the new rating.  Any previous rating for this rule by this user is amended to the current value.  This does not attempt to delete a rating by this user of this rule if the rating is zero.
         * @summary Add or update a rating for a rule, by rule ID.
         * @param {RuleRating} ruleRating
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingCreate(ruleRating: RuleRating, options?: any): AxiosPromise<RuleRating> {
            return RatingApiFp(configuration).ratingCreate(ruleRating, options)(axios, basePath);
        },
        /**
         * Only the current user\'s ratings are listed here.
         * @summary List all rules rated by the current user
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingList(limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return RatingApiFp(configuration).ratingList(limit, offset, options)(axios, basePath);
        },
        /**
         * Retrieve the ratings for a single rule, by Insights Rule ID
         * @summary Retrieve the ratings for a single rule
         * @param {string} rule Insights Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ratingRead(rule: string, options?: any): AxiosPromise<RuleRating> {
            return RatingApiFp(configuration).ratingRead(rule, options)(axios, basePath);
        },
    };
};

/**
 * RatingApi - object-oriented interface
 * @export
 * @class RatingApi
 * @extends {BaseAPI}
 */
export class RatingApi extends BaseAPI {
    /**
     * Return the new rating.  Any previous rating for this rule by this user is amended to the current value.  This does not attempt to delete a rating by this user of this rule if the rating is zero.
     * @summary Add or update a rating for a rule, by rule ID.
     * @param {RuleRating} ruleRating
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingApi
     */
    public ratingCreate(ruleRating: RuleRating, options?: any) {
        return RatingApiFp(this.configuration).ratingCreate(ruleRating, options)(this.axios, this.basePath);
    }

    /**
     * Only the current user\'s ratings are listed here.
     * @summary List all rules rated by the current user
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingApi
     */
    public ratingList(limit?: number, offset?: number, options?: any) {
        return RatingApiFp(this.configuration).ratingList(limit, offset, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve the ratings for a single rule, by Insights Rule ID
     * @summary Retrieve the ratings for a single rule
     * @param {string} rule Insights Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RatingApi
     */
    public ratingRead(rule: string, options?: any) {
        return RatingApiFp(this.configuration).ratingRead(rule, options)(this.axios, this.basePath);
    }

}


/**
 * ResolutionRiskApi - axios parameter creator
 * @export
 */
export const ResolutionRiskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Risks are listed in increasing order of severity.
         * @summary List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolutionRiskList(options: any = {}): RequestArgs {
            const localVarPath = `/resolution_risk/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResolutionRiskApi - functional programming interface
 * @export
 */
export const ResolutionRiskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Risks are listed in increasing order of severity.
         * @summary List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolutionRiskList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = ResolutionRiskApiAxiosParamCreator(configuration).resolutionRiskList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResolutionRiskApi - factory interface
 * @export
 */
export const ResolutionRiskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Risks are listed in increasing order of severity.
         * @summary List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolutionRiskList(options?: any): AxiosPromise<void> {
            return ResolutionRiskApiFp(configuration).resolutionRiskList(options)(axios, basePath);
        },
    };
};

/**
 * ResolutionRiskApi - object-oriented interface
 * @export
 * @class ResolutionRiskApi
 * @extends {BaseAPI}
 */
export class ResolutionRiskApi extends BaseAPI {
    /**
     * Risks are listed in increasing order of severity.
     * @summary List all total risk values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionRiskApi
     */
    public resolutionRiskList(options?: any) {
        return ResolutionRiskApiFp(this.configuration).resolutionRiskList(options)(this.axios, this.basePath);
    }

}


/**
 * RuleApi - axios parameter creator
 * @export
 */
export const RuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Host acknowledgements will be added to this rule in this account for the system UUIDs supplied.  The justification supplied will be given for all host acks created.  Any existing host acknowledgements for a host on this rule will be updated.  The count of created hosts acknowledgements, and the list of systems now impacted by this rule, will be returned.  Account-wide acks are unaffected.
         * @summary Add acknowledgements for one or more hosts to this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {MultiHostAck} multiHostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAckHosts(ruleId: string, multiHostAck: MultiHostAck, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ruleAckHosts.');
            }
            // verify required parameter 'multiHostAck' is not null or undefined
            if (multiHostAck === null || multiHostAck === undefined) {
                throw new RequiredError('multiHostAck','Required parameter multiHostAck was null or undefined when calling ruleAckHosts.');
            }
            const localVarPath = `/rule/{rule_id}/ack_hosts/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof multiHostAck !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(multiHostAck !== undefined ? multiHostAck : {}) : (multiHostAck || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If \'acked\' is False or not given, then only rules that are not acked will be shown.  If acked is set and \'true\' as a string or evaluates to a true value, then all rules including those that are acked will be shown.
         * @summary List all active rules for this account.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<string>} [hasTag] Display rules that have (one or more) tags
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {boolean} [impacting] Display only rules that are impacting systems currently
         * @param {boolean} [incident] Display only rules that cause an incident
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {boolean} [reboot] Display rules that require a reboot to fix
         * @param {boolean} [reportsShown] Display rules where reports are shown or not
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {Array<'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'>} [sort] Order by this field
         * @param {string} [text] Display rules with this text in their text fields
         * @param {string} [topic] Display rules in this topic (slug)
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {boolean} [hasPlaybook] Display rules that have a playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleList(limit?: number, offset?: number, category?: Array<1 | 2 | 3 | 4>, hasTag?: Array<string>, tags?: Array<string>, impact?: Array<1 | 2 | 3 | 4>, impacting?: boolean, incident?: boolean, likelihood?: Array<1 | 2 | 3 | 4>, reboot?: boolean, reportsShown?: boolean, resRisk?: Array<1 | 2 | 3 | 4>, sort?: Array<'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'>, text?: string, topic?: string, totalRisk?: Array<1 | 2 | 3 | 4>, hasPlaybook?: boolean, options: any = {}): RequestArgs {
            const localVarPath = `/rule/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (category) {
                localVarQueryParameter['category'] = category.join(COLLECTION_FORMATS.csv);
            }

            if (hasTag) {
                localVarQueryParameter['has_tag'] = hasTag.join(COLLECTION_FORMATS.csv);
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (impact) {
                localVarQueryParameter['impact'] = impact.join(COLLECTION_FORMATS.csv);
            }

            if (impacting !== undefined) {
                localVarQueryParameter['impacting'] = impacting;
            }

            if (incident !== undefined) {
                localVarQueryParameter['incident'] = incident;
            }

            if (likelihood) {
                localVarQueryParameter['likelihood'] = likelihood.join(COLLECTION_FORMATS.csv);
            }

            if (reboot !== undefined) {
                localVarQueryParameter['reboot'] = reboot;
            }

            if (reportsShown !== undefined) {
                localVarQueryParameter['reports_shown'] = reportsShown;
            }

            if (resRisk) {
                localVarQueryParameter['res_risk'] = resRisk.join(COLLECTION_FORMATS.csv);
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (totalRisk) {
                localVarQueryParameter['total_risk'] = totalRisk.join(COLLECTION_FORMATS.csv);
            }

            if (hasPlaybook !== undefined) {
                localVarQueryParameter['has_playbook'] = hasPlaybook;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This includes the account-relevant details such as number of impacted systems and host acknowledgements.
         * @summary Retrieve a single rule and its associated details.
         * @param {string} ruleId Rule ID from Insights
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleRead(ruleId: string, tags?: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ruleRead.');
            }
            const localVarPath = `/rule/{rule_id}/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All systems owned by the user\'s account, with a current upload reporting the given rule, are listed.  Systems are simply listed by Insights Inventory UUID.
         * @summary List all systems affected by this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleSystems(ruleId: string, tags?: Array<string>, sort?: Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ruleSystems.');
            }
            const localVarPath = `/rule/{rule_id}/systems/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Any host acknowledgements for this rule in this account for the given system are deleted.  Hosts that do not have an acknowledgement for this rule in this account are ignored.  The count of deleted host acknowledgements, and the list of hosts now impacted by this rule, will be returned.  Account-wide acks are unaffected.
         * @summary Delete acknowledgements for one or more hosts to this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {MultiHostUnAck} multiHostUnAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUnackHosts(ruleId: string, multiHostUnAck: MultiHostUnAck, options: any = {}): RequestArgs {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling ruleUnackHosts.');
            }
            // verify required parameter 'multiHostUnAck' is not null or undefined
            if (multiHostUnAck === null || multiHostUnAck === undefined) {
                throw new RequiredError('multiHostUnAck','Required parameter multiHostUnAck was null or undefined when calling ruleUnackHosts.');
            }
            const localVarPath = `/rule/{rule_id}/unack_hosts/`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof multiHostUnAck !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(multiHostUnAck !== undefined ? multiHostUnAck : {}) : (multiHostUnAck || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleApi - functional programming interface
 * @export
 */
export const RuleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Host acknowledgements will be added to this rule in this account for the system UUIDs supplied.  The justification supplied will be given for all host acks created.  Any existing host acknowledgements for a host on this rule will be updated.  The count of created hosts acknowledgements, and the list of systems now impacted by this rule, will be returned.  Account-wide acks are unaffected.
         * @summary Add acknowledgements for one or more hosts to this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {MultiHostAck} multiHostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAckHosts(ruleId: string, multiHostAck: MultiHostAck, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultiAckResponse> {
            const localVarAxiosArgs = RuleApiAxiosParamCreator(configuration).ruleAckHosts(ruleId, multiHostAck, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If \'acked\' is False or not given, then only rules that are not acked will be shown.  If acked is set and \'true\' as a string or evaluates to a true value, then all rules including those that are acked will be shown.
         * @summary List all active rules for this account.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<string>} [hasTag] Display rules that have (one or more) tags
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {boolean} [impacting] Display only rules that are impacting systems currently
         * @param {boolean} [incident] Display only rules that cause an incident
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {boolean} [reboot] Display rules that require a reboot to fix
         * @param {boolean} [reportsShown] Display rules where reports are shown or not
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {Array<'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'>} [sort] Order by this field
         * @param {string} [text] Display rules with this text in their text fields
         * @param {string} [topic] Display rules in this topic (slug)
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {boolean} [hasPlaybook] Display rules that have a playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleList(limit?: number, offset?: number, category?: Array<1 | 2 | 3 | 4>, hasTag?: Array<string>, tags?: Array<string>, impact?: Array<1 | 2 | 3 | 4>, impacting?: boolean, incident?: boolean, likelihood?: Array<1 | 2 | 3 | 4>, reboot?: boolean, reportsShown?: boolean, resRisk?: Array<1 | 2 | 3 | 4>, sort?: Array<'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'>, text?: string, topic?: string, totalRisk?: Array<1 | 2 | 3 | 4>, hasPlaybook?: boolean, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004> {
            const localVarAxiosArgs = RuleApiAxiosParamCreator(configuration).ruleList(limit, offset, category, hasTag, tags, impact, impacting, incident, likelihood, reboot, reportsShown, resRisk, sort, text, topic, totalRisk, hasPlaybook, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This includes the account-relevant details such as number of impacted systems and host acknowledgements.
         * @summary Retrieve a single rule and its associated details.
         * @param {string} ruleId Rule ID from Insights
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleRead(ruleId: string, tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleForAccount> {
            const localVarAxiosArgs = RuleApiAxiosParamCreator(configuration).ruleRead(ruleId, tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * All systems owned by the user\'s account, with a current upload reporting the given rule, are listed.  Systems are simply listed by Insights Inventory UUID.
         * @summary List all systems affected by this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleSystems(ruleId: string, tags?: Array<string>, sort?: Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemsForRule> {
            const localVarAxiosArgs = RuleApiAxiosParamCreator(configuration).ruleSystems(ruleId, tags, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Any host acknowledgements for this rule in this account for the given system are deleted.  Hosts that do not have an acknowledgement for this rule in this account are ignored.  The count of deleted host acknowledgements, and the list of hosts now impacted by this rule, will be returned.  Account-wide acks are unaffected.
         * @summary Delete acknowledgements for one or more hosts to this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {MultiHostUnAck} multiHostUnAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUnackHosts(ruleId: string, multiHostUnAck: MultiHostUnAck, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultiAckResponse> {
            const localVarAxiosArgs = RuleApiAxiosParamCreator(configuration).ruleUnackHosts(ruleId, multiHostUnAck, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RuleApi - factory interface
 * @export
 */
export const RuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Host acknowledgements will be added to this rule in this account for the system UUIDs supplied.  The justification supplied will be given for all host acks created.  Any existing host acknowledgements for a host on this rule will be updated.  The count of created hosts acknowledgements, and the list of systems now impacted by this rule, will be returned.  Account-wide acks are unaffected.
         * @summary Add acknowledgements for one or more hosts to this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {MultiHostAck} multiHostAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleAckHosts(ruleId: string, multiHostAck: MultiHostAck, options?: any): AxiosPromise<MultiAckResponse> {
            return RuleApiFp(configuration).ruleAckHosts(ruleId, multiHostAck, options)(axios, basePath);
        },
        /**
         * If \'acked\' is False or not given, then only rules that are not acked will be shown.  If acked is set and \'true\' as a string or evaluates to a true value, then all rules including those that are acked will be shown.
         * @summary List all active rules for this account.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
         * @param {Array<string>} [hasTag] Display rules that have (one or more) tags
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
         * @param {boolean} [impacting] Display only rules that are impacting systems currently
         * @param {boolean} [incident] Display only rules that cause an incident
         * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
         * @param {boolean} [reboot] Display rules that require a reboot to fix
         * @param {boolean} [reportsShown] Display rules where reports are shown or not
         * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
         * @param {Array<'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'>} [sort] Order by this field
         * @param {string} [text] Display rules with this text in their text fields
         * @param {string} [topic] Display rules in this topic (slug)
         * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
         * @param {boolean} [hasPlaybook] Display rules that have a playbook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleList(limit?: number, offset?: number, category?: Array<1 | 2 | 3 | 4>, hasTag?: Array<string>, tags?: Array<string>, impact?: Array<1 | 2 | 3 | 4>, impacting?: boolean, incident?: boolean, likelihood?: Array<1 | 2 | 3 | 4>, reboot?: boolean, reportsShown?: boolean, resRisk?: Array<1 | 2 | 3 | 4>, sort?: Array<'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'>, text?: string, topic?: string, totalRisk?: Array<1 | 2 | 3 | 4>, hasPlaybook?: boolean, options?: any): AxiosPromise<InlineResponse2004> {
            return RuleApiFp(configuration).ruleList(limit, offset, category, hasTag, tags, impact, impacting, incident, likelihood, reboot, reportsShown, resRisk, sort, text, topic, totalRisk, hasPlaybook, options)(axios, basePath);
        },
        /**
         * This includes the account-relevant details such as number of impacted systems and host acknowledgements.
         * @summary Retrieve a single rule and its associated details.
         * @param {string} ruleId Rule ID from Insights
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleRead(ruleId: string, tags?: Array<string>, options?: any): AxiosPromise<RuleForAccount> {
            return RuleApiFp(configuration).ruleRead(ruleId, tags, options)(axios, basePath);
        },
        /**
         * All systems owned by the user\'s account, with a current upload reporting the given rule, are listed.  Systems are simply listed by Insights Inventory UUID.
         * @summary List all systems affected by this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleSystems(ruleId: string, tags?: Array<string>, sort?: Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>, options?: any): AxiosPromise<SystemsForRule> {
            return RuleApiFp(configuration).ruleSystems(ruleId, tags, sort, options)(axios, basePath);
        },
        /**
         * Any host acknowledgements for this rule in this account for the given system are deleted.  Hosts that do not have an acknowledgement for this rule in this account are ignored.  The count of deleted host acknowledgements, and the list of hosts now impacted by this rule, will be returned.  Account-wide acks are unaffected.
         * @summary Delete acknowledgements for one or more hosts to this rule.
         * @param {string} ruleId Rule ID from Insights
         * @param {MultiHostUnAck} multiHostUnAck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleUnackHosts(ruleId: string, multiHostUnAck: MultiHostUnAck, options?: any): AxiosPromise<MultiAckResponse> {
            return RuleApiFp(configuration).ruleUnackHosts(ruleId, multiHostUnAck, options)(axios, basePath);
        },
    };
};

/**
 * RuleApi - object-oriented interface
 * @export
 * @class RuleApi
 * @extends {BaseAPI}
 */
export class RuleApi extends BaseAPI {
    /**
     * Host acknowledgements will be added to this rule in this account for the system UUIDs supplied.  The justification supplied will be given for all host acks created.  Any existing host acknowledgements for a host on this rule will be updated.  The count of created hosts acknowledgements, and the list of systems now impacted by this rule, will be returned.  Account-wide acks are unaffected.
     * @summary Add acknowledgements for one or more hosts to this rule.
     * @param {string} ruleId Rule ID from Insights
     * @param {MultiHostAck} multiHostAck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public ruleAckHosts(ruleId: string, multiHostAck: MultiHostAck, options?: any) {
        return RuleApiFp(this.configuration).ruleAckHosts(ruleId, multiHostAck, options)(this.axios, this.basePath);
    }

    /**
     * If \'acked\' is False or not given, then only rules that are not acked will be shown.  If acked is set and \'true\' as a string or evaluates to a true value, then all rules including those that are acked will be shown.
     * @summary List all active rules for this account.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {Array<1 | 2 | 3 | 4>} [category] Display rules of this category (number)
     * @param {Array<string>} [hasTag] Display rules that have (one or more) tags
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {Array<1 | 2 | 3 | 4>} [impact] Display rules of this impact level (1..4)
     * @param {boolean} [impacting] Display only rules that are impacting systems currently
     * @param {boolean} [incident] Display only rules that cause an incident
     * @param {Array<1 | 2 | 3 | 4>} [likelihood] Display only rules of this likelihood level (1..4)
     * @param {boolean} [reboot] Display rules that require a reboot to fix
     * @param {boolean} [reportsShown] Display rules where reports are shown or not
     * @param {Array<1 | 2 | 3 | 4>} [resRisk] Display rules with this resolution risk level (1..4)
     * @param {Array<'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'>} [sort] Order by this field
     * @param {string} [text] Display rules with this text in their text fields
     * @param {string} [topic] Display rules in this topic (slug)
     * @param {Array<1 | 2 | 3 | 4>} [totalRisk] Display rules with this total risk level (1..4)
     * @param {boolean} [hasPlaybook] Display rules that have a playbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public ruleList(limit?: number, offset?: number, category?: Array<1 | 2 | 3 | 4>, hasTag?: Array<string>, tags?: Array<string>, impact?: Array<1 | 2 | 3 | 4>, impacting?: boolean, incident?: boolean, likelihood?: Array<1 | 2 | 3 | 4>, reboot?: boolean, reportsShown?: boolean, resRisk?: Array<1 | 2 | 3 | 4>, sort?: Array<'category' | 'description' | 'impact' | 'impacted_count' | 'likelihood' | 'playbook_count' | 'publish_date' | 'rule_id' | 'total_risk' | 'resolution_risk' | '-category' | '-description' | '-impact' | '-impacted_count' | '-likelihood' | '-playbook_count' | '-publish_date' | '-rule_id' | '-total_risk' | '-resolution_risk'>, text?: string, topic?: string, totalRisk?: Array<1 | 2 | 3 | 4>, hasPlaybook?: boolean, options?: any) {
        return RuleApiFp(this.configuration).ruleList(limit, offset, category, hasTag, tags, impact, impacting, incident, likelihood, reboot, reportsShown, resRisk, sort, text, topic, totalRisk, hasPlaybook, options)(this.axios, this.basePath);
    }

    /**
     * This includes the account-relevant details such as number of impacted systems and host acknowledgements.
     * @summary Retrieve a single rule and its associated details.
     * @param {string} ruleId Rule ID from Insights
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public ruleRead(ruleId: string, tags?: Array<string>, options?: any) {
        return RuleApiFp(this.configuration).ruleRead(ruleId, tags, options)(this.axios, this.basePath);
    }

    /**
     * All systems owned by the user\'s account, with a current upload reporting the given rule, are listed.  Systems are simply listed by Insights Inventory UUID.
     * @summary List all systems affected by this rule.
     * @param {string} ruleId Rule ID from Insights
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>} [sort] Order by this field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public ruleSystems(ruleId: string, tags?: Array<string>, sort?: Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>, options?: any) {
        return RuleApiFp(this.configuration).ruleSystems(ruleId, tags, sort, options)(this.axios, this.basePath);
    }

    /**
     * Any host acknowledgements for this rule in this account for the given system are deleted.  Hosts that do not have an acknowledgement for this rule in this account are ignored.  The count of deleted host acknowledgements, and the list of hosts now impacted by this rule, will be returned.  Account-wide acks are unaffected.
     * @summary Delete acknowledgements for one or more hosts to this rule.
     * @param {string} ruleId Rule ID from Insights
     * @param {MultiHostUnAck} multiHostUnAck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public ruleUnackHosts(ruleId: string, multiHostUnAck: MultiHostUnAck, options?: any) {
        return RuleApiFp(this.configuration).ruleUnackHosts(ruleId, multiHostUnAck, options)(this.axios, this.basePath);
    }

}


/**
 * RulecategoryApi - axios parameter creator
 * @export
 */
export const RulecategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Categories are listed in decreasing order of importance.
         * @summary Rules are divided into categories, the usual being Availability, Stability, Security and Performance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryList(options: any = {}): RequestArgs {
            const localVarPath = `/rulecategory/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Categories are listed in decreasing order of importance.
         * @summary Rules are divided into categories, the usual being Availability, Stability, Security and Performance.
         * @param {number} id A unique integer value identifying this rule category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryRead(id: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rulecategoryRead.');
            }
            const localVarPath = `/rulecategory/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulecategoryApi - functional programming interface
 * @export
 */
export const RulecategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Categories are listed in decreasing order of importance.
         * @summary Rules are divided into categories, the usual being Availability, Stability, Security and Performance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleCategory>> {
            const localVarAxiosArgs = RulecategoryApiAxiosParamCreator(configuration).rulecategoryList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Categories are listed in decreasing order of importance.
         * @summary Rules are divided into categories, the usual being Availability, Stability, Security and Performance.
         * @param {number} id A unique integer value identifying this rule category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryRead(id: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleCategory> {
            const localVarAxiosArgs = RulecategoryApiAxiosParamCreator(configuration).rulecategoryRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RulecategoryApi - factory interface
 * @export
 */
export const RulecategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Categories are listed in decreasing order of importance.
         * @summary Rules are divided into categories, the usual being Availability, Stability, Security and Performance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryList(options?: any): AxiosPromise<Array<RuleCategory>> {
            return RulecategoryApiFp(configuration).rulecategoryList(options)(axios, basePath);
        },
        /**
         * Categories are listed in decreasing order of importance.
         * @summary Rules are divided into categories, the usual being Availability, Stability, Security and Performance.
         * @param {number} id A unique integer value identifying this rule category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rulecategoryRead(id: number, options?: any): AxiosPromise<RuleCategory> {
            return RulecategoryApiFp(configuration).rulecategoryRead(id, options)(axios, basePath);
        },
    };
};

/**
 * RulecategoryApi - object-oriented interface
 * @export
 * @class RulecategoryApi
 * @extends {BaseAPI}
 */
export class RulecategoryApi extends BaseAPI {
    /**
     * Categories are listed in decreasing order of importance.
     * @summary Rules are divided into categories, the usual being Availability, Stability, Security and Performance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulecategoryApi
     */
    public rulecategoryList(options?: any) {
        return RulecategoryApiFp(this.configuration).rulecategoryList(options)(this.axios, this.basePath);
    }

    /**
     * Categories are listed in decreasing order of importance.
     * @summary Rules are divided into categories, the usual being Availability, Stability, Security and Performance.
     * @param {number} id A unique integer value identifying this rule category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulecategoryApi
     */
    public rulecategoryRead(id: number, options?: any) {
        return RulecategoryApiFp(this.configuration).rulecategoryRead(id, options)(this.axios, this.basePath);
    }

}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The current account settings will be updated, or one will be created, with the
         * @summary Accept the settings as input, and adjust the actual models accordingly.
         * @param {SettingsInput} settingsInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCreate(settingsInput: SettingsInput, options: any = {}): RequestArgs {
            // verify required parameter 'settingsInput' is not null or undefined
            if (settingsInput === null || settingsInput === undefined) {
                throw new RequiredError('settingsInput','Required parameter settingsInput was null or undefined when calling settingsCreate.');
            }
            const localVarPath = `/settings/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof settingsInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(settingsInput !== undefined ? settingsInput : {}) : (settingsInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This simply compiles the \'show_satellite_hosts\' account-wide setting into a format compatible with Data-Driven Forms.
         * @summary Describe the settings we have in a Data-Driven Forms way.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsList(options: any = {}): RequestArgs {
            const localVarPath = `/settings/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The current account settings will be updated, or one will be created, with the
         * @summary Accept the settings as input, and adjust the actual models accordingly.
         * @param {SettingsInput} settingsInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCreate(settingsInput: SettingsInput, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsInput> {
            const localVarAxiosArgs = SettingsApiAxiosParamCreator(configuration).settingsCreate(settingsInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This simply compiles the \'show_satellite_hosts\' account-wide setting into a format compatible with Data-Driven Forms.
         * @summary Describe the settings we have in a Data-Driven Forms way.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SettingsDDF>> {
            const localVarAxiosArgs = SettingsApiAxiosParamCreator(configuration).settingsList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The current account settings will be updated, or one will be created, with the
         * @summary Accept the settings as input, and adjust the actual models accordingly.
         * @param {SettingsInput} settingsInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsCreate(settingsInput: SettingsInput, options?: any): AxiosPromise<SettingsInput> {
            return SettingsApiFp(configuration).settingsCreate(settingsInput, options)(axios, basePath);
        },
        /**
         * This simply compiles the \'show_satellite_hosts\' account-wide setting into a format compatible with Data-Driven Forms.
         * @summary Describe the settings we have in a Data-Driven Forms way.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsList(options?: any): AxiosPromise<Array<SettingsDDF>> {
            return SettingsApiFp(configuration).settingsList(options)(axios, basePath);
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * The current account settings will be updated, or one will be created, with the
     * @summary Accept the settings as input, and adjust the actual models accordingly.
     * @param {SettingsInput} settingsInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsCreate(settingsInput: SettingsInput, options?: any) {
        return SettingsApiFp(this.configuration).settingsCreate(settingsInput, options)(this.axios, this.basePath);
    }

    /**
     * This simply compiles the \'show_satellite_hosts\' account-wide setting into a format compatible with Data-Driven Forms.
     * @summary Describe the settings we have in a Data-Driven Forms way.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsList(options?: any) {
        return SettingsApiFp(this.configuration).settingsList(options)(this.axios, this.basePath);
    }

}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Copied sort-of from the APIRootView\'s `get` method.
         * @summary Provide a simple list of URLs contained here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsList(options: any = {}): RequestArgs {
            const localVarPath = `/stats/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of reports impacting across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsReports(tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/stats/reports/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of rule usage across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRules(tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/stats/rules/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For historic reasons, \'stale\' refers to hosts that are being warned of being stale, and \'stale_warn\' refers to hosts that are being hidden from display.
         * @summary Show statistics of stale warning and hidden systems.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsStaleHosts(tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/stats/stale_hosts/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of systems being impacted across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystems(tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/stats/systems/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Copied sort-of from the APIRootView\'s `get` method.
         * @summary Provide a simple list of URLs contained here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of reports impacting across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsReports(tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsReports(tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of rule usage across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRules(tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsRules(tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * For historic reasons, \'stale\' refers to hosts that are being warned of being stale, and \'stale_warn\' refers to hosts that are being hidden from display.
         * @summary Show statistics of stale warning and hidden systems.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsStaleHosts(tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StaleSystemStats> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsStaleHosts(tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of systems being impacted across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystems(tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats> {
            const localVarAxiosArgs = StatsApiAxiosParamCreator(configuration).statsSystems(tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Copied sort-of from the APIRootView\'s `get` method.
         * @summary Provide a simple list of URLs contained here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsList(options?: any): AxiosPromise<void> {
            return StatsApiFp(configuration).statsList(options)(axios, basePath);
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of reports impacting across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsReports(tags?: Array<string>, options?: any): AxiosPromise<Stats> {
            return StatsApiFp(configuration).statsReports(tags, options)(axios, basePath);
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of rule usage across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsRules(tags?: Array<string>, options?: any): AxiosPromise<Stats> {
            return StatsApiFp(configuration).statsRules(tags, options)(axios, basePath);
        },
        /**
         * For historic reasons, \'stale\' refers to hosts that are being warned of being stale, and \'stale_warn\' refers to hosts that are being hidden from display.
         * @summary Show statistics of stale warning and hidden systems.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsStaleHosts(tags?: Array<string>, options?: any): AxiosPromise<StaleSystemStats> {
            return StatsApiFp(configuration).statsStaleHosts(tags, options)(axios, basePath);
        },
        /**
         * Only current reports are considered.
         * @summary Show statistics of systems being impacted across categories and risks.
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsSystems(tags?: Array<string>, options?: any): AxiosPromise<Stats> {
            return StatsApiFp(configuration).statsSystems(tags, options)(axios, basePath);
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Copied sort-of from the APIRootView\'s `get` method.
     * @summary Provide a simple list of URLs contained here.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsList(options?: any) {
        return StatsApiFp(this.configuration).statsList(options)(this.axios, this.basePath);
    }

    /**
     * Only current reports are considered.
     * @summary Show statistics of reports impacting across categories and risks.
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsReports(tags?: Array<string>, options?: any) {
        return StatsApiFp(this.configuration).statsReports(tags, options)(this.axios, this.basePath);
    }

    /**
     * Only current reports are considered.
     * @summary Show statistics of rule usage across categories and risks.
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsRules(tags?: Array<string>, options?: any) {
        return StatsApiFp(this.configuration).statsRules(tags, options)(this.axios, this.basePath);
    }

    /**
     * For historic reasons, \'stale\' refers to hosts that are being warned of being stale, and \'stale_warn\' refers to hosts that are being hidden from display.
     * @summary Show statistics of stale warning and hidden systems.
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsStaleHosts(tags?: Array<string>, options?: any) {
        return StatsApiFp(this.configuration).statsStaleHosts(tags, options)(this.axios, this.basePath);
    }

    /**
     * Only current reports are considered.
     * @summary Show statistics of systems being impacted across categories and risks.
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsSystems(tags?: Array<string>, options?: any) {
        return StatsApiFp(this.configuration).statsSystems(tags, options)(this.axios, this.basePath);
    }

}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Results can be sorted and systems can be filtered by display name.
         * @summary Returns systems with their hit count and last upload time.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemList(limit?: number, offset?: number, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', displayName?: string, tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/system/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the reports for a single system by Insights Inventory UUID
         * @summary Retrieve the reports for a single system
         * @param {string} uuid The system\&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRead(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling systemRead.');
            }
            const localVarPath = `/system/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns reports that: * are in the user\'s account * have an active, not-deleted rule * where the rule has not been acked by this account If the host ID is not found, return an empty list.
         * @summary Returns the list of latest reports for an Inventory Host ID.
         * @param {string} uuid The system\&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemReports(uuid: string, options: any = {}): RequestArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling systemReports.');
            }
            const localVarPath = `/system/{uuid}/reports/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Results can be sorted and systems can be filtered by display name.
         * @summary Returns systems with their hit count and last upload time.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemList(limit?: number, offset?: number, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', displayName?: string, tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).systemList(limit, offset, sort, displayName, tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve the reports for a single system by Insights Inventory UUID
         * @summary Retrieve the reports for a single system
         * @param {string} uuid The system\&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRead(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<System> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).systemRead(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns reports that: * are in the user\'s account * have an active, not-deleted rule * where the rule has not been acked by this account If the host ID is not found, return an empty list.
         * @summary Returns the list of latest reports for an Inventory Host ID.
         * @param {string} uuid The system\&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemReports(uuid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Report>> {
            const localVarAxiosArgs = SystemApiAxiosParamCreator(configuration).systemReports(uuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Results can be sorted and systems can be filtered by display name.
         * @summary Returns systems with their hit count and last upload time.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
         * @param {string} [displayName] Display systems with this text in their display_name
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemList(limit?: number, offset?: number, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', displayName?: string, tags?: Array<string>, options?: any): AxiosPromise<InlineResponse2005> {
            return SystemApiFp(configuration).systemList(limit, offset, sort, displayName, tags, options)(axios, basePath);
        },
        /**
         * Retrieve the reports for a single system by Insights Inventory UUID
         * @summary Retrieve the reports for a single system
         * @param {string} uuid The system\&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemRead(uuid: string, options?: any): AxiosPromise<System> {
            return SystemApiFp(configuration).systemRead(uuid, options)(axios, basePath);
        },
        /**
         * Returns reports that: * are in the user\'s account * have an active, not-deleted rule * where the rule has not been acked by this account If the host ID is not found, return an empty list.
         * @summary Returns the list of latest reports for an Inventory Host ID.
         * @param {string} uuid The system\&#39;s Host ID in the Inventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemReports(uuid: string, options?: any): AxiosPromise<Array<Report>> {
            return SystemApiFp(configuration).systemReports(uuid, options)(axios, basePath);
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Results can be sorted and systems can be filtered by display name.
     * @summary Returns systems with their hit count and last upload time.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name'} [sort] Order by this field
     * @param {string} [displayName] Display systems with this text in their display_name
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemList(limit?: number, offset?: number, sort?: 'hits' | 'last_seen' | 'display_name' | '-hits' | '-last_seen' | '-display_name', displayName?: string, tags?: Array<string>, options?: any) {
        return SystemApiFp(this.configuration).systemList(limit, offset, sort, displayName, tags, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve the reports for a single system by Insights Inventory UUID
     * @summary Retrieve the reports for a single system
     * @param {string} uuid The system\&#39;s Host ID in the Inventory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemRead(uuid: string, options?: any) {
        return SystemApiFp(this.configuration).systemRead(uuid, options)(this.axios, this.basePath);
    }

    /**
     * Returns reports that: * are in the user\'s account * have an active, not-deleted rule * where the rule has not been acked by this account If the host ID is not found, return an empty list.
     * @summary Returns the list of latest reports for an Inventory Host ID.
     * @param {string} uuid The system\&#39;s Host ID in the Inventory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemReports(uuid: string, options?: any) {
        return SystemApiFp(this.configuration).systemReports(uuid, options)(this.axios, this.basePath);
    }

}


/**
 * SystemtypeApi - axios parameter creator
 * @export
 */
export const SystemtypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all system types by role and product code
         * @summary List all system types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeList(options: any = {}): RequestArgs {
            const localVarPath = `/systemtype/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a single system type
         * @summary Retrieve a system type
         * @param {number} id A unique integer value identifying this system type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeRead(id: number, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling systemtypeRead.');
            }
            const localVarPath = `/systemtype/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemtypeApi - functional programming interface
 * @export
 */
export const SystemtypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List all system types by role and product code
         * @summary List all system types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SystemType>> {
            const localVarAxiosArgs = SystemtypeApiAxiosParamCreator(configuration).systemtypeList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve details of a single system type
         * @summary Retrieve a system type
         * @param {number} id A unique integer value identifying this system type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeRead(id: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemType> {
            const localVarAxiosArgs = SystemtypeApiAxiosParamCreator(configuration).systemtypeRead(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemtypeApi - factory interface
 * @export
 */
export const SystemtypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List all system types by role and product code
         * @summary List all system types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeList(options?: any): AxiosPromise<Array<SystemType>> {
            return SystemtypeApiFp(configuration).systemtypeList(options)(axios, basePath);
        },
        /**
         * Retrieve details of a single system type
         * @summary Retrieve a system type
         * @param {number} id A unique integer value identifying this system type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemtypeRead(id: number, options?: any): AxiosPromise<SystemType> {
            return SystemtypeApiFp(configuration).systemtypeRead(id, options)(axios, basePath);
        },
    };
};

/**
 * SystemtypeApi - object-oriented interface
 * @export
 * @class SystemtypeApi
 * @extends {BaseAPI}
 */
export class SystemtypeApi extends BaseAPI {
    /**
     * List all system types by role and product code
     * @summary List all system types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemtypeApi
     */
    public systemtypeList(options?: any) {
        return SystemtypeApiFp(this.configuration).systemtypeList(options)(this.axios, this.basePath);
    }

    /**
     * Retrieve details of a single system type
     * @summary Retrieve a system type
     * @param {number} id A unique integer value identifying this system type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemtypeApi
     */
    public systemtypeRead(id: number, options?: any) {
        return SystemtypeApiFp(this.configuration).systemtypeRead(id, options)(this.axios, this.basePath);
    }

}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Tags are ordered by namespace, key and value and are given in encoded fromat.
         * @summary List all available host tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options: any = {}): RequestArgs {
            const localVarPath = `/tag/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Tags are ordered by namespace, key and value and are given in encoded fromat.
         * @summary List all available host tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagList> {
            const localVarAxiosArgs = TagApiAxiosParamCreator(configuration).tagList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Tags are ordered by namespace, key and value and are given in encoded fromat.
         * @summary List all available host tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options?: any): AxiosPromise<TagList> {
            return TagApiFp(configuration).tagList(options)(axios, basePath);
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * Tags are ordered by namespace, key and value and are given in encoded fromat.
     * @summary List all available host tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public tagList(options?: any) {
        return TagApiFp(this.configuration).tagList(options)(this.axios, this.basePath);
    }

}


/**
 * TopicApi - axios parameter creator
 * @export
 */
export const TopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Normally this only shows enabled topics, but if the \'show_disabled\' parameter is set to True then this will show disabled topics as well.
         * @summary List the rule topics and their impacted systems counts.
         * @param {boolean} [showDisabled] Display topics that are disabled as well as enabled
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicList(showDisabled?: boolean, tags?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/topic/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (showDisabled !== undefined) {
                localVarQueryParameter['show_disabled'] = showDisabled;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This also lists the topic\'s impacted systems count.
         * @summary Retrieve a single topic by slug.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRead(slug: string, options: any = {}): RequestArgs {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling topicRead.');
            }
            const localVarPath = `/topic/{slug}/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This shows the rule information for rules with this tag.
         * @summary Lists the available rules that have this tag.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRulesWithTag(slug: string, options: any = {}): RequestArgs {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling topicRulesWithTag.');
            }
            const localVarPath = `/topic/{slug}/rules_with_tag/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Systems are just listed by their UUID.
         * @summary List all systems affected by this rule topic.
         * @param {string} slug Rule topic slug
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSystems(slug: string, tags?: Array<string>, sort?: Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>, options: any = {}): RequestArgs {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling topicSystems.');
            }
            const localVarPath = `/topic/{slug}/systems/`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopicApi - functional programming interface
 * @export
 */
export const TopicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Normally this only shows enabled topics, but if the \'show_disabled\' parameter is set to True then this will show disabled topics as well.
         * @summary List the rule topics and their impacted systems counts.
         * @param {boolean} [showDisabled] Display topics that are disabled as well as enabled
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicList(showDisabled?: boolean, tags?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Topic>> {
            const localVarAxiosArgs = TopicApiAxiosParamCreator(configuration).topicList(showDisabled, tags, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This also lists the topic\'s impacted systems count.
         * @summary Retrieve a single topic by slug.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRead(slug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Topic> {
            const localVarAxiosArgs = TopicApiAxiosParamCreator(configuration).topicRead(slug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This shows the rule information for rules with this tag.
         * @summary Lists the available rules that have this tag.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRulesWithTag(slug: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rule>> {
            const localVarAxiosArgs = TopicApiAxiosParamCreator(configuration).topicRulesWithTag(slug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Systems are just listed by their UUID.
         * @summary List all systems affected by this rule topic.
         * @param {string} slug Rule topic slug
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSystems(slug: string, tags?: Array<string>, sort?: Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemsForRule> {
            const localVarAxiosArgs = TopicApiAxiosParamCreator(configuration).topicSystems(slug, tags, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TopicApi - factory interface
 * @export
 */
export const TopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Normally this only shows enabled topics, but if the \'show_disabled\' parameter is set to True then this will show disabled topics as well.
         * @summary List the rule topics and their impacted systems counts.
         * @param {boolean} [showDisabled] Display topics that are disabled as well as enabled
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicList(showDisabled?: boolean, tags?: Array<string>, options?: any): AxiosPromise<Array<Topic>> {
            return TopicApiFp(configuration).topicList(showDisabled, tags, options)(axios, basePath);
        },
        /**
         * This also lists the topic\'s impacted systems count.
         * @summary Retrieve a single topic by slug.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRead(slug: string, options?: any): AxiosPromise<Topic> {
            return TopicApiFp(configuration).topicRead(slug, options)(axios, basePath);
        },
        /**
         * This shows the rule information for rules with this tag.
         * @summary Lists the available rules that have this tag.
         * @param {string} slug Rule topic slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicRulesWithTag(slug: string, options?: any): AxiosPromise<Array<Rule>> {
            return TopicApiFp(configuration).topicRulesWithTag(slug, options)(axios, basePath);
        },
        /**
         * Systems are just listed by their UUID.
         * @summary List all systems affected by this rule topic.
         * @param {string} slug Rule topic slug
         * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
         * @param {Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>} [sort] Order by this field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSystems(slug: string, tags?: Array<string>, sort?: Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>, options?: any): AxiosPromise<SystemsForRule> {
            return TopicApiFp(configuration).topicSystems(slug, tags, sort, options)(axios, basePath);
        },
    };
};

/**
 * TopicApi - object-oriented interface
 * @export
 * @class TopicApi
 * @extends {BaseAPI}
 */
export class TopicApi extends BaseAPI {
    /**
     * Normally this only shows enabled topics, but if the \'show_disabled\' parameter is set to True then this will show disabled topics as well.
     * @summary List the rule topics and their impacted systems counts.
     * @param {boolean} [showDisabled] Display topics that are disabled as well as enabled
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicList(showDisabled?: boolean, tags?: Array<string>, options?: any) {
        return TopicApiFp(this.configuration).topicList(showDisabled, tags, options)(this.axios, this.basePath);
    }

    /**
     * This also lists the topic\'s impacted systems count.
     * @summary Retrieve a single topic by slug.
     * @param {string} slug Rule topic slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicRead(slug: string, options?: any) {
        return TopicApiFp(this.configuration).topicRead(slug, options)(this.axios, this.basePath);
    }

    /**
     * This shows the rule information for rules with this tag.
     * @summary Lists the available rules that have this tag.
     * @param {string} slug Rule topic slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicRulesWithTag(slug: string, options?: any) {
        return TopicApiFp(this.configuration).topicRulesWithTag(slug, options)(this.axios, this.basePath);
    }

    /**
     * Systems are just listed by their UUID.
     * @summary List all systems affected by this rule topic.
     * @param {string} slug Rule topic slug
     * @param {Array<string>} [tags] Tags have a key, and optional namespace and value, in the forms \&#39;key\&#39;, \&#39;key&#x3D;value\&#39;, \&#39;namespace/key\&#39; or \&#39;namespace/key&#x3D;value\&#39;.  Omitting a part, or supplying \&#39;*\&#39; for that part, matches anything for that part.  One or more tag searches can be supplied, separated by commas.  Strings should be URI encoded, including slashes
     * @param {Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>} [sort] Order by this field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopicApi
     */
    public topicSystems(slug: string, tags?: Array<string>, sort?: Array<'display_name' | 'last_seen' | 'stale_at' | 'system_uuid' | 'updated' | '-display_name' | '-last_seen' | '-stale_at' | '-system_uuid' | '-updated'>, options?: any) {
        return TopicApiFp(this.configuration).topicSystems(slug, tags, sort, options)(this.axios, this.basePath);
    }

}


/**
 * TotalRiskApi - axios parameter creator
 * @export
 */
export const TotalRiskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Total risk values are listed in increasing order of severity.
         * @summary List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalRiskList(options: any = {}): RequestArgs {
            const localVarPath = `/total_risk/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TotalRiskApi - functional programming interface
 * @export
 */
export const TotalRiskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Total risk values are listed in increasing order of severity.
         * @summary List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalRiskList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = TotalRiskApiAxiosParamCreator(configuration).totalRiskList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TotalRiskApi - factory interface
 * @export
 */
export const TotalRiskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Total risk values are listed in increasing order of severity.
         * @summary List all total risk values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalRiskList(options?: any): AxiosPromise<void> {
            return TotalRiskApiFp(configuration).totalRiskList(options)(axios, basePath);
        },
    };
};

/**
 * TotalRiskApi - object-oriented interface
 * @export
 * @class TotalRiskApi
 * @extends {BaseAPI}
 */
export class TotalRiskApi extends BaseAPI {
    /**
     * Total risk values are listed in increasing order of severity.
     * @summary List all total risk values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TotalRiskApi
     */
    public totalRiskList(options?: any) {
        return TotalRiskApiFp(this.configuration).totalRiskList(options)(this.axios, this.basePath);
    }

}


/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This uses a HashLogLog structure to record number of hits, and this is therefore an approximation.
         * @summary List the unique rule hits for this account over the given time range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageList(options: any = {}): RequestArgs {
            const localVarPath = `/usage/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This uses a HashLogLog structure to record number of hits, and this is therefore an approximation.
         * @summary List the unique rule hits for this account over the given time range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = UsageApiAxiosParamCreator(configuration).usageList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This uses a HashLogLog structure to record number of hits, and this is therefore an approximation.
         * @summary List the unique rule hits for this account over the given time range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageList(options?: any): AxiosPromise<void> {
            return UsageApiFp(configuration).usageList(options)(axios, basePath);
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * This uses a HashLogLog structure to record number of hits, and this is therefore an approximation.
     * @summary List the unique rule hits for this account over the given time range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public usageList(options?: any) {
        return UsageApiFp(this.configuration).usageList(options)(this.axios, this.basePath);
    }

}


/**
 * UserPreferencesApi - axios parameter creator
 * @export
 */
export const UserPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The current account settings will be updated, or one will be created, with the
         * @summary Accept the settings as input, and adjust the actual models accordingly.
         * @param {PreferencesInput} preferencesInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPreferencesCreate(preferencesInput: PreferencesInput, options: any = {}): RequestArgs {
            // verify required parameter 'preferencesInput' is not null or undefined
            if (preferencesInput === null || preferencesInput === undefined) {
                throw new RequiredError('preferencesInput','Required parameter preferencesInput was null or undefined when calling userPreferencesCreate.');
            }
            const localVarPath = `/user-preferences/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof preferencesInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(preferencesInput !== undefined ? preferencesInput : {}) : (preferencesInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This simply compiles the \'show_satellite_hosts\' account-wide setting and the weekly report \'is_subscribed\' user-specific setting into one handy view, with the description metadata necessary to use Data-Driven Forms to display it.
         * @summary Describe the settings we have in a Data-Driven Forms way.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPreferencesList(options: any = {}): RequestArgs {
            const localVarPath = `/user-preferences/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPreferencesApi - functional programming interface
 * @export
 */
export const UserPreferencesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The current account settings will be updated, or one will be created, with the
         * @summary Accept the settings as input, and adjust the actual models accordingly.
         * @param {PreferencesInput} preferencesInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPreferencesCreate(preferencesInput: PreferencesInput, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreferencesInput> {
            const localVarAxiosArgs = UserPreferencesApiAxiosParamCreator(configuration).userPreferencesCreate(preferencesInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This simply compiles the \'show_satellite_hosts\' account-wide setting and the weekly report \'is_subscribed\' user-specific setting into one handy view, with the description metadata necessary to use Data-Driven Forms to display it.
         * @summary Describe the settings we have in a Data-Driven Forms way.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPreferencesList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SettingsDDF>> {
            const localVarAxiosArgs = UserPreferencesApiAxiosParamCreator(configuration).userPreferencesList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserPreferencesApi - factory interface
 * @export
 */
export const UserPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * The current account settings will be updated, or one will be created, with the
         * @summary Accept the settings as input, and adjust the actual models accordingly.
         * @param {PreferencesInput} preferencesInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPreferencesCreate(preferencesInput: PreferencesInput, options?: any): AxiosPromise<PreferencesInput> {
            return UserPreferencesApiFp(configuration).userPreferencesCreate(preferencesInput, options)(axios, basePath);
        },
        /**
         * This simply compiles the \'show_satellite_hosts\' account-wide setting and the weekly report \'is_subscribed\' user-specific setting into one handy view, with the description metadata necessary to use Data-Driven Forms to display it.
         * @summary Describe the settings we have in a Data-Driven Forms way.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPreferencesList(options?: any): AxiosPromise<Array<SettingsDDF>> {
            return UserPreferencesApiFp(configuration).userPreferencesList(options)(axios, basePath);
        },
    };
};

/**
 * UserPreferencesApi - object-oriented interface
 * @export
 * @class UserPreferencesApi
 * @extends {BaseAPI}
 */
export class UserPreferencesApi extends BaseAPI {
    /**
     * The current account settings will be updated, or one will be created, with the
     * @summary Accept the settings as input, and adjust the actual models accordingly.
     * @param {PreferencesInput} preferencesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public userPreferencesCreate(preferencesInput: PreferencesInput, options?: any) {
        return UserPreferencesApiFp(this.configuration).userPreferencesCreate(preferencesInput, options)(this.axios, this.basePath);
    }

    /**
     * This simply compiles the \'show_satellite_hosts\' account-wide setting and the weekly report \'is_subscribed\' user-specific setting into one handy view, with the description metadata necessary to use Data-Driven Forms to display it.
     * @summary Describe the settings we have in a Data-Driven Forms way.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public userPreferencesList(options?: any) {
        return UserPreferencesApiFp(this.configuration).userPreferencesList(options)(this.axios, this.basePath);
    }

}


/**
 * WeeklyreportsubscriptionApi - axios parameter creator
 * @export
 */
export const WeeklyreportsubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If \'is_subscribed\' is true, a subscription is added if it doesn\'t already exist.  If it is false, the subscription is removed if it exists.
         * @summary Set the subscription status of the current user to the supplied `is_subscribed` value.
         * @param {WeeklyReportSubscription} weeklyReportSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionCreate(weeklyReportSubscription: WeeklyReportSubscription, options: any = {}): RequestArgs {
            // verify required parameter 'weeklyReportSubscription' is not null or undefined
            if (weeklyReportSubscription === null || weeklyReportSubscription === undefined) {
                throw new RequiredError('weeklyReportSubscription','Required parameter weeklyReportSubscription was null or undefined when calling weeklyreportsubscriptionCreate.');
            }
            const localVarPath = `/weeklyreportsubscription/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof weeklyReportSubscription !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(weeklyReportSubscription !== undefined ? weeklyReportSubscription : {}) : (weeklyReportSubscription || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This shows the presence of a weekly report subscription by the user in this account.
         * @summary Show the user\'s current subscription status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionList(options: any = {}): RequestArgs {
            const localVarPath = `/weeklyreportsubscription/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WeeklyreportsubscriptionApi - functional programming interface
 * @export
 */
export const WeeklyreportsubscriptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * If \'is_subscribed\' is true, a subscription is added if it doesn\'t already exist.  If it is false, the subscription is removed if it exists.
         * @summary Set the subscription status of the current user to the supplied `is_subscribed` value.
         * @param {WeeklyReportSubscription} weeklyReportSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionCreate(weeklyReportSubscription: WeeklyReportSubscription, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeeklyReportSubscription> {
            const localVarAxiosArgs = WeeklyreportsubscriptionApiAxiosParamCreator(configuration).weeklyreportsubscriptionCreate(weeklyReportSubscription, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This shows the presence of a weekly report subscription by the user in this account.
         * @summary Show the user\'s current subscription status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionList(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeeklyReportSubscription> {
            const localVarAxiosArgs = WeeklyreportsubscriptionApiAxiosParamCreator(configuration).weeklyreportsubscriptionList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WeeklyreportsubscriptionApi - factory interface
 * @export
 */
export const WeeklyreportsubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * If \'is_subscribed\' is true, a subscription is added if it doesn\'t already exist.  If it is false, the subscription is removed if it exists.
         * @summary Set the subscription status of the current user to the supplied `is_subscribed` value.
         * @param {WeeklyReportSubscription} weeklyReportSubscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionCreate(weeklyReportSubscription: WeeklyReportSubscription, options?: any): AxiosPromise<WeeklyReportSubscription> {
            return WeeklyreportsubscriptionApiFp(configuration).weeklyreportsubscriptionCreate(weeklyReportSubscription, options)(axios, basePath);
        },
        /**
         * This shows the presence of a weekly report subscription by the user in this account.
         * @summary Show the user\'s current subscription status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weeklyreportsubscriptionList(options?: any): AxiosPromise<WeeklyReportSubscription> {
            return WeeklyreportsubscriptionApiFp(configuration).weeklyreportsubscriptionList(options)(axios, basePath);
        },
    };
};

/**
 * WeeklyreportsubscriptionApi - object-oriented interface
 * @export
 * @class WeeklyreportsubscriptionApi
 * @extends {BaseAPI}
 */
export class WeeklyreportsubscriptionApi extends BaseAPI {
    /**
     * If \'is_subscribed\' is true, a subscription is added if it doesn\'t already exist.  If it is false, the subscription is removed if it exists.
     * @summary Set the subscription status of the current user to the supplied `is_subscribed` value.
     * @param {WeeklyReportSubscription} weeklyReportSubscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WeeklyreportsubscriptionApi
     */
    public weeklyreportsubscriptionCreate(weeklyReportSubscription: WeeklyReportSubscription, options?: any) {
        return WeeklyreportsubscriptionApiFp(this.configuration).weeklyreportsubscriptionCreate(weeklyReportSubscription, options)(this.axios, this.basePath);
    }

    /**
     * This shows the presence of a weekly report subscription by the user in this account.
     * @summary Show the user\'s current subscription status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WeeklyreportsubscriptionApi
     */
    public weeklyreportsubscriptionList(options?: any) {
        return WeeklyreportsubscriptionApiFp(this.configuration).weeklyreportsubscriptionList(options)(this.axios, this.basePath);
    }

}


