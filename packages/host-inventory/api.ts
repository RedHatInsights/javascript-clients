// tslint:disable
/**
 * Insights Host Inventory REST Interface
 * REST interface for the Insights Platform Host Inventory application.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Information about a host tag
 * @export
 * @interface ActiveTag
 */
export interface ActiveTag {
    /**
     *
     * @type {StructuredTag}
     * @memberof ActiveTag
     */
    tag: StructuredTag;
    /**
     * The number of hosts with the given tag. If the value is null this indicates that the count is unknown.
     * @type {number}
     * @memberof ActiveTag
     */
    count: number | null;
}
/**
 *
 * @export
 * @interface ActiveTags
 */
export interface ActiveTags {
    /**
     * Total number of items
     * @type {number}
     * @memberof ActiveTags
     */
    total: number;
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof ActiveTags
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof ActiveTags
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof ActiveTags
     */
    per_page: number;
    /**
     *
     * @type {Array<ActiveTag>}
     * @memberof ActiveTags
     */
    results: Array<ActiveTag>;
}
/**
 *
 * @export
 * @interface CanonicalFactsIn
 */
export interface CanonicalFactsIn {
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsIn
     */
    insights_id: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsIn
     */
    rhel_machine_id: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsIn
     */
    subscription_manager_id: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsIn
     */
    satellite_id: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsIn
     */
    bios_uuid: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CanonicalFactsIn
     */
    ip_addresses: Array<string>;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsIn
     */
    Fqdn?: string | null;
    /**
     *
     * @type {Array<string>}
     * @memberof CanonicalFactsIn
     */
    mac_addresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsIn
     */
    external_id: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsIn
     */
    fqdn: string;
}
/**
 *
 * @export
 * @interface CanonicalFactsInAllOf
 */
export interface CanonicalFactsInAllOf {
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    insights_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    rhel_machine_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    subscription_manager_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    satellite_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    bios_uuid?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CanonicalFactsInAllOf
     */
    ip_addresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    fqdn?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CanonicalFactsInAllOf
     */
    mac_addresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    external_id?: string;
}
/**
 *
 * @export
 * @interface CanonicalFactsOut
 */
export interface CanonicalFactsOut {
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    insights_id?: string | null;
    /**
     * A Machine ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    rhel_machine_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CanonicalFactsOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    Fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CanonicalFactsOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. AWS EC2, Azure, OpenStack, etc. This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    external_id?: string | null;
}
/**
 * Data required to create a check-in record for a host.
 * @export
 * @interface CreateCheckIn
 */
export interface CreateCheckIn {
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    insights_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    rhel_machine_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    subscription_manager_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    satellite_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    bios_uuid: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateCheckIn
     */
    ip_addresses: Array<string>;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateCheckIn
     */
    Fqdn?: string | null;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateCheckIn
     */
    mac_addresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    external_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    fqdn: string;
    /**
     * How long from now to expect another check-in (in minutes).
     * @type {number}
     * @memberof CreateCheckIn
     */
    checkin_frequency?: number;
}
/**
 *
 * @export
 * @interface CreateCheckInAllOf
 */
export interface CreateCheckInAllOf {
    /**
     * How long from now to expect another check-in (in minutes).
     * @type {number}
     * @memberof CreateCheckInAllOf
     */
    checkin_frequency?: number;
}
/**
 * Data of a single host belonging to an account. Represents the hosts without its Inventory metadata.
 * @export
 * @interface CreateHostOut
 */
export interface CreateHostOut {
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    insights_id?: string | null;
    /**
     * A Machine ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    rhel_machine_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    Fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. AWS EC2, Azure, OpenStack, etc. This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    external_id?: string | null;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof CreateHostOut
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof CreateHostOut
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof CreateHostOut
     */
    account: string;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof CreateHostOut
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof CreateHostOut
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof CreateHostOut
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof CreateHostOut
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof CreateHostOut
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof CreateHostOut
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof CreateHostOut
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof CreateHostOut
     */
    reporter?: string | null;
}
/**
 *
 * @export
 * @interface CreateHostOutAllOf
 */
export interface CreateHostOutAllOf {
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    account: string;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof CreateHostOutAllOf
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    reporter?: string | null;
}
/**
 * Representation of one mounted device
 * @export
 * @interface DiskDevice
 */
export interface DiskDevice {
    /**
     *
     * @type {string}
     * @memberof DiskDevice
     */
    device?: string;
    /**
     * User-defined mount label
     * @type {string}
     * @memberof DiskDevice
     */
    label?: string;
    /**
     * Mount options for nested object
     * @type {object}
     * @memberof DiskDevice
     */
    options?: object;
    /**
     * The mount point
     * @type {string}
     * @memberof DiskDevice
     */
    mount_point?: string;
    /**
     * The mount type
     * @type {string}
     * @memberof DiskDevice
     */
    type?: string;
}
/**
 * Representation of one DNF module
 * @export
 * @interface DnfModule
 */
export interface DnfModule {
    /**
     *
     * @type {string}
     * @memberof DnfModule
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof DnfModule
     */
    stream?: string;
}
/**
 * A set of string facts belonging to a single namespace.
 * @export
 * @interface FactSet
 */
export interface FactSet {
    /**
     * A namespace the facts belong to.
     * @type {string}
     * @memberof FactSet
     */
    namespace: string;
    /**
     * The facts themselves.
     * @type {object}
     * @memberof FactSet
     */
    facts: object;
}
/**
 * A database entry representing a single host with its Inventory metadata.
 * @export
 * @interface HostOut
 */
export interface HostOut {
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    insights_id?: string | null;
    /**
     * A Machine ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    rhel_machine_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof HostOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    Fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof HostOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. AWS EC2, Azure, OpenStack, etc. This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    external_id?: string | null;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof HostOut
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof HostOut
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof HostOut
     */
    account: string;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof HostOut
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof HostOut
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof HostOut
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOut
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof HostOut
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof HostOut
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof HostOut
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof HostOut
     */
    reporter?: string | null;
}
/**
 *
 * @export
 * @interface HostOutAllOf
 */
export interface HostOutAllOf {
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOutAllOf
     */
    facts?: Array<FactSet>;
}
/**
 * A paginated host search query result with host entries and their Inventory metadata.
 * @export
 * @interface HostQueryOutput
 */
export interface HostQueryOutput {
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof HostQueryOutput
     */
    count: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof HostQueryOutput
     */
    page: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof HostQueryOutput
     */
    per_page: number;
    /**
     * A total count of the found entries.
     * @type {number}
     * @memberof HostQueryOutput
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostOut>}
     * @memberof HostQueryOutput
     */
    results: Array<HostOut>;
}
/**
 * Individual host record that contains only the host id and system profile
 * @export
 * @interface HostSystemProfileOut
 */
export interface HostSystemProfileOut {
    /**
     *
     * @type {string}
     * @memberof HostSystemProfileOut
     */
    id?: string;
    /**
     *
     * @type {SystemProfile}
     * @memberof HostSystemProfileOut
     */
    system_profile?: SystemProfile;
}
/**
 * Representation of one installed product
 * @export
 * @interface InstalledProduct
 */
export interface InstalledProduct {
    /**
     *
     * @type {string}
     * @memberof InstalledProduct
     */
    name?: string;
    /**
     * The product ID
     * @type {string}
     * @memberof InstalledProduct
     */
    id?: string;
    /**
     * Subscription status for product
     * @type {string}
     * @memberof InstalledProduct
     */
    status?: string;
}
/**
 * Representation of one network interface
 * @export
 * @interface NetworkInterface
 */
export interface NetworkInterface {
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv4_addresses?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv6_addresses?: Array<string>;
    /**
     * MTU (Maximum transmission unit)
     * @type {number}
     * @memberof NetworkInterface
     */
    mtu?: number;
    /**
     * MAC address (with or without colons)
     * @type {string}
     * @memberof NetworkInterface
     */
    mac_address?: string;
    /**
     * Name of interface
     * @type {string}
     * @memberof NetworkInterface
     */
    name?: string;
    /**
     * Interface state (UP, DOWN, UNKNOWN)
     * @type {string}
     * @memberof NetworkInterface
     */
    state?: string;
    /**
     * Interface type (ether, loopback)
     * @type {string}
     * @memberof NetworkInterface
     */
    type?: string;
}
/**
 * Data of a single host to be updated.
 * @export
 * @interface PatchHostIn
 */
export interface PatchHostIn {
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof PatchHostIn
     */
    ansible_host?: string;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof PatchHostIn
     */
    display_name?: string;
}
/**
 *
 * @export
 * @interface StructuredTag
 */
export interface StructuredTag {
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    namespace?: string | null;
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    value?: string | null;
}
/**
 * Representation of the system profile fields
 * @export
 * @interface SystemProfile
 */
export interface SystemProfile {
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    number_of_cpus?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    number_of_sockets?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    cores_per_socket?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    system_memory_bytes?: number;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    infrastructure_type?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    infrastructure_vendor?: string;
    /**
     *
     * @type {Array<NetworkInterface>}
     * @memberof SystemProfile
     */
    network_interfaces?: Array<NetworkInterface>;
    /**
     *
     * @type {Array<DiskDevice>}
     * @memberof SystemProfile
     */
    disk_devices?: Array<DiskDevice>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_vendor?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_release_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    cpu_flags?: Array<string>;
    /**
     *
     * @type {SystemProfileOperatingSystem}
     * @memberof SystemProfile
     */
    operating_system?: SystemProfileOperatingSystem;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    os_release?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    os_kernel_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    arch?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    kernel_modules?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    last_boot_time?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    running_processes?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    subscription_status?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    subscription_auto_attach?: string;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfile
     */
    katello_agent_running?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfile
     */
    satellite_managed?: boolean;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    cloud_provider?: string;
    /**
     *
     * @type {Array<YumRepo>}
     * @memberof SystemProfile
     */
    yum_repos?: Array<YumRepo>;
    /**
     *
     * @type {Array<DnfModule>}
     * @memberof SystemProfile
     */
    dnf_modules?: Array<DnfModule>;
    /**
     *
     * @type {Array<InstalledProduct>}
     * @memberof SystemProfile
     */
    installed_products?: Array<InstalledProduct>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    insights_client_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    insights_egg_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    captured_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_packages?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_services?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    enabled_services?: Array<string>;
    /**
     * Indicates if SAP is installed on the system
     * @type {boolean}
     * @memberof SystemProfile
     */
    sap_system?: boolean;
    /**
     * List of SAP SIDs
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    sap_sids?: Array<string>;
    /**
     * The instance number of the SAP HANA system
     * @type {string}
     * @memberof SystemProfile
     */
    sap_instance_number?: string;
    /**
     * The version of the SAP HANA lifecycle management program
     * @type {string}
     * @memberof SystemProfile
     */
    sap_version?: string;
    /**
     * Current profile resulting from command tuned-adm active
     * @type {string}
     * @memberof SystemProfile
     */
    tuned_profile?: string;
    /**
     * The current SELinux mode, either enforcing, permissive, or disabled
     * @type {string}
     * @memberof SystemProfile
     */
    selinux_current_mode?: SystemProfileSelinuxCurrentModeEnum;
    /**
     * The SELinux mode provided in the config file
     * @type {string}
     * @memberof SystemProfile
     */
    selinux_config_file?: SystemProfileSelinuxConfigFileEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSelinuxCurrentModeEnum {
    Enforcing = 'enforcing',
    Permissive = 'permissive',
    Disabled = 'disabled'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSelinuxConfigFileEnum {
    Enforcing = 'enforcing',
    Permissive = 'permissive',
    Disabled = 'disabled'
}

/**
 * Structure of the output of the host system profile query
 * @export
 * @interface SystemProfileByHostOut
 */
export interface SystemProfileByHostOut {
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    count: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    page: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    per_page: number;
    /**
     * A total count of the found entries.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostSystemProfileOut>}
     * @memberof SystemProfileByHostOut
     */
    results: Array<HostSystemProfileOut>;
}
/**
 *
 * @export
 * @interface SystemProfileOperatingSystem
 */
export interface SystemProfileOperatingSystem {
    /**
     * Major release of OS (aka the x version)
     * @type {number}
     * @memberof SystemProfileOperatingSystem
     */
    major?: number;
    /**
     * Minor release of OS (aka the y version)
     * @type {number}
     * @memberof SystemProfileOperatingSystem
     */
    minor?: number;
    /**
     * Name of the distro/os
     * @type {string}
     * @memberof SystemProfileOperatingSystem
     */
    name?: SystemProfileOperatingSystemNameEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileOperatingSystemNameEnum {
    RHEL = 'RHEL'
}

/**
 *
 * @export
 * @interface SystemProfileSapSystemOut
 */
export interface SystemProfileSapSystemOut {
    /**
     * Total number of items
     * @type {number}
     * @memberof SystemProfileSapSystemOut
     */
    total?: number;
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof SystemProfileSapSystemOut
     */
    count?: number;
    /**
     * The list of sap_system values on the account
     * @type {Array<object>}
     * @memberof SystemProfileSapSystemOut
     */
    results?: Array<object>;
}
/**
 *
 * @export
 * @interface TagCountOut
 */
export interface TagCountOut {
    /**
     * Total number of items in the \"data\" list.
     * @type {number}
     * @memberof TagCountOut
     */
    total?: number;
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof TagCountOut
     */
    count?: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof TagCountOut
     */
    page?: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof TagCountOut
     */
    per_page?: number;
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: number; }}
     * @memberof TagCountOut
     */
    results?: { [key: string]: number; };
}
/**
 *
 * @export
 * @interface TagsOut
 */
export interface TagsOut {
    /**
     * Total number of items in the \"data\" list.
     * @type {number}
     * @memberof TagsOut
     */
    total?: number;
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof TagsOut
     */
    count?: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof TagsOut
     */
    page?: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof TagsOut
     */
    per_page?: number;
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: Array<StructuredTag>; }}
     * @memberof TagsOut
     */
    results?: { [key: string]: Array<StructuredTag>; };
}
/**
 * Representation of one yum repository
 * @export
 * @interface YumRepo
 */
export interface YumRepo {
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    gpgcheck?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    base_url?: string;
}

/**
 * HostsApi - axios parameter creator
 * @export
 */
export const HostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById: async (hostIdList: Array<string>, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostDeleteById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById: async (hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host\&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList: async (displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: 'insights', filter?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (registeredWith !== undefined) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostSystemProfileById.');
            }
            const localVarPath = `/hosts/{host_id_list}/system_profile`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostTagCount.');
            }
            const localVarPath = `/hosts/{host_id_list}/tags/count`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostTags.');
            }
            const localVarPath = `/hosts/{host_id_list}/tags`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostHostCheckin: async (createCheckIn: CreateCheckIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCheckIn' is not null or undefined
            if (createCheckIn === null || createCheckIn === undefined) {
                throw new RequiredError('createCheckIn','Required parameter createCheckIn was null or undefined when calling apiHostHostCheckin.');
            }
            const localVarPath = `/hosts/checkin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCheckIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCheckIn !== undefined ? createCheckIn : {}) : (createCheckIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts: async (hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostMergeFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a host <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById: async (hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostPatchById.');
            }
            // verify required parameter 'patchHostIn' is not null or undefined
            if (patchHostIn === null || patchHostIn === undefined) {
                throw new RequiredError('patchHostIn','Required parameter patchHostIn was null or undefined when calling apiHostPatchById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchHostIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchHostIn !== undefined ? patchHostIn : {}) : (patchHostIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts: async (hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostReplaceFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostsApi - functional programming interface
 * @export
 */
export const HostsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostDeleteById(hostIdList, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host\&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: 'insights', filter?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileByHostOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the number of tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagCountOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateHostOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostHostCheckin(createCheckIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a host <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HostsApi - factory interface
 * @export
 */
export const HostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostDeleteById(hostIdList, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<HostQueryOutput> {
            return HostsApiFp(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host\&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: 'insights', filter?: object, options?: any): AxiosPromise<HostQueryOutput> {
            return HostsApiFp(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', branchId?: string, options?: any): AxiosPromise<SystemProfileByHostOut> {
            return HostsApiFp(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<TagCountOut> {
            return HostsApiFp(configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', search?: string, options?: any): AxiosPromise<TagsOut> {
            return HostsApiFp(configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any): AxiosPromise<CreateHostOut> {
            return HostsApiFp(configuration).apiHostHostCheckin(createCheckIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a host <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HostsApi - object-oriented interface
 * @export
 * @class HostsApi
 * @extends {BaseAPI}
 */
export class HostsApi extends BaseAPI {
    /**
     * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
     * @summary Delete hosts by IDs
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteById(hostIdList, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
     * @summary Find hosts by their IDs
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
     * @summary Read the entire list of hosts
     * @param {string} [displayName] A part of a searched host’s display name.
     * @param {string} [fqdn] Filter by a host\&#39;s FQDN
     * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
     * @param {string} [insightsId] Search for a host by insights_id
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
     * @param {object} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: 'insights', filter?: object, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
     * @summary Return one or more hosts system profile
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of tags on a host <br /><br /> Required permissions: inventory:hosts:read
     * @summary Get the number of tags on a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
     * @summary Get the tags on a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', search?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
     * @summary Update staleness timestamps for a host matching the provided facts
     * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any) {
        return HostsApiFp(this.configuration).apiHostHostCheckin(createCheckIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
     * @summary Merge facts under a namespace
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} namespace A namespace of the merged facts.
     * @param {object} body A dictionary with the new facts to merge with the original ones.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a host <br /><br /> Required permissions: inventory:hosts:write
     * @summary Update a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
     * @summary Replace facts under a namespace
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} namespace A namespace of the merged facts.
     * @param {object} body A dictionary with the new facts to replace the original ones.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SapSystemApi - axios parameter creator
 * @export
 */
export const SapSystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get sap system values
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSids: async (search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: 'insights', filter?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system_profile/sap_sids`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (registeredWith !== undefined) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get sap system values
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSystem: async (tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: 'insights', filter?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system_profile/sap_system`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (registeredWith !== undefined) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SapSystemApi - functional programming interface
 * @export
 */
export const SapSystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get sap system values
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: 'insights', filter?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileSapSystemOut>> {
            const localVarAxiosArgs = await SapSystemApiAxiosParamCreator(configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get sap system values
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: 'insights', filter?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileSapSystemOut>> {
            const localVarAxiosArgs = await SapSystemApiAxiosParamCreator(configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SapSystemApi - factory interface
 * @export
 */
export const SapSystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get sap system values
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: 'insights', filter?: object, options?: any): AxiosPromise<SystemProfileSapSystemOut> {
            return SapSystemApiFp(configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get sap system values
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: 'insights', filter?: object, options?: any): AxiosPromise<SystemProfileSapSystemOut> {
            return SapSystemApiFp(configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SapSystemApi - object-oriented interface
 * @export
 * @class SapSystemApi
 * @extends {BaseAPI}
 */
export class SapSystemApi extends BaseAPI {
    /**
     * Required permissions: inventory:hosts:read
     * @summary get sap system values
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
     * @param {object} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SapSystemApi
     */
    public apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: 'insights', filter?: object, options?: any) {
        return SapSystemApiFp(this.configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions: inventory:hosts:read
     * @summary get sap system values
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
     * @param {object} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SapSystemApi
     */
    public apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: 'insights', filter?: object, options?: any) {
        return SapSystemApiFp(this.configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags: async (tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, registeredWith?: 'insights', filter?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (registeredWith !== undefined) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, registeredWith?: 'insights', filter?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveTags>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {object} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, registeredWith?: 'insights', filter?: object, options?: any): AxiosPromise<ActiveTags> {
            return TagsApiFp(configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Required permissions: inventory:hosts:read
     * @summary Get the active host tags for a given account
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {'tag' | 'count'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
     * @param {object} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, registeredWith?: 'insights', filter?: object, options?: any) {
        return TagsApiFp(this.configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

}


