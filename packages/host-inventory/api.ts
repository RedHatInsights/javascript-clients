// tslint:disable
/**
 * Insights Host Inventory REST Interface
 * REST interface for the Insights Platform Host Inventory application.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Information about a host tag
 * @export
 * @interface ActiveTag
 */
export interface ActiveTag {
    /**
     *
     * @type {StructuredTag}
     * @memberof ActiveTag
     */
    tag: StructuredTag;
    /**
     * The number of hosts with the given tag. If the value is null this indicates that the count is unknown.
     * @type {number}
     * @memberof ActiveTag
     */
    count: number | null;
}
/**
 *
 * @export
 * @interface ActiveTags
 */
export interface ActiveTags {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof ActiveTags
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof ActiveTags
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof ActiveTags
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof ActiveTags
     */
    total: number;
    /**
     *
     * @type {Array<ActiveTag>}
     * @memberof ActiveTags
     */
    results: Array<ActiveTag>;
}
/**
 *
 * @export
 * @interface ActiveTagsAllOf
 */
export interface ActiveTagsAllOf {
    /**
     *
     * @type {Array<ActiveTag>}
     * @memberof ActiveTagsAllOf
     */
    results: Array<ActiveTag>;
}
/**
 *
 * @export
 * @interface CanonicalFactsIn
 */
export interface CanonicalFactsIn extends CanonicalFactsInAllOf {
}
/**
 *
 * @export
 * @interface CanonicalFactsInAllOf
 */
export interface CanonicalFactsInAllOf {
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    insights_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    subscription_manager_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    satellite_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    bios_uuid?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CanonicalFactsInAllOf
     */
    ip_addresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    fqdn?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CanonicalFactsInAllOf
     */
    mac_addresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    provider_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    provider_type?: string;
}
/**
 *
 * @export
 * @interface CanonicalFactsOut
 */
export interface CanonicalFactsOut {
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    insights_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CanonicalFactsOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CanonicalFactsOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM etc. This field is one of the canonical facts and does not work without provider_type.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    provider_id?: string | null;
    /**
     * Type of external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM, etc. This field is one of the canonical facts and does not workout provider_id.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    provider_type?: string | null;
}
/**
 * Data required to create a check-in record for a host.
 * @export
 * @interface CreateCheckIn
 */
export interface CreateCheckIn {
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    insights_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    subscription_manager_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    satellite_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    bios_uuid: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateCheckIn
     */
    ip_addresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    fqdn: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateCheckIn
     */
    mac_addresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    provider_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    provider_type: string;
    /**
     * How long from now to expect another check-in (in minutes).
     * @type {number}
     * @memberof CreateCheckIn
     */
    checkin_frequency?: number;
}
/**
 *
 * @export
 * @interface CreateCheckInAllOf
 */
export interface CreateCheckInAllOf {
    /**
     * How long from now to expect another check-in (in minutes).
     * @type {number}
     * @memberof CreateCheckInAllOf
     */
    checkin_frequency?: number;
}
/**
 * Data of a single host belonging to an account. Represents the hosts without its Inventory metadata.
 * @export
 * @interface CreateHostOut
 */
export interface CreateHostOut {
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    insights_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM etc. This field is one of the canonical facts and does not work without provider_type.
     * @type {string}
     * @memberof CreateHostOut
     */
    provider_id?: string | null;
    /**
     * Type of external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM, etc. This field is one of the canonical facts and does not workout provider_id.
     * @type {string}
     * @memberof CreateHostOut
     */
    provider_type?: string | null;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof CreateHostOut
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof CreateHostOut
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof CreateHostOut
     */
    account: string;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof CreateHostOut
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof CreateHostOut
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof CreateHostOut
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof CreateHostOut
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof CreateHostOut
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof CreateHostOut
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof CreateHostOut
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof CreateHostOut
     */
    reporter?: string | null;
    /**
     * Reporting source of the last checkin status, stale_timestamp, and last_check_in.
     * @type {{ [key: string]: object; }}
     * @memberof CreateHostOut
     */
    per_reporter_staleness?: { [key: string]: object; };
}
/**
 *
 * @export
 * @interface CreateHostOutAllOf
 */
export interface CreateHostOutAllOf {
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    account: string;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof CreateHostOutAllOf
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof CreateHostOutAllOf
     */
    reporter?: string | null;
    /**
     * Reporting source of the last checkin status, stale_timestamp, and last_check_in.
     * @type {{ [key: string]: object; }}
     * @memberof CreateHostOutAllOf
     */
    per_reporter_staleness?: { [key: string]: object; };
}
/**
 * Representation of one mounted device
 * @export
 * @interface DiskDevice
 */
export interface DiskDevice {
    /**
     *
     * @type {string}
     * @memberof DiskDevice
     */
    device?: string;
    /**
     * User-defined mount label
     * @type {string}
     * @memberof DiskDevice
     */
    label?: string;
    /**
     * An arbitrary object that does not allow empty string keys.
     * @type {{ [key: string]: object; }}
     * @memberof DiskDevice
     */
    options?: { [key: string]: object; };
    /**
     * The mount point
     * @type {string}
     * @memberof DiskDevice
     */
    mount_point?: string;
    /**
     * The mount type
     * @type {string}
     * @memberof DiskDevice
     */
    type?: string;
}
/**
 * Representation of one DNF module
 * @export
 * @interface DnfModule
 */
export interface DnfModule {
    /**
     *
     * @type {string}
     * @memberof DnfModule
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof DnfModule
     */
    stream?: string;
}
/**
 * A set of string facts belonging to a single namespace.
 * @export
 * @interface FactSet
 */
export interface FactSet {
    /**
     * A namespace the facts belong to.
     * @type {string}
     * @memberof FactSet
     */
    namespace: string;
    /**
     * The facts themselves.
     * @type {object}
     * @memberof FactSet
     */
    facts: object;
}
/**
 * A database entry representing a single host with its Inventory metadata.
 * @export
 * @interface HostOut
 */
export interface HostOut {
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    insights_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof HostOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof HostOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM etc. This field is one of the canonical facts and does not work without provider_type.
     * @type {string}
     * @memberof HostOut
     */
    provider_id?: string | null;
    /**
     * Type of external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM, etc. This field is one of the canonical facts and does not workout provider_id.
     * @type {string}
     * @memberof HostOut
     */
    provider_type?: string | null;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof HostOut
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof HostOut
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof HostOut
     */
    account: string;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof HostOut
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof HostOut
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof HostOut
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOut
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof HostOut
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof HostOut
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof HostOut
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof HostOut
     */
    reporter?: string | null;
    /**
     * Reporting source of the last checkin status, stale_timestamp, and last_check_in.
     * @type {{ [key: string]: object; }}
     * @memberof HostOut
     */
    per_reporter_staleness?: { [key: string]: object; };
}
/**
 *
 * @export
 * @interface HostOutAllOf
 */
export interface HostOutAllOf {
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOutAllOf
     */
    facts?: Array<FactSet>;
}
/**
 * A paginated host search query result with host entries and their Inventory metadata.
 * @export
 * @interface HostQueryOutput
 */
export interface HostQueryOutput {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof HostQueryOutput
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof HostQueryOutput
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof HostQueryOutput
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof HostQueryOutput
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostOut>}
     * @memberof HostQueryOutput
     */
    results: Array<HostOut>;
}
/**
 *
 * @export
 * @interface HostQueryOutputAllOf
 */
export interface HostQueryOutputAllOf {
    /**
     * Actual host search query result entries.
     * @type {Array<HostOut>}
     * @memberof HostQueryOutputAllOf
     */
    results: Array<HostOut>;
}
/**
 * Individual host record that contains only the host id and system profile
 * @export
 * @interface HostSystemProfileOut
 */
export interface HostSystemProfileOut {
    /**
     *
     * @type {string}
     * @memberof HostSystemProfileOut
     */
    id?: string;
    /**
     *
     * @type {SystemProfile}
     * @memberof HostSystemProfileOut
     */
    system_profile?: SystemProfile;
}
/**
 * Representation of one installed product
 * @export
 * @interface InstalledProduct
 */
export interface InstalledProduct {
    /**
     *
     * @type {string}
     * @memberof InstalledProduct
     */
    name?: string;
    /**
     * The product ID
     * @type {string}
     * @memberof InstalledProduct
     */
    id?: string;
    /**
     * Subscription status for product
     * @type {string}
     * @memberof InstalledProduct
     */
    status?: string;
}
/**
 * Representation of one network interface
 * @export
 * @interface NetworkInterface
 */
export interface NetworkInterface {
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv4_addresses?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv6_addresses?: Array<string>;
    /**
     * MTU (Maximum transmission unit)
     * @type {number}
     * @memberof NetworkInterface
     */
    mtu?: number;
    /**
     * MAC address (with or without colons)
     * @type {string}
     * @memberof NetworkInterface
     */
    mac_address?: string;
    /**
     * Name of interface
     * @type {string}
     * @memberof NetworkInterface
     */
    name?: string;
    /**
     * Interface state (UP, DOWN, UNKNOWN)
     * @type {string}
     * @memberof NetworkInterface
     */
    state?: string;
    /**
     * Interface type (ether, loopback)
     * @type {string}
     * @memberof NetworkInterface
     */
    type?: string;
}
/**
 *
 * @export
 * @interface PaginationOut
 */
export interface PaginationOut {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof PaginationOut
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof PaginationOut
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof PaginationOut
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof PaginationOut
     */
    total: number;
}
/**
 * Data of a single host to be updated.
 * @export
 * @interface PatchHostIn
 */
export interface PatchHostIn {
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof PatchHostIn
     */
    ansible_host?: string;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof PatchHostIn
     */
    display_name?: string;
}
/**
 *
 * @export
 * @interface PerReporterStaleness
 */
export interface PerReporterStaleness {
    /**
     *
     * @type {string}
     * @memberof PerReporterStaleness
     */
    last_check_in?: string;
    /**
     *
     * @type {string}
     * @memberof PerReporterStaleness
     */
    stale_timestamp?: string;
    /**
     *
     * @type {boolean}
     * @memberof PerReporterStaleness
     */
    check_in_succeeded?: boolean;
}
/**
 * Limited deployment information from systems managed by rpm-ostree as reported by rpm-ostree status --json
 * @export
 * @interface RPMOSTreeDeployment
 */
export interface RPMOSTreeDeployment {
    /**
     * ID of the deployment
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    id: string;
    /**
     * The checksum / commit of the deployment
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    checksum: string;
    /**
     * The origin repo from which the commit was installed
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    origin: string;
    /**
     * The operating system name
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    osname: string;
    /**
     * The version of the deployment
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    version?: string;
    /**
     * Whether the deployment is currently booted
     * @type {boolean}
     * @memberof RPMOSTreeDeployment
     */
    booted: boolean;
    /**
     * Whether the deployment is currently pinned
     * @type {boolean}
     * @memberof RPMOSTreeDeployment
     */
    pinned: boolean;
}
/**
 *
 * @export
 * @interface StructuredTag
 */
export interface StructuredTag {
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    namespace?: string | null;
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    value?: string | null;
}
/**
 * Representation of the system profile fields
 * @export
 * @interface SystemProfile
 */
export interface SystemProfile {
    /**
     * A UUID associated with the host\'s RHSM certificate
     * @type {string}
     * @memberof SystemProfile
     */
    owner_id?: string;
    /**
     * A UUID associated with a cloud_connector
     * @type {string}
     * @memberof SystemProfile
     */
    rhc_client_id?: string;
    /**
     * A UUID associated with the config manager state
     * @type {string}
     * @memberof SystemProfile
     */
    rhc_config_state?: string;
    /**
     * The cpu model name
     * @type {string}
     * @memberof SystemProfile
     */
    cpu_model?: string;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    number_of_cpus?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    number_of_sockets?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    cores_per_socket?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    system_memory_bytes?: number;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    infrastructure_type?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    infrastructure_vendor?: string;
    /**
     *
     * @type {Array<NetworkInterface>}
     * @memberof SystemProfile
     */
    network_interfaces?: Array<NetworkInterface>;
    /**
     *
     * @type {Array<DiskDevice>}
     * @memberof SystemProfile
     */
    disk_devices?: Array<DiskDevice>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_vendor?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_release_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    cpu_flags?: Array<string>;
    /**
     *
     * @type {SystemProfileOperatingSystem}
     * @memberof SystemProfile
     */
    operating_system?: SystemProfileOperatingSystem;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    os_release?: string;
    /**
     * The kernel version represented with a three, optionally four, number scheme.
     * @type {string}
     * @memberof SystemProfile
     */
    os_kernel_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    arch?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    kernel_modules?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    last_boot_time?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    running_processes?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    subscription_status?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    subscription_auto_attach?: string;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfile
     */
    katello_agent_running?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfile
     */
    satellite_managed?: boolean;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    cloud_provider?: string;
    /**
     *
     * @type {Array<YumRepo>}
     * @memberof SystemProfile
     */
    yum_repos?: Array<YumRepo>;
    /**
     *
     * @type {Array<DnfModule>}
     * @memberof SystemProfile
     */
    dnf_modules?: Array<DnfModule>;
    /**
     *
     * @type {Array<InstalledProduct>}
     * @memberof SystemProfile
     */
    installed_products?: Array<InstalledProduct>;
    /**
     * The version number of insights client. supports wildcards
     * @type {string}
     * @memberof SystemProfile
     */
    insights_client_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    insights_egg_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    captured_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_packages?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_packages_delta?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    gpg_pubkeys?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_services?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    enabled_services?: Array<string>;
    /**
     * Indicates if SAP is installed on the system
     * @type {boolean}
     * @memberof SystemProfile
     */
    sap_system?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    sap_sids?: Array<string>;
    /**
     * The instance number of the SAP HANA system (a two-digit number between 00 and 99)
     * @type {string}
     * @memberof SystemProfile
     */
    sap_instance_number?: string;
    /**
     * The version of the SAP HANA lifecycle management program
     * @type {string}
     * @memberof SystemProfile
     */
    sap_version?: string;
    /**
     * Current profile resulting from command tuned-adm active
     * @type {string}
     * @memberof SystemProfile
     */
    tuned_profile?: string;
    /**
     * The current SELinux mode, either enforcing, permissive, or disabled
     * @type {string}
     * @memberof SystemProfile
     */
    selinux_current_mode?: SystemProfileSelinuxCurrentModeEnum;
    /**
     * The SELinux mode provided in the config file
     * @type {string}
     * @memberof SystemProfile
     */
    selinux_config_file?: string;
    /**
     * Indicates whether the host is part of a marketplace install from AWS, Azure, etc.
     * @type {boolean}
     * @memberof SystemProfile
     */
    is_marketplace?: boolean;
    /**
     * Indicates the type of host.
     * @type {string}
     * @memberof SystemProfile
     */
    host_type?: SystemProfileHostTypeEnum;
    /**
     * Indicates the greenboot status of an edge device.
     * @type {string}
     * @memberof SystemProfile
     */
    greenboot_status?: SystemProfileGreenbootStatusEnum;
    /**
     * Indicates whether greenboot detected a rolled back update on an edge device.
     * @type {boolean}
     * @memberof SystemProfile
     */
    greenboot_fallback_detected?: boolean;
    /**
     * The list of deployments on the system as reported by rpm-ostree status --json
     * @type {Array<RPMOSTreeDeployment>}
     * @memberof SystemProfile
     */
    rpm_ostree_deployments?: Array<RPMOSTreeDeployment>;
    /**
     *
     * @type {SystemProfileRhsm}
     * @memberof SystemProfile
     */
    rhsm?: SystemProfileRhsm;
    /**
     *
     * @type {SystemProfileSystemPurpose}
     * @memberof SystemProfile
     */
    system_purpose?: SystemProfileSystemPurpose;
    /**
     *
     * @type {SystemProfileAnsible}
     * @memberof SystemProfile
     */
    ansible?: SystemProfileAnsible;
    /**
     *
     * @type {SystemProfileMssql}
     * @memberof SystemProfile
     */
    mssql?: SystemProfileMssql;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSelinuxCurrentModeEnum {
    Enforcing = 'enforcing',
    Permissive = 'permissive',
    Disabled = 'disabled'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileHostTypeEnum {
    Edge = 'edge'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileGreenbootStatusEnum {
    Red = 'red',
    Green = 'green'
}

/**
 * Object containing data specific to Ansible Automation Platform
 * @export
 * @interface SystemProfileAnsible
 */
export interface SystemProfileAnsible {
    /**
     * The ansible-tower or automation-controller version on the host
     * @type {string}
     * @memberof SystemProfileAnsible
     */
    controller_version?: string;
    /**
     * The automation-hub version on the host
     * @type {string}
     * @memberof SystemProfileAnsible
     */
    hub_version?: string;
    /**
     * The catalog-worker version on the host
     * @type {string}
     * @memberof SystemProfileAnsible
     */
    catalog_worker_version?: string;
    /**
     * The SSO version on the host
     * @type {string}
     * @memberof SystemProfileAnsible
     */
    sso_version?: string;
}
/**
 * Structure of the output of the host system profile query
 * @export
 * @interface SystemProfileByHostOut
 */
export interface SystemProfileByHostOut {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostSystemProfileOut>}
     * @memberof SystemProfileByHostOut
     */
    results: Array<HostSystemProfileOut>;
}
/**
 *
 * @export
 * @interface SystemProfileByHostOutAllOf
 */
export interface SystemProfileByHostOutAllOf {
    /**
     * Actual host search query result entries.
     * @type {Array<HostSystemProfileOut>}
     * @memberof SystemProfileByHostOutAllOf
     */
    results: Array<HostSystemProfileOut>;
}
/**
 * Representation of one mounted device
 * @export
 * @interface SystemProfileDiskDevice
 */
export interface SystemProfileDiskDevice {
    /**
     *
     * @type {string}
     * @memberof SystemProfileDiskDevice
     */
    device?: string;
    /**
     * User-defined mount label
     * @type {string}
     * @memberof SystemProfileDiskDevice
     */
    label?: string;
    /**
     * An arbitrary object that does not allow empty string keys.
     * @type {{ [key: string]: object; }}
     * @memberof SystemProfileDiskDevice
     */
    options?: { [key: string]: object; };
    /**
     * The mount point
     * @type {string}
     * @memberof SystemProfileDiskDevice
     */
    mount_point?: string;
    /**
     * The mount type
     * @type {string}
     * @memberof SystemProfileDiskDevice
     */
    type?: string;
}
/**
 * Representation of one DNF module
 * @export
 * @interface SystemProfileDnfModule
 */
export interface SystemProfileDnfModule {
    /**
     *
     * @type {string}
     * @memberof SystemProfileDnfModule
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileDnfModule
     */
    stream?: string;
}
/**
 * Representation of one installed product
 * @export
 * @interface SystemProfileInstalledProduct
 */
export interface SystemProfileInstalledProduct {
    /**
     *
     * @type {string}
     * @memberof SystemProfileInstalledProduct
     */
    name?: string;
    /**
     * The product ID
     * @type {string}
     * @memberof SystemProfileInstalledProduct
     */
    id?: string;
    /**
     * Subscription status for product
     * @type {string}
     * @memberof SystemProfileInstalledProduct
     */
    status?: string;
}
/**
 * Object containing data specific to the MS SQL workload
 * @export
 * @interface SystemProfileMssql
 */
export interface SystemProfileMssql {
    /**
     * MSSQL version number
     * @type {string}
     * @memberof SystemProfileMssql
     */
    version?: string;
}
/**
 * Representation of one network interface
 * @export
 * @interface SystemProfileNetworkInterface
 */
export interface SystemProfileNetworkInterface {
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileNetworkInterface
     */
    ipv4_addresses?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileNetworkInterface
     */
    ipv6_addresses?: Array<string>;
    /**
     * MTU (Maximum transmission unit)
     * @type {number}
     * @memberof SystemProfileNetworkInterface
     */
    mtu?: number;
    /**
     * MAC address (with or without colons)
     * @type {string}
     * @memberof SystemProfileNetworkInterface
     */
    mac_address?: string;
    /**
     * Name of interface
     * @type {string}
     * @memberof SystemProfileNetworkInterface
     */
    name?: string;
    /**
     * Interface state (UP, DOWN, UNKNOWN)
     * @type {string}
     * @memberof SystemProfileNetworkInterface
     */
    state?: string;
    /**
     * Interface type (ether, loopback)
     * @type {string}
     * @memberof SystemProfileNetworkInterface
     */
    type?: string;
}
/**
 * Object for OS details. Supports range operations
 * @export
 * @interface SystemProfileOperatingSystem
 */
export interface SystemProfileOperatingSystem {
    /**
     * Major release of OS (aka the x version)
     * @type {number}
     * @memberof SystemProfileOperatingSystem
     */
    major: number;
    /**
     * Minor release of OS (aka the y version)
     * @type {number}
     * @memberof SystemProfileOperatingSystem
     */
    minor: number;
    /**
     * Name of the distro/os
     * @type {string}
     * @memberof SystemProfileOperatingSystem
     */
    name: SystemProfileOperatingSystemNameEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileOperatingSystemNameEnum {
    RHEL = 'RHEL',
    CentOS = 'CentOS'
}

/**
 *
 * @export
 * @interface SystemProfileOperatingSystemOut
 */
export interface SystemProfileOperatingSystemOut {
    /**
     * Total number of items
     * @type {number}
     * @memberof SystemProfileOperatingSystemOut
     */
    total?: number;
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof SystemProfileOperatingSystemOut
     */
    count?: number;
    /**
     * The list of operating_system values on the account
     * @type {Array<SystemProfileOperatingSystemOutResults>}
     * @memberof SystemProfileOperatingSystemOut
     */
    results?: Array<SystemProfileOperatingSystemOutResults>;
}
/**
 *
 * @export
 * @interface SystemProfileOperatingSystemOutResults
 */
export interface SystemProfileOperatingSystemOutResults {
    /**
     *
     * @type {SystemProfileOperatingSystemOutValue}
     * @memberof SystemProfileOperatingSystemOutResults
     */
    value?: SystemProfileOperatingSystemOutValue;
    /**
     *
     * @type {number}
     * @memberof SystemProfileOperatingSystemOutResults
     */
    count?: number;
}
/**
 *
 * @export
 * @interface SystemProfileOperatingSystemOutValue
 */
export interface SystemProfileOperatingSystemOutValue {
    /**
     *
     * @type {string}
     * @memberof SystemProfileOperatingSystemOutValue
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof SystemProfileOperatingSystemOutValue
     */
    major?: number | null;
    /**
     *
     * @type {number}
     * @memberof SystemProfileOperatingSystemOutValue
     */
    minor?: number | null;
}
/**
 * Object for subscription-manager details
 * @export
 * @interface SystemProfileRhsm
 */
export interface SystemProfileRhsm {
    /**
     * System release set by subscription-manager
     * @type {string}
     * @memberof SystemProfileRhsm
     */
    version?: string;
}
/**
 *
 * @export
 * @interface SystemProfileSapSystemOut
 */
export interface SystemProfileSapSystemOut {
    /**
     * Total number of items
     * @type {number}
     * @memberof SystemProfileSapSystemOut
     */
    total?: number;
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof SystemProfileSapSystemOut
     */
    count?: number;
    /**
     * The list of sap_system values on the account
     * @type {Array<SystemProfileSapSystemOutResults>}
     * @memberof SystemProfileSapSystemOut
     */
    results?: Array<SystemProfileSapSystemOutResults>;
}
/**
 *
 * @export
 * @interface SystemProfileSapSystemOutResults
 */
export interface SystemProfileSapSystemOutResults {
    /**
     *
     * @type {string | boolean}
     * @memberof SystemProfileSapSystemOutResults
     */
    value?: string | boolean;
    /**
     *
     * @type {number}
     * @memberof SystemProfileSapSystemOutResults
     */
    count?: number;
}
/**
 * Object for system purpose information
 * @export
 * @interface SystemProfileSystemPurpose
 */
export interface SystemProfileSystemPurpose {
    /**
     * The intended usage of the system
     * @type {string}
     * @memberof SystemProfileSystemPurpose
     */
    usage?: SystemProfileSystemPurposeUsageEnum;
    /**
     * The intended role of the system
     * @type {string}
     * @memberof SystemProfileSystemPurpose
     */
    role?: SystemProfileSystemPurposeRoleEnum;
    /**
     * The intended SLA of the system
     * @type {string}
     * @memberof SystemProfileSystemPurpose
     */
    sla?: SystemProfileSystemPurposeSlaEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSystemPurposeUsageEnum {
    Production = 'Production',
    DevelopmentTest = 'Development/Test',
    DisasterRecovery = 'Disaster Recovery'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSystemPurposeRoleEnum {
    Server = 'Red Hat Enterprise Linux Server',
    Workstation = 'Red Hat Enterprise Linux Workstation',
    ComputeNode = 'Red Hat Enterprise Linux Compute Node'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSystemPurposeSlaEnum {
    Premium = 'Premium',
    Standard = 'Standard',
    SelfSupport = 'Self-Support'
}

/**
 * Representation of one yum repository
 * @export
 * @interface SystemProfileYumRepo
 */
export interface SystemProfileYumRepo {
    /**
     *
     * @type {string}
     * @memberof SystemProfileYumRepo
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileYumRepo
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfileYumRepo
     */
    gpgcheck?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfileYumRepo
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof SystemProfileYumRepo
     */
    base_url?: string;
}
/**
 *
 * @export
 * @interface TagCountOut
 */
export interface TagCountOut {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof TagCountOut
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof TagCountOut
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof TagCountOut
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof TagCountOut
     */
    total: number;
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: number; }}
     * @memberof TagCountOut
     */
    results?: { [key: string]: number; };
}
/**
 *
 * @export
 * @interface TagCountOutAllOf
 */
export interface TagCountOutAllOf {
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: number; }}
     * @memberof TagCountOutAllOf
     */
    results?: { [key: string]: number; };
}
/**
 *
 * @export
 * @interface TagsOut
 */
export interface TagsOut {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof TagsOut
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof TagsOut
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof TagsOut
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof TagsOut
     */
    total: number;
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: Array<StructuredTag>; }}
     * @memberof TagsOut
     */
    results?: { [key: string]: Array<StructuredTag>; };
}
/**
 *
 * @export
 * @interface TagsOutAllOf
 */
export interface TagsOutAllOf {
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: Array<StructuredTag>; }}
     * @memberof TagsOutAllOf
     */
    results?: { [key: string]: Array<StructuredTag>; };
}
/**
 * Representation of one yum repository
 * @export
 * @interface YumRepo
 */
export interface YumRepo {
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    gpgcheck?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    base_url?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Validates System Profile data from recent Kafka messages against a given spec, and compares it with the current one. Only HBI Admins can access this endpoint.
         * @summary validate system profile schema
         * @param {string} repoBranch The branch of the inventory-schemas repo to use
         * @param {string} [repoFork] The fork of the inventory-schemas repo to use
         * @param {number} [days] How many days worth of data to validate
         * @param {number} [maxMessages] Stops polling when this number of messages has been collected
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileValidateSchema: async (repoBranch: string, repoFork?: string, days?: number, maxMessages?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoBranch' is not null or undefined
            if (repoBranch === null || repoBranch === undefined) {
                throw new RequiredError('repoBranch','Required parameter repoBranch was null or undefined when calling apiSystemProfileValidateSchema.');
            }
            const localVarPath = `/system_profile/validate_schema`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (repoFork !== undefined) {
                localVarQueryParameter['repo_fork'] = repoFork;
            }

            if (repoBranch !== undefined) {
                localVarQueryParameter['repo_branch'] = repoBranch;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            if (maxMessages !== undefined) {
                localVarQueryParameter['max_messages'] = maxMessages;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Validates System Profile data from recent Kafka messages against a given spec, and compares it with the current one. Only HBI Admins can access this endpoint.
         * @summary validate system profile schema
         * @param {string} repoBranch The branch of the inventory-schemas repo to use
         * @param {string} [repoFork] The fork of the inventory-schemas repo to use
         * @param {number} [days] How many days worth of data to validate
         * @param {number} [maxMessages] Stops polling when this number of messages has been collected
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileValidateSchema(repoBranch: string, repoFork?: string, days?: number, maxMessages?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).apiSystemProfileValidateSchema(repoBranch, repoFork, days, maxMessages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Validates System Profile data from recent Kafka messages against a given spec, and compares it with the current one. Only HBI Admins can access this endpoint.
         * @summary validate system profile schema
         * @param {string} repoBranch The branch of the inventory-schemas repo to use
         * @param {string} [repoFork] The fork of the inventory-schemas repo to use
         * @param {number} [days] How many days worth of data to validate
         * @param {number} [maxMessages] Stops polling when this number of messages has been collected
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileValidateSchema(repoBranch: string, repoFork?: string, days?: number, maxMessages?: number, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).apiSystemProfileValidateSchema(repoBranch, repoFork, days, maxMessages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Validates System Profile data from recent Kafka messages against a given spec, and compares it with the current one. Only HBI Admins can access this endpoint.
     * @summary validate system profile schema
     * @param {string} repoBranch The branch of the inventory-schemas repo to use
     * @param {string} [repoFork] The fork of the inventory-schemas repo to use
     * @param {number} [days] How many days worth of data to validate
     * @param {number} [maxMessages] Stops polling when this number of messages has been collected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiSystemProfileValidateSchema(repoBranch: string, repoFork?: string, days?: number, maxMessages?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiSystemProfileValidateSchema(repoBranch, repoFork, days, maxMessages, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HostsApi - axios parameter creator
 * @export
 */
export const HostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete all hosts on the account
         * @param {boolean} [confirmDeleteAll] Confirmation to delete all hosts on an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteAllHosts: async (confirmDeleteAll?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hosts/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (confirmDeleteAll !== undefined) {
                localVarQueryParameter['confirm_delete_all'] = confirmDeleteAll;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById: async (hostIdList: Array<string>, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostDeleteById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete the entire list of hosts filtered by the given parameters
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteHostList: async (displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider_id'] = providerId;
            }

            if (providerType !== undefined) {
                localVarQueryParameter['provider_type'] = providerType;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById: async (hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList: async (displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, fields?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider_id'] = providerId;
            }

            if (providerType !== undefined) {
                localVarQueryParameter['provider_type'] = providerType;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [branchId] Filter by branch_id
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', branchId?: string, fields?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostSystemProfileById.');
            }
            const localVarPath = `/hosts/{host_id_list}/system_profile`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostTagCount.');
            }
            const localVarPath = `/hosts/{host_id_list}/tags/count`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostTags.');
            }
            const localVarPath = `/hosts/{host_id_list}/tags`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostHostCheckin: async (createCheckIn: CreateCheckIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCheckIn' is not null or undefined
            if (createCheckIn === null || createCheckIn === undefined) {
                throw new RequiredError('createCheckIn','Required parameter createCheckIn was null or undefined when calling apiHostHostCheckin.');
            }
            const localVarPath = `/hosts/checkin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCheckIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCheckIn !== undefined ? createCheckIn : {}) : (createCheckIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts: async (hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostMergeFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a host <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById: async (hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostPatchById.');
            }
            // verify required parameter 'patchHostIn' is not null or undefined
            if (patchHostIn === null || patchHostIn === undefined) {
                throw new RequiredError('patchHostIn','Required parameter patchHostIn was null or undefined when calling apiHostPatchById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchHostIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchHostIn !== undefined ? patchHostIn : {}) : (patchHostIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts: async (hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostReplaceFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostsApi - functional programming interface
 * @export
 */
export const HostsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete all hosts on the account
         * @param {boolean} [confirmDeleteAll] Confirmation to delete all hosts on an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostDeleteAllHosts(confirmDeleteAll?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostDeleteAllHosts(confirmDeleteAll, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostDeleteById(hostIdList, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete the entire list of hosts filtered by the given parameters
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostDeleteHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostDeleteHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, registeredWith, staleness, tags, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, fields?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [branchId] Filter by branch_id
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', branchId?: string, fields?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileByHostOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the number of tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagCountOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateHostOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostHostCheckin(createCheckIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a host <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HostsApi - factory interface
 * @export
 */
export const HostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete all hosts on the account
         * @param {boolean} [confirmDeleteAll] Confirmation to delete all hosts on an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteAllHosts(confirmDeleteAll?: boolean, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostDeleteAllHosts(confirmDeleteAll, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostDeleteById(hostIdList, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete the entire list of hosts filtered by the given parameters
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostDeleteHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, registeredWith, staleness, tags, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<HostQueryOutput> {
            return HostsApiFp(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, fields?: { [key: string]: object; }, options?: any): AxiosPromise<HostQueryOutput> {
            return HostsApiFp(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [branchId] Filter by branch_id
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', branchId?: string, fields?: { [key: string]: object; }, options?: any): AxiosPromise<SystemProfileByHostOut> {
            return HostsApiFp(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<TagCountOut> {
            return HostsApiFp(configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', search?: string, options?: any): AxiosPromise<TagsOut> {
            return HostsApiFp(configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any): AxiosPromise<CreateHostOut> {
            return HostsApiFp(configuration).apiHostHostCheckin(createCheckIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a host <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HostsApi - object-oriented interface
 * @export
 * @class HostsApi
 * @extends {BaseAPI}
 */
export class HostsApi extends BaseAPI {
    /**
     * Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write
     * @summary Delete all hosts on the account
     * @param {boolean} [confirmDeleteAll] Confirmation to delete all hosts on an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteAllHosts(confirmDeleteAll?: boolean, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteAllHosts(confirmDeleteAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
     * @summary Delete hosts by IDs
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteById(hostIdList, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write
     * @summary Delete the entire list of hosts filtered by the given parameters
     * @param {string} [displayName] Filter by display_name
     * @param {string} [fqdn] Filter by FQDN
     * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
     * @param {string} [insightsId] Filter by insights_id
     * @param {string} [providerId] Filter by provider_id
     * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
     * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts.
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, filter?: { [key: string]: object; }, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, registeredWith, staleness, tags, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
     * @summary Find hosts by their IDs
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
     * @summary Read the entire list of hosts
     * @param {string} [displayName] Filter by display_name
     * @param {string} [fqdn] Filter by FQDN
     * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
     * @param {string} [insightsId] Filter by insights_id
     * @param {string} [providerId] Filter by provider_id
     * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
     * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, fields?: { [key: string]: object; }, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
     * @summary Return one or more hosts system profile
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {string} [branchId] Filter by branch_id
     * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', branchId?: string, fields?: { [key: string]: object; }, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of tags on a host <br /><br /> Required permissions: inventory:hosts:read
     * @summary Get the number of tags on a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
     * @summary Get the tags on a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', search?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
     * @summary Update staleness timestamps for a host matching the provided facts
     * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any) {
        return HostsApiFp(this.configuration).apiHostHostCheckin(createCheckIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
     * @summary Merge facts under a namespace
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} namespace A namespace of the merged facts.
     * @param {object} body A dictionary with the new facts to merge with the original ones.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a host <br /><br /> Required permissions: inventory:hosts:write
     * @summary Update a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
     * @summary Replace facts under a namespace
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} namespace A namespace of the merged facts.
     * @param {object} body A dictionary with the new facts to replace the original ones.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SystemProfileApi - axios parameter creator
 * @export
 */
export const SystemProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all operating system versions and counts on an account
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetOperatingSystem: async (search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system_profile/operating_system`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap sids values and counts on an account
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSids: async (search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system_profile/sap_sids`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap system values and counts on an account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSystem: async (tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system_profile/sap_system`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemProfileApi - functional programming interface
 * @export
 */
export const SystemProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all operating system versions and counts on an account
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileGetOperatingSystem(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileOperatingSystemOut>> {
            const localVarAxiosArgs = await SystemProfileApiAxiosParamCreator(configuration).apiSystemProfileGetOperatingSystem(search, tags, perPage, page, staleness, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap sids values and counts on an account
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileSapSystemOut>> {
            const localVarAxiosArgs = await SystemProfileApiAxiosParamCreator(configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap system values and counts on an account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileSapSystemOut>> {
            const localVarAxiosArgs = await SystemProfileApiAxiosParamCreator(configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemProfileApi - factory interface
 * @export
 */
export const SystemProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all operating system versions and counts on an account
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetOperatingSystem(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<SystemProfileOperatingSystemOut> {
            return SystemProfileApiFp(configuration).apiSystemProfileGetOperatingSystem(search, tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap sids values and counts on an account
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<SystemProfileSapSystemOut> {
            return SystemProfileApiFp(configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap system values and counts on an account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<SystemProfileSapSystemOut> {
            return SystemProfileApiFp(configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemProfileApi - object-oriented interface
 * @export
 * @class SystemProfileApi
 * @extends {BaseAPI}
 */
export class SystemProfileApi extends BaseAPI {
    /**
     * Required permissions: inventory:hosts:read
     * @summary get all operating system versions and counts on an account
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemProfileApi
     */
    public apiSystemProfileGetOperatingSystem(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any) {
        return SystemProfileApiFp(this.configuration).apiSystemProfileGetOperatingSystem(search, tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions: inventory:hosts:read
     * @summary get all sap sids values and counts on an account
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemProfileApi
     */
    public apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any) {
        return SystemProfileApiFp(this.configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions: inventory:hosts:read
     * @summary get all sap system values and counts on an account
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemProfileApi
     */
    public apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any) {
        return SystemProfileApiFp(this.configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags: async (tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider_id'] = providerId;
            }

            if (providerType !== undefined) {
                localVarQueryParameter['provider_type'] = providerType;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveTags>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {string} [displayName] Filter by display_name
         * @param {string} [fqdn] Filter by FQDN
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<ActiveTags> {
            return TagsApiFp(configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Required permissions: inventory:hosts:read
     * @summary Get the active host tags for a given account
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {'tag' | 'count'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {string} [displayName] Filter by display_name
     * @param {string} [fqdn] Filter by FQDN
     * @param {string} [hostnameOrId] Filter by display_name, fqdn, id
     * @param {string} [insightsId] Filter by insights_id
     * @param {string} [providerId] Filter by provider_id
     * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
     * @param {Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', registeredWith?: Array<'insights' | 'yupana' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector'>, filter?: { [key: string]: object; }, options?: any) {
        return TagsApiFp(this.configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

}


