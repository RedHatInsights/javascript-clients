// tslint:disable
/**
 * Insights Host Inventory REST Interface
 * REST interface for the Insights Platform Host Inventory application.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Information about a host tag
 * @export
 * @interface ActiveTag
 */
export interface ActiveTag {
    /**
     *
     * @type {StructuredTag}
     * @memberof ActiveTag
     */
    tag: StructuredTag;
    /**
     * The number of hosts with the given tag. If the value is null this indicates that the count is unknown.
     * @type {number}
     * @memberof ActiveTag
     */
    count: number | null;
}
/**
 *
 * @export
 * @interface ActiveTags
 */
export interface ActiveTags {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof ActiveTags
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof ActiveTags
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof ActiveTags
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof ActiveTags
     */
    total: number;
    /**
     *
     * @type {Array<ActiveTag>}
     * @memberof ActiveTags
     */
    results: Array<ActiveTag>;
}
/**
 *
 * @export
 * @interface ActiveTagsAllOf
 */
export interface ActiveTagsAllOf {
    /**
     *
     * @type {Array<ActiveTag>}
     * @memberof ActiveTagsAllOf
     */
    results: Array<ActiveTag>;
}
/**
 * Data for a single Assignment Rule
 * @export
 * @interface AssignmentRuleIn
 */
export interface AssignmentRuleIn {
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleIn
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleIn
     */
    description?: string | null;
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleIn
     */
    group_id: string;
    /**
     *
     * @type {object}
     * @memberof AssignmentRuleIn
     */
    filter: object;
    /**
     *
     * @type {boolean}
     * @memberof AssignmentRuleIn
     */
    enabled: boolean;
}
/**
 * Data for a single Assignment Rule response
 * @export
 * @interface AssignmentRuleOut
 */
export interface AssignmentRuleOut {
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleOut
     */
    id?: string;
    /**
     * The Org ID of the tenant that owns the host.
     * @type {string}
     * @memberof AssignmentRuleOut
     */
    org_id?: string;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof AssignmentRuleOut
     */
    account?: string | null;
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleOut
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleOut
     */
    description?: string | null;
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleOut
     */
    group_id: string;
    /**
     *
     * @type {object}
     * @memberof AssignmentRuleOut
     */
    filter: object;
    /**
     *
     * @type {boolean}
     * @memberof AssignmentRuleOut
     */
    enabled: boolean;
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleOut
     */
    created: string;
    /**
     *
     * @type {string}
     * @memberof AssignmentRuleOut
     */
    modified: string;
}
/**
 * A paginated assignment-rule search query result with assignment-rule entries and their Inventory metadata.
 * @export
 * @interface AssignmentRuleQueryOutput
 */
export interface AssignmentRuleQueryOutput {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof AssignmentRuleQueryOutput
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof AssignmentRuleQueryOutput
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof AssignmentRuleQueryOutput
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof AssignmentRuleQueryOutput
     */
    total: number;
    /**
     * Actual assignment-rule search query result entries.
     * @type {Array<AssignmentRuleOut>}
     * @memberof AssignmentRuleQueryOutput
     */
    results: Array<AssignmentRuleOut>;
}
/**
 *
 * @export
 * @interface AssignmentRuleQueryOutputAllOf
 */
export interface AssignmentRuleQueryOutputAllOf {
    /**
     * Actual assignment-rule search query result entries.
     * @type {Array<AssignmentRuleOut>}
     * @memberof AssignmentRuleQueryOutputAllOf
     */
    results: Array<AssignmentRuleOut>;
}
/**
 *
 * @export
 * @interface CanonicalFactsIn
 */
export interface CanonicalFactsIn extends CanonicalFactsInAllOf {
}
/**
 *
 * @export
 * @interface CanonicalFactsInAllOf
 */
export interface CanonicalFactsInAllOf {
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    insights_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    subscription_manager_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    satellite_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    bios_uuid?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CanonicalFactsInAllOf
     */
    ip_addresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    fqdn?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CanonicalFactsInAllOf
     */
    mac_addresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    provider_id?: string;
    /**
     *
     * @type {string}
     * @memberof CanonicalFactsInAllOf
     */
    provider_type?: string;
}
/**
 *
 * @export
 * @interface CanonicalFactsOut
 */
export interface CanonicalFactsOut {
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    insights_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CanonicalFactsOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CanonicalFactsOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM etc. This field is one of the canonical facts and does not work without provider_type.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    provider_id?: string | null;
    /**
     * Type of external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM, etc. This field is one of the canonical facts and does not workout provider_id.
     * @type {string}
     * @memberof CanonicalFactsOut
     */
    provider_type?: string | null;
}
/**
 * Data required to create a check-in record for a host.
 * @export
 * @interface CreateCheckIn
 */
export interface CreateCheckIn {
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    insights_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    subscription_manager_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    satellite_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    bios_uuid: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateCheckIn
     */
    ip_addresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    fqdn: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateCheckIn
     */
    mac_addresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    provider_id: string;
    /**
     *
     * @type {string}
     * @memberof CreateCheckIn
     */
    provider_type: string;
    /**
     * How long from now to expect another check-in (in minutes).
     * @type {number}
     * @memberof CreateCheckIn
     */
    checkin_frequency?: number;
}
/**
 *
 * @export
 * @interface CreateCheckInAllOf
 */
export interface CreateCheckInAllOf {
    /**
     * How long from now to expect another check-in (in minutes).
     * @type {number}
     * @memberof CreateCheckInAllOf
     */
    checkin_frequency?: number;
}
/**
 * Representation of one mounted device
 * @export
 * @interface DiskDevice
 */
export interface DiskDevice {
    /**
     *
     * @type {string}
     * @memberof DiskDevice
     */
    device?: string;
    /**
     * User-defined mount label
     * @type {string}
     * @memberof DiskDevice
     */
    label?: string;
    /**
     * An arbitrary object that does not allow empty string keys.
     * @type {{ [key: string]: object; }}
     * @memberof DiskDevice
     */
    options?: { [key: string]: object; };
    /**
     * The mount point
     * @type {string}
     * @memberof DiskDevice
     */
    mount_point?: string;
    /**
     * The mount type
     * @type {string}
     * @memberof DiskDevice
     */
    type?: string;
}
/**
 * Representation of one DNF module
 * @export
 * @interface DnfModule
 */
export interface DnfModule {
    /**
     *
     * @type {string}
     * @memberof DnfModule
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof DnfModule
     */
    stream?: string;
}
/**
 * A set of string facts belonging to a single namespace.
 * @export
 * @interface FactSet
 */
export interface FactSet {
    /**
     * A namespace the facts belong to.
     * @type {string}
     * @memberof FactSet
     */
    namespace: string;
    /**
     * The facts themselves.
     * @type {object}
     * @memberof FactSet
     */
    facts: object;
}
/**
 * Data of a single group belonging to an account.
 * @export
 * @interface GroupIn
 */
export interface GroupIn {
    /**
     * A group’s human-readable name.
     * @type {string}
     * @memberof GroupIn
     */
    name?: string;
    /**
     * A comma-separated list of host IDs that belong to the group.
     * @type {Array<string>}
     * @memberof GroupIn
     */
    host_ids?: Array<string> | null;
}
/**
 * Data of a single group belonging to an account.
 * @export
 * @interface GroupOut
 */
export interface GroupOut {
    /**
     *
     * @type {string}
     * @memberof GroupOut
     */
    id?: string;
    /**
     * A group’s human-readable name.
     * @type {string}
     * @memberof GroupOut
     */
    name?: string;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof GroupOut
     */
    account?: string | null;
    /**
     * The Org ID of the tenant that owns the host.
     * @type {string}
     * @memberof GroupOut
     */
    org_id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof GroupOut
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof GroupOut
     */
    updated?: string;
}
/**
 * Data of a single group belonging to an account.
 * @export
 * @interface GroupOutWithHostCount
 */
export interface GroupOutWithHostCount {
    /**
     *
     * @type {string}
     * @memberof GroupOutWithHostCount
     */
    id?: string;
    /**
     * A group’s human-readable name.
     * @type {string}
     * @memberof GroupOutWithHostCount
     */
    name?: string;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof GroupOutWithHostCount
     */
    account?: string | null;
    /**
     * The Org ID of the tenant that owns the host.
     * @type {string}
     * @memberof GroupOutWithHostCount
     */
    org_id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof GroupOutWithHostCount
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof GroupOutWithHostCount
     */
    updated?: string;
    /**
     * The number of hosts associated with the group.
     * @type {number}
     * @memberof GroupOutWithHostCount
     */
    host_count?: number;
}
/**
 *
 * @export
 * @interface GroupOutWithHostCountAllOf
 */
export interface GroupOutWithHostCountAllOf {
    /**
     * The number of hosts associated with the group.
     * @type {number}
     * @memberof GroupOutWithHostCountAllOf
     */
    host_count?: number;
}
/**
 * A paginated group search query result with group entries and their Inventory metadata.
 * @export
 * @interface GroupQueryOutput
 */
export interface GroupQueryOutput {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof GroupQueryOutput
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof GroupQueryOutput
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof GroupQueryOutput
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof GroupQueryOutput
     */
    total: number;
    /**
     * Actual group search query result entries.
     * @type {Array<GroupOutWithHostCount>}
     * @memberof GroupQueryOutput
     */
    results: Array<GroupOutWithHostCount>;
}
/**
 *
 * @export
 * @interface GroupQueryOutputAllOf
 */
export interface GroupQueryOutputAllOf {
    /**
     * Actual group search query result entries.
     * @type {Array<GroupOutWithHostCount>}
     * @memberof GroupQueryOutputAllOf
     */
    results: Array<GroupOutWithHostCount>;
}
/**
 * A single Host ID that belongs to a host.
 * @export
 * @interface HostIdOut
 */
export interface HostIdOut {
    /**
     *
     * @type {string}
     * @memberof HostIdOut
     */
    id?: string;
}
/**
 * Data of a single host belonging to an account. Represents the hosts without its Inventory metadata.
 * @export
 * @interface HostOut
 */
export interface HostOut {
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    insights_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof HostOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof HostOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM etc. This field is one of the canonical facts and does not work without provider_type.
     * @type {string}
     * @memberof HostOut
     */
    provider_id?: string | null;
    /**
     * Type of external source e.g. Alibaba, AWS EC2, Azure, GCP, IBM, etc. This field is one of the canonical facts and does not workout provider_id.
     * @type {string}
     * @memberof HostOut
     */
    provider_type?: string | null;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof HostOut
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof HostOut
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof HostOut
     */
    account?: string | null;
    /**
     * The Org ID of the tenant that owns the host.
     * @type {string}
     * @memberof HostOut
     */
    org_id: string;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof HostOut
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof HostOut
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof HostOut
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOut
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof HostOut
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof HostOut
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof HostOut
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof HostOut
     */
    reporter?: string | null;
    /**
     * Reporting source of the last checkin status, stale_timestamp, and last_check_in.
     * @type {{ [key: string]: PerReporterStaleness; }}
     * @memberof HostOut
     */
    per_reporter_staleness?: { [key: string]: PerReporterStaleness; };
    /**
     * The groups that the host belongs to, if any.
     * @type {Array<GroupOut>}
     * @memberof HostOut
     */
    groups?: Array<GroupOut>;
    /**
     *
     * @type {SystemProfile}
     * @memberof HostOut
     */
    system_profile?: SystemProfile;
}
/**
 *
 * @export
 * @interface HostOutAllOf
 */
export interface HostOutAllOf {
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof HostOutAllOf
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof HostOutAllOf
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof HostOutAllOf
     */
    account?: string | null;
    /**
     * The Org ID of the tenant that owns the host.
     * @type {string}
     * @memberof HostOutAllOf
     */
    org_id: string;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof HostOutAllOf
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof HostOutAllOf
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof HostOutAllOf
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOutAllOf
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof HostOutAllOf
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof HostOutAllOf
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof HostOutAllOf
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof HostOutAllOf
     */
    reporter?: string | null;
    /**
     * Reporting source of the last checkin status, stale_timestamp, and last_check_in.
     * @type {{ [key: string]: PerReporterStaleness; }}
     * @memberof HostOutAllOf
     */
    per_reporter_staleness?: { [key: string]: PerReporterStaleness; };
    /**
     * The groups that the host belongs to, if any.
     * @type {Array<GroupOut>}
     * @memberof HostOutAllOf
     */
    groups?: Array<GroupOut>;
    /**
     *
     * @type {SystemProfile}
     * @memberof HostOutAllOf
     */
    system_profile?: SystemProfile;
}
/**
 * A paginated host search query result with host entries and their Inventory metadata.
 * @export
 * @interface HostQueryOutput
 */
export interface HostQueryOutput {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof HostQueryOutput
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof HostQueryOutput
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof HostQueryOutput
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof HostQueryOutput
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostOut>}
     * @memberof HostQueryOutput
     */
    results: Array<HostOut>;
}
/**
 *
 * @export
 * @interface HostQueryOutputAllOf
 */
export interface HostQueryOutputAllOf {
    /**
     * Actual host search query result entries.
     * @type {Array<HostOut>}
     * @memberof HostQueryOutputAllOf
     */
    results: Array<HostOut>;
}
/**
 * Individual host record that contains only the host id and system profile
 * @export
 * @interface HostSystemProfileOut
 */
export interface HostSystemProfileOut {
    /**
     *
     * @type {string}
     * @memberof HostSystemProfileOut
     */
    id?: string;
    /**
     *
     * @type {SystemProfile}
     * @memberof HostSystemProfileOut
     */
    system_profile?: SystemProfile;
}
/**
 * Representation of one installed product
 * @export
 * @interface InstalledProduct
 */
export interface InstalledProduct {
    /**
     *
     * @type {string}
     * @memberof InstalledProduct
     */
    name?: string;
    /**
     * The product ID
     * @type {string}
     * @memberof InstalledProduct
     */
    id?: string;
    /**
     * Subscription status for product
     * @type {string}
     * @memberof InstalledProduct
     */
    status?: string;
}
/**
 * The info for an InterSystems instance running on the system
 * @export
 * @interface InterSystemsRunningInstance
 */
export interface InterSystemsRunningInstance {
    /**
     * The name of the instance
     * @type {string}
     * @memberof InterSystemsRunningInstance
     */
    instance_name?: string;
    /**
     * The product of the instance
     * @type {string}
     * @memberof InterSystemsRunningInstance
     */
    product?: string;
    /**
     * The version of the instance
     * @type {string}
     * @memberof InterSystemsRunningInstance
     */
    version?: string;
}
/**
 * A collection of pagination links for resource-types endpoints
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * The URI path for the first page in the pagination
     * @type {string}
     * @memberof Links
     */
    first: string;
    /**
     * The URI path for the previous page in the pagination
     * @type {string}
     * @memberof Links
     */
    previous: string | null;
    /**
     * The URI path for the next page in the pagination
     * @type {string}
     * @memberof Links
     */
    next: string | null;
    /**
     * The URI path for the last page in the pagination
     * @type {string}
     * @memberof Links
     */
    last: string;
}
/**
 * The metadata for resource-types responses
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * The total number of objects returned by the query.
     * @type {number}
     * @memberof Meta
     */
    count: number;
}
/**
 * Representation of one network interface
 * @export
 * @interface NetworkInterface
 */
export interface NetworkInterface {
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv4_addresses?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv6_addresses?: Array<string>;
    /**
     * MTU (Maximum transmission unit)
     * @type {number}
     * @memberof NetworkInterface
     */
    mtu?: number;
    /**
     * MAC address (with or without colons)
     * @type {string}
     * @memberof NetworkInterface
     */
    mac_address?: string;
    /**
     * Name of interface
     * @type {string}
     * @memberof NetworkInterface
     */
    name?: string;
    /**
     * Interface state (UP, DOWN, UNKNOWN)
     * @type {string}
     * @memberof NetworkInterface
     */
    state?: string;
    /**
     * Interface type (ether, loopback)
     * @type {string}
     * @memberof NetworkInterface
     */
    type?: string;
}
/**
 *
 * @export
 * @interface PaginationOut
 */
export interface PaginationOut {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof PaginationOut
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof PaginationOut
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof PaginationOut
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof PaginationOut
     */
    total: number;
}
/**
 * Data of a single host to be updated.
 * @export
 * @interface PatchHostIn
 */
export interface PatchHostIn {
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof PatchHostIn
     */
    ansible_host?: string;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof PatchHostIn
     */
    display_name?: string;
}
/**
 *
 * @export
 * @interface PerReporterStaleness
 */
export interface PerReporterStaleness {
    /**
     *
     * @type {string}
     * @memberof PerReporterStaleness
     */
    last_check_in?: string;
    /**
     *
     * @type {string}
     * @memberof PerReporterStaleness
     */
    stale_timestamp?: string;
    /**
     *
     * @type {string}
     * @memberof PerReporterStaleness
     */
    stale_warning_timestamp?: string;
    /**
     *
     * @type {string}
     * @memberof PerReporterStaleness
     */
    culled_timestamp?: string;
    /**
     *
     * @type {boolean}
     * @memberof PerReporterStaleness
     */
    check_in_succeeded?: boolean;
}
/**
 * Limited deployment information from systems managed by rpm-ostree as reported by rpm-ostree status --json
 * @export
 * @interface RPMOSTreeDeployment
 */
export interface RPMOSTreeDeployment {
    /**
     * ID of the deployment
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    id: string;
    /**
     * The checksum / commit of the deployment
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    checksum: string;
    /**
     * The origin repo from which the commit was installed
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    origin: string;
    /**
     * The operating system name
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    osname: string;
    /**
     * The version of the deployment
     * @type {string}
     * @memberof RPMOSTreeDeployment
     */
    version?: string;
    /**
     * Whether the deployment is currently booted
     * @type {boolean}
     * @memberof RPMOSTreeDeployment
     */
    booted: boolean;
    /**
     * Whether the deployment is currently pinned
     * @type {boolean}
     * @memberof RPMOSTreeDeployment
     */
    pinned: boolean;
}
/**
 * A paginated group search query result with group entries and their Inventory metadata in paginated resource-types response format.
 * @export
 * @interface ResourceTypesGroupsQueryOutput
 */
export interface ResourceTypesGroupsQueryOutput {
    /**
     *
     * @type {Meta}
     * @memberof ResourceTypesGroupsQueryOutput
     */
    meta: Meta;
    /**
     *
     * @type {Links}
     * @memberof ResourceTypesGroupsQueryOutput
     */
    links: Links;
    /**
     * Actual group search query result entries.
     * @type {Array<GroupOutWithHostCount>}
     * @memberof ResourceTypesGroupsQueryOutput
     */
    data: Array<GroupOutWithHostCount>;
}
/**
 *
 * @export
 * @interface ResourceTypesGroupsQueryOutputAllOf
 */
export interface ResourceTypesGroupsQueryOutputAllOf {
    /**
     * Actual group search query result entries.
     * @type {Array<GroupOutWithHostCount>}
     * @memberof ResourceTypesGroupsQueryOutputAllOf
     */
    data: Array<GroupOutWithHostCount>;
}
/**
 * Data describing a single resource-types RBAC object.
 * @export
 * @interface ResourceTypesOut
 */
export interface ResourceTypesOut {
    /**
     * The name of the resource type
     * @type {string}
     * @memberof ResourceTypesOut
     */
    value?: string;
    /**
     * The path for the RBAC endpoint for the resource type
     * @type {string}
     * @memberof ResourceTypesOut
     */
    path?: string;
    /**
     *
     * @type {number}
     * @memberof ResourceTypesOut
     */
    count?: number;
}
/**
 *
 * @export
 * @interface ResourceTypesPaginationOut
 */
export interface ResourceTypesPaginationOut {
    /**
     *
     * @type {Meta}
     * @memberof ResourceTypesPaginationOut
     */
    meta: Meta;
    /**
     *
     * @type {Links}
     * @memberof ResourceTypesPaginationOut
     */
    links: Links;
}
/**
 * A paginated list of resource-types RBAC objects.
 * @export
 * @interface ResourceTypesQueryOutput
 */
export interface ResourceTypesQueryOutput {
    /**
     *
     * @type {Meta}
     * @memberof ResourceTypesQueryOutput
     */
    meta: Meta;
    /**
     *
     * @type {Links}
     * @memberof ResourceTypesQueryOutput
     */
    links: Links;
    /**
     * Actual resource-types object data.
     * @type {Array<ResourceTypesOut>}
     * @memberof ResourceTypesQueryOutput
     */
    data: Array<ResourceTypesOut>;
}
/**
 *
 * @export
 * @interface ResourceTypesQueryOutputAllOf
 */
export interface ResourceTypesQueryOutputAllOf {
    /**
     * Actual resource-types object data.
     * @type {Array<ResourceTypesOut>}
     * @memberof ResourceTypesQueryOutputAllOf
     */
    data: Array<ResourceTypesOut>;
}
/**
 * @type StalenessId
 * Account Staleness UID
 * @export
 */
export type StalenessId = SystemDefaultId | string;

/**
 * Data of a single account staleness.
 * @export
 * @interface StalenessIn
 */
export interface StalenessIn {
    /**
     *
     * @type {number}
     * @memberof StalenessIn
     */
    conventional_time_to_stale?: number;
    /**
     *
     * @type {number}
     * @memberof StalenessIn
     */
    conventional_time_to_stale_warning?: number;
    /**
     *
     * @type {number}
     * @memberof StalenessIn
     */
    conventional_time_to_delete?: number;
    /**
     *
     * @type {number}
     * @memberof StalenessIn
     */
    immutable_time_to_stale?: number;
    /**
     *
     * @type {number}
     * @memberof StalenessIn
     */
    immutable_time_to_stale_warning?: number;
    /**
     *
     * @type {number}
     * @memberof StalenessIn
     */
    immutable_time_to_delete?: number;
}
/**
 * Data of a account staleness.
 * @export
 * @interface StalenessOutput
 */
export interface StalenessOutput {
    /**
     *
     * @type {number}
     * @memberof StalenessOutput
     */
    conventional_time_to_stale: number;
    /**
     *
     * @type {number}
     * @memberof StalenessOutput
     */
    conventional_time_to_stale_warning: number;
    /**
     *
     * @type {number}
     * @memberof StalenessOutput
     */
    conventional_time_to_delete: number;
    /**
     *
     * @type {number}
     * @memberof StalenessOutput
     */
    immutable_time_to_stale: number;
    /**
     *
     * @type {number}
     * @memberof StalenessOutput
     */
    immutable_time_to_stale_warning: number;
    /**
     *
     * @type {number}
     * @memberof StalenessOutput
     */
    immutable_time_to_delete: number;
    /**
     *
     * @type {StalenessId}
     * @memberof StalenessOutput
     */
    id: StalenessId;
    /**
     * The Org ID of the tenant that owns the host.
     * @type {string}
     * @memberof StalenessOutput
     */
    org_id: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof StalenessOutput
     */
    created: string | null;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof StalenessOutput
     */
    updated: string | null;
}
/**
 *
 * @export
 * @interface StalenessOutputAllOf
 */
export interface StalenessOutputAllOf {
    /**
     *
     * @type {StalenessId}
     * @memberof StalenessOutputAllOf
     */
    id: StalenessId;
    /**
     * The Org ID of the tenant that owns the host.
     * @type {string}
     * @memberof StalenessOutputAllOf
     */
    org_id: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof StalenessOutputAllOf
     */
    created: string | null;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof StalenessOutputAllOf
     */
    updated: string | null;
}
/**
 *
 * @export
 * @interface StructuredTag
 */
export interface StructuredTag {
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    namespace?: string | null;
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    value?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum SystemDefaultId {
    SystemDefault = 'system_default'
}

/**
 * Representation of the system profile fields
 * @export
 * @interface SystemProfile
 */
export interface SystemProfile {
    /**
     * A UUID associated with the host\'s RHSM certificate
     * @type {string}
     * @memberof SystemProfile
     */
    owner_id?: string;
    /**
     * A UUID associated with a cloud_connector
     * @type {string}
     * @memberof SystemProfile
     */
    rhc_client_id?: string;
    /**
     * A UUID associated with the config manager state
     * @type {string}
     * @memberof SystemProfile
     */
    rhc_config_state?: string;
    /**
     * The cpu model name
     * @type {string}
     * @memberof SystemProfile
     */
    cpu_model?: string;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    number_of_cpus?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    number_of_sockets?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    cores_per_socket?: number;
    /**
     * Number of CPU threads per CPU core. Typical values: 1, 2, 4
     * @type {number}
     * @memberof SystemProfile
     */
    threads_per_core?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    system_memory_bytes?: number;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    infrastructure_type?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    infrastructure_vendor?: string;
    /**
     *
     * @type {Array<NetworkInterface>}
     * @memberof SystemProfile
     */
    network_interfaces?: Array<NetworkInterface>;
    /**
     *
     * @type {Array<DiskDevice>}
     * @memberof SystemProfile
     */
    disk_devices?: Array<DiskDevice>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_vendor?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_release_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    cpu_flags?: Array<string>;
    /**
     *
     * @type {SystemProfileSystemd}
     * @memberof SystemProfile
     */
    systemd?: SystemProfileSystemd;
    /**
     *
     * @type {SystemProfileOperatingSystem}
     * @memberof SystemProfile
     */
    operating_system?: SystemProfileOperatingSystem;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    os_release?: string;
    /**
     * The kernel version represented with a three, optionally four, number scheme.
     * @type {string}
     * @memberof SystemProfile
     */
    os_kernel_version?: string;
    /**
     * Release name of the system distribution (from yum/dnf)
     * @type {string}
     * @memberof SystemProfile
     */
    releasever?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    arch?: string;
    /**
     * The architecture family (from yum/dnf)
     * @type {string}
     * @memberof SystemProfile
     */
    basearch?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    kernel_modules?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    last_boot_time?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    running_processes?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    subscription_status?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    subscription_auto_attach?: string;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfile
     */
    katello_agent_running?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfile
     */
    satellite_managed?: boolean;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    cloud_provider?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    public_ipv4_addresses?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    public_dns?: Array<string>;
    /**
     *
     * @type {Array<YumRepo>}
     * @memberof SystemProfile
     */
    yum_repos?: Array<YumRepo>;
    /**
     *
     * @type {Array<DnfModule>}
     * @memberof SystemProfile
     */
    dnf_modules?: Array<DnfModule>;
    /**
     *
     * @type {Array<InstalledProduct>}
     * @memberof SystemProfile
     */
    installed_products?: Array<InstalledProduct>;
    /**
     * The version number of insights client. supports wildcards
     * @type {string}
     * @memberof SystemProfile
     */
    insights_client_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    insights_egg_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    captured_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_packages?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_packages_delta?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    gpg_pubkeys?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_services?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    enabled_services?: Array<string>;
    /**
     *
     * @type {SystemProfileSap}
     * @memberof SystemProfile
     */
    sap?: SystemProfileSap;
    /**
     * Indicates if SAP is installed on the system
     * @type {boolean}
     * @memberof SystemProfile
     */
    sap_system?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    sap_sids?: Array<string>;
    /**
     * The instance number of the SAP HANA system (a two-digit number between 00 and 99)
     * @type {string}
     * @memberof SystemProfile
     */
    sap_instance_number?: string;
    /**
     * The version of the SAP HANA lifecycle management program
     * @type {string}
     * @memberof SystemProfile
     */
    sap_version?: string;
    /**
     * Current profile resulting from command tuned-adm active
     * @type {string}
     * @memberof SystemProfile
     */
    tuned_profile?: string;
    /**
     * The current SELinux mode, either enforcing, permissive, or disabled
     * @type {string}
     * @memberof SystemProfile
     */
    selinux_current_mode?: SystemProfileSelinuxCurrentModeEnum;
    /**
     * The SELinux mode provided in the config file
     * @type {string}
     * @memberof SystemProfile
     */
    selinux_config_file?: string;
    /**
     * Indicates whether the host is part of a marketplace install from AWS, Azure, etc.
     * @type {boolean}
     * @memberof SystemProfile
     */
    is_marketplace?: boolean;
    /**
     * Indicates the type of host.
     * @type {string}
     * @memberof SystemProfile
     */
    host_type?: SystemProfileHostTypeEnum;
    /**
     * Indicates the greenboot status of an edge device.
     * @type {string}
     * @memberof SystemProfile
     */
    greenboot_status?: SystemProfileGreenbootStatusEnum;
    /**
     * Indicates whether greenboot detected a rolled back update on an edge device.
     * @type {boolean}
     * @memberof SystemProfile
     */
    greenboot_fallback_detected?: boolean;
    /**
     * The list of deployments on the system as reported by rpm-ostree status --json
     * @type {Array<RPMOSTreeDeployment>}
     * @memberof SystemProfile
     */
    rpm_ostree_deployments?: Array<RPMOSTreeDeployment>;
    /**
     *
     * @type {SystemProfileRhsm}
     * @memberof SystemProfile
     */
    rhsm?: SystemProfileRhsm;
    /**
     *
     * @type {SystemProfileSystemPurpose}
     * @memberof SystemProfile
     */
    system_purpose?: SystemProfileSystemPurpose;
    /**
     *
     * @type {SystemProfileAnsible}
     * @memberof SystemProfile
     */
    ansible?: SystemProfileAnsible;
    /**
     *
     * @type {SystemProfileIntersystems}
     * @memberof SystemProfile
     */
    intersystems?: SystemProfileIntersystems;
    /**
     *
     * @type {SystemProfileMssql}
     * @memberof SystemProfile
     */
    mssql?: SystemProfileMssql;
    /**
     * System update method
     * @type {string}
     * @memberof SystemProfile
     */
    system_update_method?: SystemProfileSystemUpdateMethodEnum;
    /**
     * Hypervisor host identity (subscription manager id)
     * @type {string}
     * @memberof SystemProfile
     */
    virtual_host_uuid?: string;
    /**
     *
     * @type {SystemProfileBootcStatus}
     * @memberof SystemProfile
     */
    bootc_status?: SystemProfileBootcStatus;
    /**
     *
     * @type {SystemProfileConversions}
     * @memberof SystemProfile
     */
    conversions?: SystemProfileConversions;
    /**
     *
     * @type {SystemProfileRhelAi}
     * @memberof SystemProfile
     */
    rhel_ai?: SystemProfileRhelAi;
    /**
     *
     * @type {SystemProfileThirdPartyServices}
     * @memberof SystemProfile
     */
    third_party_services?: SystemProfileThirdPartyServices;
    /**
     *
     * @type {SystemProfileImageBuilder}
     * @memberof SystemProfile
     */
    image_builder?: SystemProfileImageBuilder;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSelinuxCurrentModeEnum {
    Enforcing = 'enforcing',
    Permissive = 'permissive',
    Disabled = 'disabled'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileHostTypeEnum {
    Edge = 'edge'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileGreenbootStatusEnum {
    Red = 'red',
    Green = 'green'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSystemUpdateMethodEnum {
    Dnf = 'dnf',
    RpmOstree = 'rpm-ostree',
    Yum = 'yum'
}

/**
 * Object containing data specific to Ansible Automation Platform
 * @export
 * @interface SystemProfileAnsible
 */
export interface SystemProfileAnsible {
    /**
     * The ansible-tower or automation-controller version on the host
     * @type {string}
     * @memberof SystemProfileAnsible
     */
    controller_version?: string;
    /**
     * The automation-hub version on the host
     * @type {string}
     * @memberof SystemProfileAnsible
     */
    hub_version?: string;
    /**
     * The catalog-worker version on the host
     * @type {string}
     * @memberof SystemProfileAnsible
     */
    catalog_worker_version?: string;
    /**
     * The SSO version on the host
     * @type {string}
     * @memberof SystemProfileAnsible
     */
    sso_version?: string;
}
/**
 * Object containing image data from command bootc status
 * @export
 * @interface SystemProfileBootcStatus
 */
export interface SystemProfileBootcStatus {
    /**
     *
     * @type {SystemProfileBootcStatusBooted}
     * @memberof SystemProfileBootcStatus
     */
    booted?: SystemProfileBootcStatusBooted;
    /**
     *
     * @type {SystemProfileBootcStatusBooted}
     * @memberof SystemProfileBootcStatus
     */
    rollback?: SystemProfileBootcStatusBooted;
    /**
     *
     * @type {SystemProfileBootcStatusBooted}
     * @memberof SystemProfileBootcStatus
     */
    staged?: SystemProfileBootcStatusBooted;
}
/**
 *
 * @export
 * @interface SystemProfileBootcStatusBooted
 */
export interface SystemProfileBootcStatusBooted {
    /**
     * Name of the image
     * @type {string}
     * @memberof SystemProfileBootcStatusBooted
     */
    image?: string;
    /**
     * Digest of the image
     * @type {string}
     * @memberof SystemProfileBootcStatusBooted
     */
    image_digest?: string;
    /**
     * Name of the image
     * @type {string}
     * @memberof SystemProfileBootcStatusBooted
     */
    cached_image?: string;
    /**
     * Digest of the image
     * @type {string}
     * @memberof SystemProfileBootcStatusBooted
     */
    cached_image_digest?: string;
}
/**
 * Structure of the output of the host system profile query
 * @export
 * @interface SystemProfileByHostOut
 */
export interface SystemProfileByHostOut {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostSystemProfileOut>}
     * @memberof SystemProfileByHostOut
     */
    results: Array<HostSystemProfileOut>;
}
/**
 *
 * @export
 * @interface SystemProfileByHostOutAllOf
 */
export interface SystemProfileByHostOutAllOf {
    /**
     * Actual host search query result entries.
     * @type {Array<HostSystemProfileOut>}
     * @memberof SystemProfileByHostOutAllOf
     */
    results: Array<HostSystemProfileOut>;
}
/**
 * Object containing information about 3rd party migration on instances
 * @export
 * @interface SystemProfileConversions
 */
export interface SystemProfileConversions {
    /**
     * Whether the conversion activity has been done or not
     * @type {boolean}
     * @memberof SystemProfileConversions
     */
    activity?: boolean;
}
/**
 * Representation of one mounted device
 * @export
 * @interface SystemProfileDiskDevice
 */
export interface SystemProfileDiskDevice {
    /**
     *
     * @type {string}
     * @memberof SystemProfileDiskDevice
     */
    device?: string;
    /**
     * User-defined mount label
     * @type {string}
     * @memberof SystemProfileDiskDevice
     */
    label?: string;
    /**
     * An arbitrary object that does not allow empty string keys.
     * @type {{ [key: string]: object; }}
     * @memberof SystemProfileDiskDevice
     */
    options?: { [key: string]: object; };
    /**
     * The mount point
     * @type {string}
     * @memberof SystemProfileDiskDevice
     */
    mount_point?: string;
    /**
     * The mount type
     * @type {string}
     * @memberof SystemProfileDiskDevice
     */
    type?: string;
}
/**
 * Representation of one DNF module
 * @export
 * @interface SystemProfileDnfModule
 */
export interface SystemProfileDnfModule {
    /**
     *
     * @type {string}
     * @memberof SystemProfileDnfModule
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileDnfModule
     */
    stream?: string;
}
/**
 * Object containing image builder facts
 * @export
 * @interface SystemProfileImageBuilder
 */
export interface SystemProfileImageBuilder {
    /**
     * The compliance policy that was used and applied during the image build
     * @type {string}
     * @memberof SystemProfileImageBuilder
     */
    compliance_policy_id?: string;
    /**
     * The profile that was applied during the image build on which the compliance policy was based
     * @type {string}
     * @memberof SystemProfileImageBuilder
     */
    compliance_profile_id?: string;
}
/**
 * Representation of one installed product
 * @export
 * @interface SystemProfileInstalledProduct
 */
export interface SystemProfileInstalledProduct {
    /**
     *
     * @type {string}
     * @memberof SystemProfileInstalledProduct
     */
    name?: string;
    /**
     * The product ID
     * @type {string}
     * @memberof SystemProfileInstalledProduct
     */
    id?: string;
    /**
     * Subscription status for product
     * @type {string}
     * @memberof SystemProfileInstalledProduct
     */
    status?: string;
}
/**
 * Object containing data specific to InterSystems workload
 * @export
 * @interface SystemProfileIntersystems
 */
export interface SystemProfileIntersystems {
    /**
     * Indicates if InterSystems is installed on the system
     * @type {boolean}
     * @memberof SystemProfileIntersystems
     */
    is_intersystems?: boolean;
    /**
     *
     * @type {Array<InterSystemsRunningInstance>}
     * @memberof SystemProfileIntersystems
     */
    running_instances?: Array<InterSystemsRunningInstance>;
}
/**
 * Object containing data specific to the MS SQL workload
 * @export
 * @interface SystemProfileMssql
 */
export interface SystemProfileMssql {
    /**
     * MSSQL version number
     * @type {string}
     * @memberof SystemProfileMssql
     */
    version?: string;
}
/**
 * Representation of one network interface
 * @export
 * @interface SystemProfileNetworkInterface
 */
export interface SystemProfileNetworkInterface {
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileNetworkInterface
     */
    ipv4_addresses?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileNetworkInterface
     */
    ipv6_addresses?: Array<string>;
    /**
     * MTU (Maximum transmission unit)
     * @type {number}
     * @memberof SystemProfileNetworkInterface
     */
    mtu?: number;
    /**
     * MAC address (with or without colons)
     * @type {string}
     * @memberof SystemProfileNetworkInterface
     */
    mac_address?: string;
    /**
     * Name of interface
     * @type {string}
     * @memberof SystemProfileNetworkInterface
     */
    name?: string;
    /**
     * Interface state (UP, DOWN, UNKNOWN)
     * @type {string}
     * @memberof SystemProfileNetworkInterface
     */
    state?: string;
    /**
     * Interface type (ether, loopback)
     * @type {string}
     * @memberof SystemProfileNetworkInterface
     */
    type?: string;
}
/**
 * Object for OS details. Supports range operations
 * @export
 * @interface SystemProfileOperatingSystem
 */
export interface SystemProfileOperatingSystem {
    /**
     * Major release of OS (aka the x version)
     * @type {number}
     * @memberof SystemProfileOperatingSystem
     */
    major: number;
    /**
     * Minor release of OS (aka the y version)
     * @type {number}
     * @memberof SystemProfileOperatingSystem
     */
    minor: number;
    /**
     * Name of the distro/os
     * @type {string}
     * @memberof SystemProfileOperatingSystem
     */
    name: SystemProfileOperatingSystemNameEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileOperatingSystemNameEnum {
    RHEL = 'RHEL',
    CentOS = 'CentOS',
    CentOSLinux = 'CentOS Linux'
}

/**
 *
 * @export
 * @interface SystemProfileOperatingSystemOut
 */
export interface SystemProfileOperatingSystemOut {
    /**
     * Total number of items
     * @type {number}
     * @memberof SystemProfileOperatingSystemOut
     */
    total?: number;
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof SystemProfileOperatingSystemOut
     */
    count?: number;
    /**
     * The list of operating_system values on the account
     * @type {Array<SystemProfileOperatingSystemOutResults>}
     * @memberof SystemProfileOperatingSystemOut
     */
    results?: Array<SystemProfileOperatingSystemOutResults>;
}
/**
 *
 * @export
 * @interface SystemProfileOperatingSystemOutResults
 */
export interface SystemProfileOperatingSystemOutResults {
    /**
     *
     * @type {SystemProfileOperatingSystemOutValue}
     * @memberof SystemProfileOperatingSystemOutResults
     */
    value?: SystemProfileOperatingSystemOutValue;
    /**
     *
     * @type {number}
     * @memberof SystemProfileOperatingSystemOutResults
     */
    count?: number;
}
/**
 *
 * @export
 * @interface SystemProfileOperatingSystemOutValue
 */
export interface SystemProfileOperatingSystemOutValue {
    /**
     *
     * @type {string}
     * @memberof SystemProfileOperatingSystemOutValue
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof SystemProfileOperatingSystemOutValue
     */
    major?: number | null;
    /**
     *
     * @type {number}
     * @memberof SystemProfileOperatingSystemOutValue
     */
    minor?: number | null;
}
/**
 * Object containing information about RHEL AI
 * @export
 * @interface SystemProfileRhelAi
 */
export interface SystemProfileRhelAi {
    /**
     * RHEL AI VARIANT
     * @type {string}
     * @memberof SystemProfileRhelAi
     */
    variant?: string;
    /**
     * RHEL AI VERSION ID
     * @type {string}
     * @memberof SystemProfileRhelAi
     */
    rhel_ai_version_id?: string;
    /**
     * Model name of Nvidia GPUs in the GPU index order
     * @type {Array<string>}
     * @memberof SystemProfileRhelAi
     */
    nvidia_gpu_models?: Array<string>;
}
/**
 * Object for subscription-manager details
 * @export
 * @interface SystemProfileRhsm
 */
export interface SystemProfileRhsm {
    /**
     * System release set by subscription-manager
     * @type {string}
     * @memberof SystemProfileRhsm
     */
    version?: string;
}
/**
 * Object containing data specific to the SAP workload
 * @export
 * @interface SystemProfileSap
 */
export interface SystemProfileSap {
    /**
     * Indicates if SAP is installed on the system
     * @type {boolean}
     * @memberof SystemProfileSap
     */
    sap_system?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileSap
     */
    sids?: Array<string>;
    /**
     * The instance number of the SAP HANA system (a two-digit number between 00 and 99)
     * @type {string}
     * @memberof SystemProfileSap
     */
    instance_number?: string;
    /**
     * The version of the SAP HANA lifecycle management program
     * @type {string}
     * @memberof SystemProfileSap
     */
    version?: string;
}
/**
 *
 * @export
 * @interface SystemProfileSapSystemOut
 */
export interface SystemProfileSapSystemOut {
    /**
     * Total number of items
     * @type {number}
     * @memberof SystemProfileSapSystemOut
     */
    total?: number;
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof SystemProfileSapSystemOut
     */
    count?: number;
    /**
     * The list of sap_system values on the account
     * @type {Array<SystemProfileSapSystemOutResults>}
     * @memberof SystemProfileSapSystemOut
     */
    results?: Array<SystemProfileSapSystemOutResults>;
}
/**
 *
 * @export
 * @interface SystemProfileSapSystemOutResults
 */
export interface SystemProfileSapSystemOutResults {
    /**
     *
     * @type {string | boolean}
     * @memberof SystemProfileSapSystemOutResults
     */
    value?: string | boolean;
    /**
     *
     * @type {number}
     * @memberof SystemProfileSapSystemOutResults
     */
    count?: number;
}
/**
 * Object for system purpose information
 * @export
 * @interface SystemProfileSystemPurpose
 */
export interface SystemProfileSystemPurpose {
    /**
     * The intended usage of the system
     * @type {string}
     * @memberof SystemProfileSystemPurpose
     */
    usage?: SystemProfileSystemPurposeUsageEnum;
    /**
     * The intended role of the system
     * @type {string}
     * @memberof SystemProfileSystemPurpose
     */
    role?: SystemProfileSystemPurposeRoleEnum;
    /**
     * The intended SLA of the system
     * @type {string}
     * @memberof SystemProfileSystemPurpose
     */
    sla?: SystemProfileSystemPurposeSlaEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSystemPurposeUsageEnum {
    Production = 'Production',
    DevelopmentTest = 'Development/Test',
    DisasterRecovery = 'Disaster Recovery'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSystemPurposeRoleEnum {
    Server = 'Red Hat Enterprise Linux Server',
    Workstation = 'Red Hat Enterprise Linux Workstation',
    ComputeNode = 'Red Hat Enterprise Linux Compute Node'
}
/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSystemPurposeSlaEnum {
    Premium = 'Premium',
    Standard = 'Standard',
    SelfSupport = 'Self-Support'
}

/**
 * Object for whole system systemd state, as reported by systemctl status --all
 * @export
 * @interface SystemProfileSystemd
 */
export interface SystemProfileSystemd {
    /**
     * The state of the systemd subsystem
     * @type {string}
     * @memberof SystemProfileSystemd
     */
    state: SystemProfileSystemdStateEnum;
    /**
     * The number of jobs jobs_queued
     * @type {number}
     * @memberof SystemProfileSystemd
     */
    jobs_queued: number;
    /**
     * The number of jobs failed
     * @type {number}
     * @memberof SystemProfileSystemd
     */
    failed: number;
    /**
     * List of all failed jobs.
     * @type {Array<string>}
     * @memberof SystemProfileSystemd
     */
    failed_services?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum SystemProfileSystemdStateEnum {
    Initializing = 'initializing',
    Starting = 'starting',
    Running = 'running',
    Degraded = 'degraded',
    Maintenance = 'maintenance',
    Stopping = 'stopping'
}

/**
 * Object containing information about system facts of third party services
 * @export
 * @interface SystemProfileThirdPartyServices
 */
export interface SystemProfileThirdPartyServices {
    /**
     *
     * @type {SystemProfileThirdPartyServicesCrowdstrike}
     * @memberof SystemProfileThirdPartyServices
     */
    crowdstrike?: SystemProfileThirdPartyServicesCrowdstrike;
}
/**
 * Object containing information about CrowdStrike system facts
 * @export
 * @interface SystemProfileThirdPartyServicesCrowdstrike
 */
export interface SystemProfileThirdPartyServicesCrowdstrike {
    /**
     * CrowdStrike Falcon Agent ID
     * @type {string}
     * @memberof SystemProfileThirdPartyServicesCrowdstrike
     */
    falcon_aid?: string;
    /**
     * CrowdStrike Falcon Sensor backend
     * @type {string}
     * @memberof SystemProfileThirdPartyServicesCrowdstrike
     */
    falcon_backend?: string;
    /**
     * CrowdStrike running Falcon Sensor version
     * @type {string}
     * @memberof SystemProfileThirdPartyServicesCrowdstrike
     */
    falcon_version?: string;
}
/**
 * Representation of one yum repository
 * @export
 * @interface SystemProfileYumRepo
 */
export interface SystemProfileYumRepo {
    /**
     *
     * @type {string}
     * @memberof SystemProfileYumRepo
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileYumRepo
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfileYumRepo
     */
    gpgcheck?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfileYumRepo
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof SystemProfileYumRepo
     */
    base_url?: string;
    /**
     * URL of a mirrorlist for the repository
     * @type {string}
     * @memberof SystemProfileYumRepo
     */
    mirrorlist?: string;
}
/**
 *
 * @export
 * @interface TagCountOut
 */
export interface TagCountOut {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof TagCountOut
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof TagCountOut
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof TagCountOut
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof TagCountOut
     */
    total: number;
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: number; }}
     * @memberof TagCountOut
     */
    results?: { [key: string]: number; };
}
/**
 *
 * @export
 * @interface TagCountOutAllOf
 */
export interface TagCountOutAllOf {
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: number; }}
     * @memberof TagCountOutAllOf
     */
    results?: { [key: string]: number; };
}
/**
 *
 * @export
 * @interface TagsOut
 */
export interface TagsOut {
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof TagsOut
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof TagsOut
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof TagsOut
     */
    per_page: number;
    /**
     * Total number of items
     * @type {number}
     * @memberof TagsOut
     */
    total: number;
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: Array<StructuredTag>; }}
     * @memberof TagsOut
     */
    results?: { [key: string]: Array<StructuredTag>; };
}
/**
 *
 * @export
 * @interface TagsOutAllOf
 */
export interface TagsOutAllOf {
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: Array<StructuredTag>; }}
     * @memberof TagsOutAllOf
     */
    results?: { [key: string]: Array<StructuredTag>; };
}
/**
 *
 * @export
 * @interface UnleashToggleOut
 */
export interface UnleashToggleOut {
    /**
     * The value of the feature flag toggle
     * @type {boolean}
     * @memberof UnleashToggleOut
     */
    flag_value?: boolean;
    /**
     * Whether the fallback value was used, if the Unleash server could not be accessed
     * @type {boolean}
     * @memberof UnleashToggleOut
     */
    using_fallback_value?: boolean;
}
/**
 * Representation of one yum repository
 * @export
 * @interface YumRepo
 */
export interface YumRepo {
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    gpgcheck?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    base_url?: string;
    /**
     * URL of a mirrorlist for the repository
     * @type {string}
     * @memberof YumRepo
     */
    mirrorlist?: string;
}

/**
 * AccountsStalenessApi - axios parameter creator
 * @export
 */
export const AccountsStalenessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create account staleness record. Required permissions: staleness:staleness:write
         * @summary Create account staleness record
         * @param {StalenessIn} stalenessIn Data required to create a record for a account staleness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessCreateStaleness: async (stalenessIn: StalenessIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stalenessIn' is not null or undefined
            if (stalenessIn === null || stalenessIn === undefined) {
                throw new RequiredError('stalenessIn','Required parameter stalenessIn was null or undefined when calling apiStalenessCreateStaleness.');
            }
            const localVarPath = `/account/staleness`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof stalenessIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(stalenessIn !== undefined ? stalenessIn : {}) : (stalenessIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an account staleness <br /><br /> Required permissions: staleness:staleness:write
         * @summary Delete an account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessDeleteStaleness: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/staleness`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all accounts staleness available. Required permissions: staleness:staleness:read
         * @summary Read the entire list of account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessGetDefaultStaleness: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/staleness/defaults`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all accounts staleness available. Required permissions: staleness:staleness:read
         * @summary Read the entire list of account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessGetStaleness: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/staleness`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update account staleness record. Required permissions: staleness:staleness:write
         * @summary Update account staleness record
         * @param {StalenessIn} stalenessIn Data required to update a record for a account staleness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessUpdateStaleness: async (stalenessIn: StalenessIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stalenessIn' is not null or undefined
            if (stalenessIn === null || stalenessIn === undefined) {
                throw new RequiredError('stalenessIn','Required parameter stalenessIn was null or undefined when calling apiStalenessUpdateStaleness.');
            }
            const localVarPath = `/account/staleness`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof stalenessIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(stalenessIn !== undefined ? stalenessIn : {}) : (stalenessIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsStalenessApi - functional programming interface
 * @export
 */
export const AccountsStalenessApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create account staleness record. Required permissions: staleness:staleness:write
         * @summary Create account staleness record
         * @param {StalenessIn} stalenessIn Data required to create a record for a account staleness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStalenessCreateStaleness(stalenessIn: StalenessIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StalenessOutput>> {
            const localVarAxiosArgs = await AccountsStalenessApiAxiosParamCreator(configuration).apiStalenessCreateStaleness(stalenessIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an account staleness <br /><br /> Required permissions: staleness:staleness:write
         * @summary Delete an account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStalenessDeleteStaleness(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountsStalenessApiAxiosParamCreator(configuration).apiStalenessDeleteStaleness(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all accounts staleness available. Required permissions: staleness:staleness:read
         * @summary Read the entire list of account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStalenessGetDefaultStaleness(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StalenessOutput>> {
            const localVarAxiosArgs = await AccountsStalenessApiAxiosParamCreator(configuration).apiStalenessGetDefaultStaleness(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all accounts staleness available. Required permissions: staleness:staleness:read
         * @summary Read the entire list of account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStalenessGetStaleness(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StalenessOutput>> {
            const localVarAxiosArgs = await AccountsStalenessApiAxiosParamCreator(configuration).apiStalenessGetStaleness(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update account staleness record. Required permissions: staleness:staleness:write
         * @summary Update account staleness record
         * @param {StalenessIn} stalenessIn Data required to update a record for a account staleness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStalenessUpdateStaleness(stalenessIn: StalenessIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StalenessOutput>> {
            const localVarAxiosArgs = await AccountsStalenessApiAxiosParamCreator(configuration).apiStalenessUpdateStaleness(stalenessIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountsStalenessApi - factory interface
 * @export
 */
export const AccountsStalenessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create account staleness record. Required permissions: staleness:staleness:write
         * @summary Create account staleness record
         * @param {StalenessIn} stalenessIn Data required to create a record for a account staleness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessCreateStaleness(stalenessIn: StalenessIn, options?: any): AxiosPromise<StalenessOutput> {
            return AccountsStalenessApiFp(configuration).apiStalenessCreateStaleness(stalenessIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an account staleness <br /><br /> Required permissions: staleness:staleness:write
         * @summary Delete an account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessDeleteStaleness(options?: any): AxiosPromise<void> {
            return AccountsStalenessApiFp(configuration).apiStalenessDeleteStaleness(options).then((request) => request(axios, basePath));
        },
        /**
         * Read the entire list of all accounts staleness available. Required permissions: staleness:staleness:read
         * @summary Read the entire list of account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessGetDefaultStaleness(options?: any): AxiosPromise<StalenessOutput> {
            return AccountsStalenessApiFp(configuration).apiStalenessGetDefaultStaleness(options).then((request) => request(axios, basePath));
        },
        /**
         * Read the entire list of all accounts staleness available. Required permissions: staleness:staleness:read
         * @summary Read the entire list of account staleness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessGetStaleness(options?: any): AxiosPromise<StalenessOutput> {
            return AccountsStalenessApiFp(configuration).apiStalenessGetStaleness(options).then((request) => request(axios, basePath));
        },
        /**
         * Update account staleness record. Required permissions: staleness:staleness:write
         * @summary Update account staleness record
         * @param {StalenessIn} stalenessIn Data required to update a record for a account staleness.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStalenessUpdateStaleness(stalenessIn: StalenessIn, options?: any): AxiosPromise<StalenessOutput> {
            return AccountsStalenessApiFp(configuration).apiStalenessUpdateStaleness(stalenessIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsStalenessApi - object-oriented interface
 * @export
 * @class AccountsStalenessApi
 * @extends {BaseAPI}
 */
export class AccountsStalenessApi extends BaseAPI {
    /**
     * Create account staleness record. Required permissions: staleness:staleness:write
     * @summary Create account staleness record
     * @param {StalenessIn} stalenessIn Data required to create a record for a account staleness.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsStalenessApi
     */
    public apiStalenessCreateStaleness(stalenessIn: StalenessIn, options?: any) {
        return AccountsStalenessApiFp(this.configuration).apiStalenessCreateStaleness(stalenessIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an account staleness <br /><br /> Required permissions: staleness:staleness:write
     * @summary Delete an account staleness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsStalenessApi
     */
    public apiStalenessDeleteStaleness(options?: any) {
        return AccountsStalenessApiFp(this.configuration).apiStalenessDeleteStaleness(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the entire list of all accounts staleness available. Required permissions: staleness:staleness:read
     * @summary Read the entire list of account staleness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsStalenessApi
     */
    public apiStalenessGetDefaultStaleness(options?: any) {
        return AccountsStalenessApiFp(this.configuration).apiStalenessGetDefaultStaleness(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the entire list of all accounts staleness available. Required permissions: staleness:staleness:read
     * @summary Read the entire list of account staleness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsStalenessApi
     */
    public apiStalenessGetStaleness(options?: any) {
        return AccountsStalenessApiFp(this.configuration).apiStalenessGetStaleness(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update account staleness record. Required permissions: staleness:staleness:write
     * @summary Update account staleness record
     * @param {StalenessIn} stalenessIn Data required to update a record for a account staleness.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsStalenessApi
     */
    public apiStalenessUpdateStaleness(stalenessIn: StalenessIn, options?: any) {
        return AccountsStalenessApiFp(this.configuration).apiStalenessUpdateStaleness(stalenessIn, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Assignment Rule object using post request <br /><br /> Required permissions: inventory:groups:write
         * @summary Create Assignment Rule object
         * @param {AssignmentRuleIn} assignmentRuleIn Data required to create Assignment Rule object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAssignmentRuleCreateAssignmentRule: async (assignmentRuleIn: AssignmentRuleIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentRuleIn' is not null or undefined
            if (assignmentRuleIn === null || assignmentRuleIn === undefined) {
                throw new RequiredError('assignmentRuleIn','Required parameter assignmentRuleIn was null or undefined when calling apiAssignmentRuleCreateAssignmentRule.');
            }
            const localVarPath = `/assignment-rules`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof assignmentRuleIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(assignmentRuleIn !== undefined ? assignmentRuleIn : {}) : (assignmentRuleIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more assignment rules by their IDs. <br /><br /> Required permissions: inventory:groups:read
         * @summary Find assignment rules by their IDs
         * @param {Array<string>} assignmentRuleIdList A comma-separated list of assignment-rule IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'group_id'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAssignmentRuleGetAssignmentRulesById: async (assignmentRuleIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'name' | 'group_id', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentRuleIdList' is not null or undefined
            if (assignmentRuleIdList === null || assignmentRuleIdList === undefined) {
                throw new RequiredError('assignmentRuleIdList','Required parameter assignmentRuleIdList was null or undefined when calling apiAssignmentRuleGetAssignmentRulesById.');
            }
            const localVarPath = `/assignment-rules/{assignment_rule_id_list}`
                .replace(`{${"assignment_rule_id_list"}}`, encodeURIComponent(String(assignmentRuleIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all assignment-rules available to the account. [Not Implemented] Required permissions: inventory:groups:read
         * @summary Read the entire list of assignment-rules [Not Implemented]
         * @param {string} [name] Filter by assignment-rule name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'group_id'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAssignmentRuleGetAssignmentRulesList: async (name?: string, perPage?: number, page?: number, orderBy?: 'name' | 'group_id', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/assignment-rules`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new group containing the hosts associated with the host IDs provided. <br /><br /> Required permissions: inventory:groups:write
         * @summary Create a new group matching the provided name and list of hosts IDs
         * @param {GroupIn} groupIn Data required to create a record for a group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupCreateGroup: async (groupIn: GroupIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupIn' is not null or undefined
            if (groupIn === null || groupIn === undefined) {
                throw new RequiredError('groupIn','Required parameter groupIn was null or undefined when calling apiGroupCreateGroup.');
            }
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof groupIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(groupIn !== undefined ? groupIn : {}) : (groupIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a list of groups. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete a list of groups
         * @param {Array<string>} groupIdList A comma-separated list of group IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupDeleteGroups: async (groupIdList: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupIdList' is not null or undefined
            if (groupIdList === null || groupIdList === undefined) {
                throw new RequiredError('groupIdList','Required parameter groupIdList was null or undefined when calling apiGroupDeleteGroups.');
            }
            const localVarPath = `/groups/{group_id_list}`
                .replace(`{${"group_id_list"}}`, encodeURIComponent(String(groupIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a list of hosts from the groups they are in. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete a list of hosts from the groups they are in
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupDeleteHostsFromDifferentGroups: async (hostIdList: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiGroupDeleteHostsFromDifferentGroups.');
            }
            const localVarPath = `/groups/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all groups available to the account. <br /><br /> Required permissions: inventory:groups:read
         * @summary Read the entire list of groups
         * @param {string} [name] Filter by group name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'host_count' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupGetGroupList: async (name?: string, perPage?: number, page?: number, orderBy?: 'name' | 'host_count' | 'updated', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more groups by their IDs. <br /><br /> Required permissions: inventory:groups:read
         * @summary Find groups by their IDs
         * @param {Array<string>} groupIdList A comma-separated list of group IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'host_count' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupGetGroupsById: async (groupIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'name' | 'host_count' | 'updated', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupIdList' is not null or undefined
            if (groupIdList === null || groupIdList === undefined) {
                throw new RequiredError('groupIdList','Required parameter groupIdList was null or undefined when calling apiGroupGetGroupsById.');
            }
            const localVarPath = `/groups/{group_id_list}`
                .replace(`{${"group_id_list"}}`, encodeURIComponent(String(groupIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merge group information. <br /><br /> Required permissions: inventory:groups:write
         * @summary Merge group information
         * @param {string} groupId Group ID.
         * @param {GroupIn} groupIn A dictionary with new information to merge with the original group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupPatchGroupById: async (groupId: string, groupIn: GroupIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling apiGroupPatchGroupById.');
            }
            // verify required parameter 'groupIn' is not null or undefined
            if (groupIn === null || groupIn === undefined) {
                throw new RequiredError('groupIn','Required parameter groupIn was null or undefined when calling apiGroupPatchGroupById.');
            }
            const localVarPath = `/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof groupIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(groupIn !== undefined ? groupIn : {}) : (groupIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds the host list in the request body to the provided group. <br /><br /> Required permissions: inventory:groups:write
         * @summary Add host IDs to the provided group
         * @param {string} groupId Group ID.
         * @param {Array<string>} requestBody A list of hosts IDs to associate with the provided group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGroupAddHostListToGroup: async (groupId: string, requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling apiHostGroupAddHostListToGroup.');
            }
            // verify required parameter 'requestBody' is not null or undefined
            if (requestBody === null || requestBody === undefined) {
                throw new RequiredError('requestBody','Required parameter requestBody was null or undefined when calling apiHostGroupAddHostListToGroup.');
            }
            const localVarPath = `/groups/{group_id}/hosts`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestBody !== undefined ? requestBody : {}) : (requestBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete one or more hosts from a group. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete one or more hosts from a group
         * @param {string} groupId Group ID.
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGroupDeleteHostsFromGroup: async (groupId: string, hostIdList: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling apiHostGroupDeleteHostsFromGroup.');
            }
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGroupDeleteHostsFromGroup.');
            }
            const localVarPath = `/groups/{group_id}/hosts/{host_id_list}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create Assignment Rule object using post request <br /><br /> Required permissions: inventory:groups:write
         * @summary Create Assignment Rule object
         * @param {AssignmentRuleIn} assignmentRuleIn Data required to create Assignment Rule object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAssignmentRuleCreateAssignmentRule(assignmentRuleIn: AssignmentRuleIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentRuleOut>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiAssignmentRuleCreateAssignmentRule(assignmentRuleIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more assignment rules by their IDs. <br /><br /> Required permissions: inventory:groups:read
         * @summary Find assignment rules by their IDs
         * @param {Array<string>} assignmentRuleIdList A comma-separated list of assignment-rule IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'group_id'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAssignmentRuleGetAssignmentRulesById(assignmentRuleIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'name' | 'group_id', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentRuleQueryOutput>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiAssignmentRuleGetAssignmentRulesById(assignmentRuleIdList, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all assignment-rules available to the account. [Not Implemented] Required permissions: inventory:groups:read
         * @summary Read the entire list of assignment-rules [Not Implemented]
         * @param {string} [name] Filter by assignment-rule name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'group_id'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAssignmentRuleGetAssignmentRulesList(name?: string, perPage?: number, page?: number, orderBy?: 'name' | 'group_id', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentRuleQueryOutput>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiAssignmentRuleGetAssignmentRulesList(name, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new group containing the hosts associated with the host IDs provided. <br /><br /> Required permissions: inventory:groups:write
         * @summary Create a new group matching the provided name and list of hosts IDs
         * @param {GroupIn} groupIn Data required to create a record for a group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupCreateGroup(groupIn: GroupIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOutWithHostCount>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiGroupCreateGroup(groupIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a list of groups. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete a list of groups
         * @param {Array<string>} groupIdList A comma-separated list of group IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupDeleteGroups(groupIdList: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiGroupDeleteGroups(groupIdList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a list of hosts from the groups they are in. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete a list of hosts from the groups they are in
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupDeleteHostsFromDifferentGroups(hostIdList: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiGroupDeleteHostsFromDifferentGroups(hostIdList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all groups available to the account. <br /><br /> Required permissions: inventory:groups:read
         * @summary Read the entire list of groups
         * @param {string} [name] Filter by group name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'host_count' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupGetGroupList(name?: string, perPage?: number, page?: number, orderBy?: 'name' | 'host_count' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupQueryOutput>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiGroupGetGroupList(name, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more groups by their IDs. <br /><br /> Required permissions: inventory:groups:read
         * @summary Find groups by their IDs
         * @param {Array<string>} groupIdList A comma-separated list of group IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'host_count' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupGetGroupsById(groupIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'name' | 'host_count' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupQueryOutput>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiGroupGetGroupsById(groupIdList, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Merge group information. <br /><br /> Required permissions: inventory:groups:write
         * @summary Merge group information
         * @param {string} groupId Group ID.
         * @param {GroupIn} groupIn A dictionary with new information to merge with the original group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupPatchGroupById(groupId: string, groupIn: GroupIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOutWithHostCount>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiGroupPatchGroupById(groupId, groupIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds the host list in the request body to the provided group. <br /><br /> Required permissions: inventory:groups:write
         * @summary Add host IDs to the provided group
         * @param {string} groupId Group ID.
         * @param {Array<string>} requestBody A list of hosts IDs to associate with the provided group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGroupAddHostListToGroup(groupId: string, requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupOutWithHostCount>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiHostGroupAddHostListToGroup(groupId, requestBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete one or more hosts from a group. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete one or more hosts from a group
         * @param {string} groupId Group ID.
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGroupDeleteHostsFromGroup(groupId: string, hostIdList: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GroupsApiAxiosParamCreator(configuration).apiHostGroupDeleteHostsFromGroup(groupId, hostIdList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create Assignment Rule object using post request <br /><br /> Required permissions: inventory:groups:write
         * @summary Create Assignment Rule object
         * @param {AssignmentRuleIn} assignmentRuleIn Data required to create Assignment Rule object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAssignmentRuleCreateAssignmentRule(assignmentRuleIn: AssignmentRuleIn, options?: any): AxiosPromise<AssignmentRuleOut> {
            return GroupsApiFp(configuration).apiAssignmentRuleCreateAssignmentRule(assignmentRuleIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one or more assignment rules by their IDs. <br /><br /> Required permissions: inventory:groups:read
         * @summary Find assignment rules by their IDs
         * @param {Array<string>} assignmentRuleIdList A comma-separated list of assignment-rule IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'group_id'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAssignmentRuleGetAssignmentRulesById(assignmentRuleIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'name' | 'group_id', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<AssignmentRuleQueryOutput> {
            return GroupsApiFp(configuration).apiAssignmentRuleGetAssignmentRulesById(assignmentRuleIdList, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Read the entire list of all assignment-rules available to the account. [Not Implemented] Required permissions: inventory:groups:read
         * @summary Read the entire list of assignment-rules [Not Implemented]
         * @param {string} [name] Filter by assignment-rule name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'group_id'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAssignmentRuleGetAssignmentRulesList(name?: string, perPage?: number, page?: number, orderBy?: 'name' | 'group_id', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<AssignmentRuleQueryOutput> {
            return GroupsApiFp(configuration).apiAssignmentRuleGetAssignmentRulesList(name, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new group containing the hosts associated with the host IDs provided. <br /><br /> Required permissions: inventory:groups:write
         * @summary Create a new group matching the provided name and list of hosts IDs
         * @param {GroupIn} groupIn Data required to create a record for a group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupCreateGroup(groupIn: GroupIn, options?: any): AxiosPromise<GroupOutWithHostCount> {
            return GroupsApiFp(configuration).apiGroupCreateGroup(groupIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a list of groups. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete a list of groups
         * @param {Array<string>} groupIdList A comma-separated list of group IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupDeleteGroups(groupIdList: Array<string>, options?: any): AxiosPromise<void> {
            return GroupsApiFp(configuration).apiGroupDeleteGroups(groupIdList, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a list of hosts from the groups they are in. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete a list of hosts from the groups they are in
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupDeleteHostsFromDifferentGroups(hostIdList: Array<string>, options?: any): AxiosPromise<void> {
            return GroupsApiFp(configuration).apiGroupDeleteHostsFromDifferentGroups(hostIdList, options).then((request) => request(axios, basePath));
        },
        /**
         * Read the entire list of all groups available to the account. <br /><br /> Required permissions: inventory:groups:read
         * @summary Read the entire list of groups
         * @param {string} [name] Filter by group name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'host_count' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupGetGroupList(name?: string, perPage?: number, page?: number, orderBy?: 'name' | 'host_count' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<GroupQueryOutput> {
            return GroupsApiFp(configuration).apiGroupGetGroupList(name, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one or more groups by their IDs. <br /><br /> Required permissions: inventory:groups:read
         * @summary Find groups by their IDs
         * @param {Array<string>} groupIdList A comma-separated list of group IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'name' | 'host_count' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupGetGroupsById(groupIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'name' | 'host_count' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<GroupQueryOutput> {
            return GroupsApiFp(configuration).apiGroupGetGroupsById(groupIdList, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Merge group information. <br /><br /> Required permissions: inventory:groups:write
         * @summary Merge group information
         * @param {string} groupId Group ID.
         * @param {GroupIn} groupIn A dictionary with new information to merge with the original group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupPatchGroupById(groupId: string, groupIn: GroupIn, options?: any): AxiosPromise<GroupOutWithHostCount> {
            return GroupsApiFp(configuration).apiGroupPatchGroupById(groupId, groupIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds the host list in the request body to the provided group. <br /><br /> Required permissions: inventory:groups:write
         * @summary Add host IDs to the provided group
         * @param {string} groupId Group ID.
         * @param {Array<string>} requestBody A list of hosts IDs to associate with the provided group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGroupAddHostListToGroup(groupId: string, requestBody: Array<string>, options?: any): AxiosPromise<GroupOutWithHostCount> {
            return GroupsApiFp(configuration).apiHostGroupAddHostListToGroup(groupId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete one or more hosts from a group. <br /><br /> Required permissions: inventory:groups:write
         * @summary Delete one or more hosts from a group
         * @param {string} groupId Group ID.
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGroupDeleteHostsFromGroup(groupId: string, hostIdList: Array<string>, options?: any): AxiosPromise<void> {
            return GroupsApiFp(configuration).apiHostGroupDeleteHostsFromGroup(groupId, hostIdList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Create Assignment Rule object using post request <br /><br /> Required permissions: inventory:groups:write
     * @summary Create Assignment Rule object
     * @param {AssignmentRuleIn} assignmentRuleIn Data required to create Assignment Rule object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiAssignmentRuleCreateAssignmentRule(assignmentRuleIn: AssignmentRuleIn, options?: any) {
        return GroupsApiFp(this.configuration).apiAssignmentRuleCreateAssignmentRule(assignmentRuleIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one or more assignment rules by their IDs. <br /><br /> Required permissions: inventory:groups:read
     * @summary Find assignment rules by their IDs
     * @param {Array<string>} assignmentRuleIdList A comma-separated list of assignment-rule IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'name' | 'group_id'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiAssignmentRuleGetAssignmentRulesById(assignmentRuleIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'name' | 'group_id', orderHow?: 'ASC' | 'DESC', options?: any) {
        return GroupsApiFp(this.configuration).apiAssignmentRuleGetAssignmentRulesById(assignmentRuleIdList, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the entire list of all assignment-rules available to the account. [Not Implemented] Required permissions: inventory:groups:read
     * @summary Read the entire list of assignment-rules [Not Implemented]
     * @param {string} [name] Filter by assignment-rule name
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'name' | 'group_id'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiAssignmentRuleGetAssignmentRulesList(name?: string, perPage?: number, page?: number, orderBy?: 'name' | 'group_id', orderHow?: 'ASC' | 'DESC', options?: any) {
        return GroupsApiFp(this.configuration).apiAssignmentRuleGetAssignmentRulesList(name, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new group containing the hosts associated with the host IDs provided. <br /><br /> Required permissions: inventory:groups:write
     * @summary Create a new group matching the provided name and list of hosts IDs
     * @param {GroupIn} groupIn Data required to create a record for a group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupCreateGroup(groupIn: GroupIn, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupCreateGroup(groupIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a list of groups. <br /><br /> Required permissions: inventory:groups:write
     * @summary Delete a list of groups
     * @param {Array<string>} groupIdList A comma-separated list of group IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupDeleteGroups(groupIdList: Array<string>, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupDeleteGroups(groupIdList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a list of hosts from the groups they are in. <br /><br /> Required permissions: inventory:groups:write
     * @summary Delete a list of hosts from the groups they are in
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupDeleteHostsFromDifferentGroups(hostIdList: Array<string>, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupDeleteHostsFromDifferentGroups(hostIdList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the entire list of all groups available to the account. <br /><br /> Required permissions: inventory:groups:read
     * @summary Read the entire list of groups
     * @param {string} [name] Filter by group name
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'name' | 'host_count' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupGetGroupList(name?: string, perPage?: number, page?: number, orderBy?: 'name' | 'host_count' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any) {
        return GroupsApiFp(this.configuration).apiGroupGetGroupList(name, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one or more groups by their IDs. <br /><br /> Required permissions: inventory:groups:read
     * @summary Find groups by their IDs
     * @param {Array<string>} groupIdList A comma-separated list of group IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'name' | 'host_count' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for name, and to DESC for host_count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupGetGroupsById(groupIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'name' | 'host_count' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any) {
        return GroupsApiFp(this.configuration).apiGroupGetGroupsById(groupIdList, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merge group information. <br /><br /> Required permissions: inventory:groups:write
     * @summary Merge group information
     * @param {string} groupId Group ID.
     * @param {GroupIn} groupIn A dictionary with new information to merge with the original group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiGroupPatchGroupById(groupId: string, groupIn: GroupIn, options?: any) {
        return GroupsApiFp(this.configuration).apiGroupPatchGroupById(groupId, groupIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds the host list in the request body to the provided group. <br /><br /> Required permissions: inventory:groups:write
     * @summary Add host IDs to the provided group
     * @param {string} groupId Group ID.
     * @param {Array<string>} requestBody A list of hosts IDs to associate with the provided group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiHostGroupAddHostListToGroup(groupId: string, requestBody: Array<string>, options?: any) {
        return GroupsApiFp(this.configuration).apiHostGroupAddHostListToGroup(groupId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete one or more hosts from a group. <br /><br /> Required permissions: inventory:groups:write
     * @summary Delete one or more hosts from a group
     * @param {string} groupId Group ID.
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public apiHostGroupDeleteHostsFromGroup(groupId: string, hostIdList: Array<string>, options?: any) {
        return GroupsApiFp(this.configuration).apiHostGroupDeleteHostsFromGroup(groupId, hostIdList, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HostsApi - axios parameter creator
 * @export
 */
export const HostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete all hosts on the account
         * @param {boolean} [confirmDeleteAll] Confirmation to delete all hosts on the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteAllHosts: async (confirmDeleteAll?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hosts/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (confirmDeleteAll !== undefined) {
                localVarQueryParameter['confirm_delete_all'] = confirmDeleteAll;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteHostById: async (hostIdList: Array<string>, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostDeleteHostById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete the entire list of hosts filtered by the given parameters
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteHostsByFilter: async (displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider_id'] = providerId;
            }

            if (providerType !== undefined) {
                localVarQueryParameter['provider_type'] = providerType;
            }

            if (updatedStart !== undefined) {
                localVarQueryParameter['updated_start'] = (updatedStart as any instanceof Date) ?
                    (updatedStart as any).toISOString() :
                    updatedStart;
            }

            if (updatedEnd !== undefined) {
                localVarQueryParameter['updated_end'] = (updatedEnd as any instanceof Date) ?
                    (updatedEnd as any).toISOString() :
                    updatedEnd;
            }

            if (groupName) {
                localVarQueryParameter['group_name'] = groupName;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById: async (hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', fields?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one host by insights_id, if it exists. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find one host by insights_id, if it exists
         * @param {string} [insightsId] Filter by insights_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostExists: async (insightsId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/host_exists`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList: async (displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, fields?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/hosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider_id'] = providerId;
            }

            if (providerType !== undefined) {
                localVarQueryParameter['provider_type'] = providerType;
            }

            if (updatedStart !== undefined) {
                localVarQueryParameter['updated_start'] = (updatedStart as any instanceof Date) ?
                    (updatedStart as any).toISOString() :
                    updatedStart;
            }

            if (updatedEnd !== undefined) {
                localVarQueryParameter['updated_end'] = (updatedEnd as any instanceof Date) ?
                    (updatedEnd as any).toISOString() :
                    updatedEnd;
            }

            if (groupName) {
                localVarQueryParameter['group_name'] = groupName;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [branchId] Filter by branch_id
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', branchId?: string, fields?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostSystemProfileById.');
            }
            const localVarPath = `/hosts/{host_id_list}/system_profile`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of tags on a host or hosts <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host or hosts
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostTagCount.');
            }
            const localVarPath = `/hosts/{host_id_list}/tags/count`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags: async (hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostTags.');
            }
            const localVarPath = `/hosts/{host_id_list}/tags`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostHostCheckin: async (createCheckIn: CreateCheckIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCheckIn' is not null or undefined
            if (createCheckIn === null || createCheckIn === undefined) {
                throw new RequiredError('createCheckIn','Required parameter createCheckIn was null or undefined when calling apiHostHostCheckin.');
            }
            const localVarPath = `/hosts/checkin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCheckIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCheckIn !== undefined ? createCheckIn : {}) : (createCheckIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts: async (hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostMergeFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update hosts <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update hosts
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the hosts
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchHostById: async (hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostPatchHostById.');
            }
            // verify required parameter 'patchHostIn' is not null or undefined
            if (patchHostIn === null || patchHostIn === undefined) {
                throw new RequiredError('patchHostIn','Required parameter patchHostIn was null or undefined when calling apiHostPatchHostById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchHostIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchHostIn !== undefined ? patchHostIn : {}) : (patchHostIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts: async (hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostReplaceFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostsApi - functional programming interface
 * @export
 */
export const HostsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete all hosts on the account
         * @param {boolean} [confirmDeleteAll] Confirmation to delete all hosts on the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostDeleteAllHosts(confirmDeleteAll?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostDeleteAllHosts(confirmDeleteAll, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostDeleteHostById(hostIdList: Array<string>, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostDeleteHostById(hostIdList, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete the entire list of hosts filtered by the given parameters
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostDeleteHostsByFilter(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostDeleteHostsByFilter(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, registeredWith, staleness, tags, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', fields?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one host by insights_id, if it exists. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find one host by insights_id, if it exists
         * @param {string} [insightsId] Filter by insights_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostExists(insightsId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostIdOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostExists(insightsId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, fields?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [branchId] Filter by branch_id
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', branchId?: string, fields?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileByHostOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the number of tags on a host or hosts <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host or hosts
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagCountOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostOut>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostHostCheckin(createCheckIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update hosts <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update hosts
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the hosts
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostPatchHostById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostPatchHostById(hostIdList, patchHostIn, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HostsApiAxiosParamCreator(configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HostsApi - factory interface
 * @export
 */
export const HostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete all hosts on the account
         * @param {boolean} [confirmDeleteAll] Confirmation to delete all hosts on the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteAllHosts(confirmDeleteAll?: boolean, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostDeleteAllHosts(confirmDeleteAll, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteHostById(hostIdList: Array<string>, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostDeleteHostById(hostIdList, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Delete the entire list of hosts filtered by the given parameters
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteHostsByFilter(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostDeleteHostsByFilter(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, registeredWith, staleness, tags, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', fields?: { [key: string]: object; }, options?: any): AxiosPromise<HostQueryOutput> {
            return HostsApiFp(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one host by insights_id, if it exists. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Find one host by insights_id, if it exists
         * @param {string} [insightsId] Filter by insights_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostExists(insightsId?: string, options?: any): AxiosPromise<HostIdOut> {
            return HostsApiFp(configuration).apiHostGetHostExists(insightsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
         * @summary Read the entire list of hosts
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, fields?: { [key: string]: object; }, options?: any): AxiosPromise<HostQueryOutput> {
            return HostsApiFp(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [branchId] Filter by branch_id
         * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', branchId?: string, fields?: { [key: string]: object; }, options?: any): AxiosPromise<SystemProfileByHostOut> {
            return HostsApiFp(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the number of tags on a host or hosts <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the number of tags on a host or hosts
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<TagCountOut> {
            return HostsApiFp(configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', search?: string, options?: any): AxiosPromise<TagsOut> {
            return HostsApiFp(configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update staleness timestamps for a host matching the provided facts
         * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any): AxiosPromise<HostOut> {
            return HostsApiFp(configuration).apiHostHostCheckin(createCheckIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update hosts <br /><br /> Required permissions: inventory:hosts:write
         * @summary Update hosts
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the hosts
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchHostById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostPatchHostById(hostIdList, patchHostIn, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma-separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HostsApi - object-oriented interface
 * @export
 * @class HostsApi
 * @extends {BaseAPI}
 */
export class HostsApi extends BaseAPI {
    /**
     * Delete all hosts on the account.  The request must include \"confirm_delete_all=true\". <br /><br /> Required permissions: inventory:hosts:write
     * @summary Delete all hosts on the account
     * @param {boolean} [confirmDeleteAll] Confirmation to delete all hosts on the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteAllHosts(confirmDeleteAll?: boolean, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteAllHosts(confirmDeleteAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete hosts by IDs <br /><br /> Required permissions: inventory:hosts:write
     * @summary Delete hosts by IDs
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteHostById(hostIdList: Array<string>, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteHostById(hostIdList, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the entire list of hosts filtered by the given parameters. <br /><br /> Required permissions: inventory:hosts:write
     * @summary Delete the entire list of hosts filtered by the given parameters
     * @param {string} [displayName] Filter by display_name (case-insensitive)
     * @param {string} [fqdn] Filter by FQDN (case-insensitive)
     * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
     * @param {string} [insightsId] Filter by insights_id
     * @param {string} [providerId] Filter by provider_id
     * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
     * @param {string} [updatedStart] Only show hosts last modified after the given date
     * @param {string} [updatedEnd] Only show hosts last modified before the given date
     * @param {Array<string>} [groupName] Filter by group name
     * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts.
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteHostsByFilter(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, filter?: { [key: string]: object; }, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteHostsByFilter(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, registeredWith, staleness, tags, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one or more hosts by their ID. <br /><br /> Required permissions: inventory:hosts:read
     * @summary Find hosts by their IDs
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', fields?: { [key: string]: object; }, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one host by insights_id, if it exists. <br /><br /> Required permissions: inventory:hosts:read
     * @summary Find one host by insights_id, if it exists
     * @param {string} [insightsId] Filter by insights_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostExists(insightsId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostExists(insightsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the entire list of all hosts available to the account. <br /><br /> Required permissions: inventory:hosts:read
     * @summary Read the entire list of hosts
     * @param {string} [displayName] Filter by display_name (case-insensitive)
     * @param {string} [fqdn] Filter by FQDN (case-insensitive)
     * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
     * @param {string} [insightsId] Filter by insights_id
     * @param {string} [providerId] Filter by provider_id
     * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
     * @param {string} [updatedStart] Only show hosts last modified after the given date
     * @param {string} [updatedEnd] Only show hosts last modified before the given date
     * @param {Array<string>} [groupName] Filter by group name
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
     * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, fields?: { [key: string]: object; }, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, filter, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find one or more hosts by their ID and return the id and system profile <br /><br /> Required permissions: inventory:hosts:read
     * @summary Return one or more hosts system profile
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {string} [branchId] Filter by branch_id
     * @param {{ [key: string]: object; }} [fields] Fetches only mentioned system_profile fields. For example, &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: [\&quot;arch\&quot;, \&quot;host_type\&quot;]} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?fields[system_profile]&#x3D;arch,host_type\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', branchId?: string, fields?: { [key: string]: object; }, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the number of tags on a host or hosts <br /><br /> Required permissions: inventory:hosts:read
     * @summary Get the number of tags on a host or hosts
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the tags on a host <br /><br /> Required permissions: inventory:hosts:read
     * @summary Get the tags on a host
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'group_name' | 'updated' | 'operating_system'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering; defaults to ASC for display_name, and to DESC for updated and operating_system
     * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'group_name' | 'updated' | 'operating_system', orderHow?: 'ASC' | 'DESC', search?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds a host and updates its staleness timestamps. It uses the supplied canonical facts to determine which host to update. By default, the staleness timestamp is set to 1 hour from when the request is received; however, this can be overridden by supplying the interval. <br /><br /> Required permissions: inventory:hosts:write
     * @summary Update staleness timestamps for a host matching the provided facts
     * @param {CreateCheckIn} createCheckIn Data required to create a check-in record for a host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostHostCheckin(createCheckIn: CreateCheckIn, options?: any) {
        return HostsApiFp(this.configuration).apiHostHostCheckin(createCheckIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merge one or multiple hosts facts under a namespace. <br /><br /> Required permissions: inventory:hosts:write
     * @summary Merge facts under a namespace
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {string} namespace A namespace of the merged facts.
     * @param {object} body A dictionary with the new facts to merge with the original ones.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update hosts <br /><br /> Required permissions: inventory:hosts:write
     * @summary Update hosts
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {PatchHostIn} patchHostIn A group of fields to be updated on the hosts
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostPatchHostById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostPatchHostById(hostIdList, patchHostIn, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace facts under a namespace <br /><br /> Required permissions: inventory:hosts:write
     * @summary Replace facts under a namespace
     * @param {Array<string>} hostIdList A comma-separated list of host IDs.
     * @param {string} namespace A namespace of the merged facts.
     * @param {object} body A dictionary with the new facts to replace the original ones.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResourceTypesApi - axios parameter creator
 * @export
 */
export const ResourceTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of groups in the current account. <br /><br /> Required permissions: rbac:*:*
         * @summary Get the list of inventory groups in resource-types format
         * @param {string} [name] Filter by group name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourceTypeGetResourceTypeGroupsList: async (name?: string, perPage?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource-types/inventory-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of available RBAC resource types. <br /><br /> Required permissions: rbac:*:*
         * @summary Get the list of resource types
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourceTypeGetResourceTypeList: async (perPage?: number, page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/resource-types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceTypesApi - functional programming interface
 * @export
 */
export const ResourceTypesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the list of groups in the current account. <br /><br /> Required permissions: rbac:*:*
         * @summary Get the list of inventory groups in resource-types format
         * @param {string} [name] Filter by group name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourceTypeGetResourceTypeGroupsList(name?: string, perPage?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceTypesGroupsQueryOutput>> {
            const localVarAxiosArgs = await ResourceTypesApiAxiosParamCreator(configuration).apiResourceTypeGetResourceTypeGroupsList(name, perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the list of available RBAC resource types. <br /><br /> Required permissions: rbac:*:*
         * @summary Get the list of resource types
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourceTypeGetResourceTypeList(perPage?: number, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceTypesQueryOutput>> {
            const localVarAxiosArgs = await ResourceTypesApiAxiosParamCreator(configuration).apiResourceTypeGetResourceTypeList(perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResourceTypesApi - factory interface
 * @export
 */
export const ResourceTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the list of groups in the current account. <br /><br /> Required permissions: rbac:*:*
         * @summary Get the list of inventory groups in resource-types format
         * @param {string} [name] Filter by group name
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourceTypeGetResourceTypeGroupsList(name?: string, perPage?: number, page?: number, options?: any): AxiosPromise<ResourceTypesGroupsQueryOutput> {
            return ResourceTypesApiFp(configuration).apiResourceTypeGetResourceTypeGroupsList(name, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of available RBAC resource types. <br /><br /> Required permissions: rbac:*:*
         * @summary Get the list of resource types
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourceTypeGetResourceTypeList(perPage?: number, page?: number, options?: any): AxiosPromise<ResourceTypesQueryOutput> {
            return ResourceTypesApiFp(configuration).apiResourceTypeGetResourceTypeList(perPage, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceTypesApi - object-oriented interface
 * @export
 * @class ResourceTypesApi
 * @extends {BaseAPI}
 */
export class ResourceTypesApi extends BaseAPI {
    /**
     * Returns the list of groups in the current account. <br /><br /> Required permissions: rbac:*:*
     * @summary Get the list of inventory groups in resource-types format
     * @param {string} [name] Filter by group name
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceTypesApi
     */
    public apiResourceTypeGetResourceTypeGroupsList(name?: string, perPage?: number, page?: number, options?: any) {
        return ResourceTypesApiFp(this.configuration).apiResourceTypeGetResourceTypeGroupsList(name, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of available RBAC resource types. <br /><br /> Required permissions: rbac:*:*
     * @summary Get the list of resource types
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceTypesApi
     */
    public apiResourceTypeGetResourceTypeList(perPage?: number, page?: number, options?: any) {
        return ResourceTypesApiFp(this.configuration).apiResourceTypeGetResourceTypeList(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SystemProfileApi - axios parameter creator
 * @export
 */
export const SystemProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all operating system versions and counts on the account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetOperatingSystem: async (tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system_profile/operating_system`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap sids values and counts on the account
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSids: async (search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system_profile/sap_sids`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap system values and counts on the account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSystem: async (tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/system_profile/sap_system`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates System Profile data from recent Kafka messages against a given spec, and compares it with the current one. Only HBI Admins can access this endpoint.
         * @summary validate system profile schema
         * @param {string} repoBranch The branch of the inventory-schemas repo to use
         * @param {string} [repoFork] The fork of the inventory-schemas repo to use
         * @param {number} [days] How many days worth of data to validate
         * @param {number} [maxMessages] Stops polling when this number of messages has been collected
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileValidateSchema: async (repoBranch: string, repoFork?: string, days?: number, maxMessages?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoBranch' is not null or undefined
            if (repoBranch === null || repoBranch === undefined) {
                throw new RequiredError('repoBranch','Required parameter repoBranch was null or undefined when calling apiSystemProfileValidateSchema.');
            }
            const localVarPath = `/system_profile/validate_schema`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (repoFork !== undefined) {
                localVarQueryParameter['repo_fork'] = repoFork;
            }

            if (repoBranch !== undefined) {
                localVarQueryParameter['repo_branch'] = repoBranch;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            if (maxMessages !== undefined) {
                localVarQueryParameter['max_messages'] = maxMessages;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemProfileApi - functional programming interface
 * @export
 */
export const SystemProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all operating system versions and counts on the account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileGetOperatingSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileOperatingSystemOut>> {
            const localVarAxiosArgs = await SystemProfileApiAxiosParamCreator(configuration).apiSystemProfileGetOperatingSystem(tags, perPage, page, staleness, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap sids values and counts on the account
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileSapSystemOut>> {
            const localVarAxiosArgs = await SystemProfileApiAxiosParamCreator(configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap system values and counts on the account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileSapSystemOut>> {
            const localVarAxiosArgs = await SystemProfileApiAxiosParamCreator(configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Validates System Profile data from recent Kafka messages against a given spec, and compares it with the current one. Only HBI Admins can access this endpoint.
         * @summary validate system profile schema
         * @param {string} repoBranch The branch of the inventory-schemas repo to use
         * @param {string} [repoFork] The fork of the inventory-schemas repo to use
         * @param {number} [days] How many days worth of data to validate
         * @param {number} [maxMessages] Stops polling when this number of messages has been collected
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemProfileValidateSchema(repoBranch: string, repoFork?: string, days?: number, maxMessages?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SystemProfileApiAxiosParamCreator(configuration).apiSystemProfileValidateSchema(repoBranch, repoFork, days, maxMessages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemProfileApi - factory interface
 * @export
 */
export const SystemProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all operating system versions and counts on the account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetOperatingSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<SystemProfileOperatingSystemOut> {
            return SystemProfileApiFp(configuration).apiSystemProfileGetOperatingSystem(tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap sids values and counts on the account
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<SystemProfileSapSystemOut> {
            return SystemProfileApiFp(configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions: inventory:hosts:read
         * @summary get all sap system values and counts on the account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<SystemProfileSapSystemOut> {
            return SystemProfileApiFp(configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates System Profile data from recent Kafka messages against a given spec, and compares it with the current one. Only HBI Admins can access this endpoint.
         * @summary validate system profile schema
         * @param {string} repoBranch The branch of the inventory-schemas repo to use
         * @param {string} [repoFork] The fork of the inventory-schemas repo to use
         * @param {number} [days] How many days worth of data to validate
         * @param {number} [maxMessages] Stops polling when this number of messages has been collected
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemProfileValidateSchema(repoBranch: string, repoFork?: string, days?: number, maxMessages?: number, options?: any): AxiosPromise<void> {
            return SystemProfileApiFp(configuration).apiSystemProfileValidateSchema(repoBranch, repoFork, days, maxMessages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemProfileApi - object-oriented interface
 * @export
 * @class SystemProfileApi
 * @extends {BaseAPI}
 */
export class SystemProfileApi extends BaseAPI {
    /**
     * Required permissions: inventory:hosts:read
     * @summary get all operating system versions and counts on the account
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
     * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemProfileApi
     */
    public apiSystemProfileGetOperatingSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any) {
        return SystemProfileApiFp(this.configuration).apiSystemProfileGetOperatingSystem(tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions: inventory:hosts:read
     * @summary get all sap sids values and counts on the account
     * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
     * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemProfileApi
     */
    public apiSystemProfileGetSapSids(search?: string, tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any) {
        return SystemProfileApiFp(this.configuration).apiSystemProfileGetSapSids(search, tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions: inventory:hosts:read
     * @summary get all sap system values and counts on the account
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
     * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemProfileApi
     */
    public apiSystemProfileGetSapSystem(tags?: Array<string>, perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any) {
        return SystemProfileApiFp(this.configuration).apiSystemProfileGetSapSystem(tags, perPage, page, staleness, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates System Profile data from recent Kafka messages against a given spec, and compares it with the current one. Only HBI Admins can access this endpoint.
     * @summary validate system profile schema
     * @param {string} repoBranch The branch of the inventory-schemas repo to use
     * @param {string} [repoFork] The fork of the inventory-schemas repo to use
     * @param {number} [days] How many days worth of data to validate
     * @param {number} [maxMessages] Stops polling when this number of messages has been collected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemProfileApi
     */
    public apiSystemProfileValidateSchema(repoBranch: string, repoFork?: string, days?: number, maxMessages?: number, options?: any) {
        return SystemProfileApiFp(this.configuration).apiSystemProfileValidateSchema(repoBranch, repoFork, days, maxMessages, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags: async (tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-rh-identity")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider_id'] = providerId;
            }

            if (providerType !== undefined) {
                localVarQueryParameter['provider_type'] = providerType;
            }

            if (updatedStart !== undefined) {
                localVarQueryParameter['updated_start'] = (updatedStart as any instanceof Date) ?
                    (updatedStart as any).toISOString() :
                    updatedStart;
            }

            if (updatedEnd !== undefined) {
                localVarQueryParameter['updated_end'] = (updatedEnd as any instanceof Date) ?
                    (updatedEnd as any).toISOString() :
                    updatedEnd;
            }

            if (groupName) {
                localVarQueryParameter['group_name'] = groupName;
            }

            if (registeredWith) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveTags>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, registeredWith, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Required permissions: inventory:hosts:read
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
         * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
         * @param {string} [displayName] Filter by display_name (case-insensitive)
         * @param {string} [fqdn] Filter by FQDN (case-insensitive)
         * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
         * @param {string} [insightsId] Filter by insights_id
         * @param {string} [providerId] Filter by provider_id
         * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
         * @param {string} [updatedStart] Only show hosts last modified after the given date
         * @param {string} [updatedEnd] Only show hosts last modified before the given date
         * @param {Array<string>} [groupName] Filter by group name
         * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
         * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any): AxiosPromise<ActiveTags> {
            return TagsApiFp(configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, registeredWith, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Required permissions: inventory:hosts:read
     * @summary Get the active host tags for a given account
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {'tag' | 'count'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh, stale and stale_warning
     * @param {string} [search] Used for searching tags and sap_sids that match the given search string. For searching tags, a tag\&#39;s namespace, key, and/or value is used for matching.
     * @param {string} [displayName] Filter by display_name (case-insensitive)
     * @param {string} [fqdn] Filter by FQDN (case-insensitive)
     * @param {string} [hostnameOrId] Filter by display_name, fqdn, id (case-insensitive)
     * @param {string} [insightsId] Filter by insights_id
     * @param {string} [providerId] Filter by provider_id
     * @param {'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm'} [providerType] Filter by provider_type
     * @param {string} [updatedStart] Only show hosts last modified after the given date
     * @param {string} [updatedEnd] Only show hosts last modified before the given date
     * @param {Array<string>} [groupName] Filter by group name
     * @param {Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>} [registeredWith] Filters out any host not registered by the specified reporters
     * @param {{ [key: string]: object; }} [filter] Filters hosts based on system_profile fields. For example: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;sap_system\&quot;: {\&quot;eq\&quot;: \&quot;true\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][sap_system][eq]&#x3D;true\&quot; &lt;br /&gt;&lt;br /&gt; To get \&quot;edge\&quot; hosts, use this explicit filter: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{\&quot;system_profile\&quot;: {\&quot;host_type\&quot;: {\&quot;eq\&quot;: \&quot;edge\&quot;}}} &lt;br /&gt;&lt;br /&gt; which equates to the URL param: &lt;br /&gt;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\&quot;?filter[system_profile][host_type][eq]&#x3D;edge\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, providerId?: string, providerType?: 'alibaba' | 'aws' | 'azure' | 'gcp' | 'ibm', updatedStart?: string, updatedEnd?: string, groupName?: Array<string>, registeredWith?: Array<'insights' | 'yupana' | 'satellite' | 'discovery' | 'puptoo' | 'rhsm-conduit' | 'cloud-connector' | '!yupana' | '!satellite' | '!discovery' | '!puptoo' | '!rhsm-conduit' | '!cloud-connector'>, filter?: { [key: string]: object; }, options?: any) {
        return TagsApiFp(this.configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, displayName, fqdn, hostnameOrId, insightsId, providerId, providerType, updatedStart, updatedEnd, groupName, registeredWith, filter, options).then((request) => request(this.axios, this.basePath));
    }

}


