// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Insights Host Inventory REST Interface
 * REST interface for the Insights Platform Host Inventory application.
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface BulkHostOut
 */
export interface BulkHostOut {
    /**
     * Total number of items in the \"data\" list.
     * @type {number}
     * @memberof BulkHostOut
     */
    total?: number;
    /**
     * Number of items in the \"data\" list that contain errors.
     * @type {number}
     * @memberof BulkHostOut
     */
    errors?: number;
    /**
     * List of hosts that were created, updated or failed to be processed.
     * @type {Array<BulkHostOutDetails>}
     * @memberof BulkHostOut
     */
    data?: Array<BulkHostOutDetails>;
}

/**
 *
 * @export
 * @interface BulkHostOutDetails
 */
export interface BulkHostOutDetails {
    /**
     * HTTP status code of the results of the host create/update process
     * @type {number}
     * @memberof BulkHostOutDetails
     */
    status?: number;
    /**
     *
     * @type {CreateHostOut}
     * @memberof BulkHostOutDetails
     */
    host?: CreateHostOut;
    /**
     * Short description of why a host failed to be created or updated.
     * @type {string}
     * @memberof BulkHostOutDetails
     */
    title?: string;
    /**
     * Details about why a host failed to be created or updated.
     * @type {string}
     * @memberof BulkHostOutDetails
     */
    detail?: string;
}

/**
 * Data of a single host belonging to an account. Represents the hosts without its Inventory metadata.
 * @export
 * @interface CreateHostIn
 */
export interface CreateHostIn {
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof CreateHostIn
     */
    displayName?: string;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof CreateHostIn
     */
    ansibleHost?: string;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof CreateHostIn
     */
    account: string;
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    insightsId?: string;
    /**
     * A Machine ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    rhelMachineId?: string;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    subscriptionManagerId?: string;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    satelliteId?: string;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    biosUuid?: string;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostIn
     */
    ipAddresses?: Array<string>;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    fqdn?: string;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostIn
     */
    macAddresses?: Array<string>;
    /**
     * Host’s reference in the external source e.g. AWS EC2, Azure, OpenStack, etc. This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    externalId?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof CreateHostIn
     */
    facts?: Array<FactSet>;
    /**
     *
     * @type {SystemProfileIn}
     * @memberof CreateHostIn
     */
    systemProfile?: SystemProfileIn;
}

/**
 * Data of a single host belonging to an account. Represents the hosts without its Inventory metadata.
 * @export
 * @interface CreateHostOut
 */
export interface CreateHostOut {
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof CreateHostOut
     */
    displayName?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof CreateHostOut
     */
    ansibleHost?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof CreateHostOut
     */
    account: string;
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    insightsId?: string | null;
    /**
     * A Machine ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    rhelMachineId?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    subscriptionManagerId?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    satelliteId?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    biosUuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostOut
     */
    ipAddresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostOut
     */
    macAddresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. AWS EC2, Azure, OpenStack, etc. This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    externalId?: string | null;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof CreateHostOut
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {Date}
     * @memberof CreateHostOut
     */
    created?: Date;
    /**
     * A timestamp when the entry was last updated.
     * @type {Date}
     * @memberof CreateHostOut
     */
    updated?: Date;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof CreateHostOut
     */
    facts?: Array<FactSet>;
}

/**
 * Representation of one mounted device
 * @export
 * @interface DiskDevice
 */
export interface DiskDevice {
    /**
     *
     * @type {string}
     * @memberof DiskDevice
     */
    device?: string;
    /**
     * user-defined mount label
     * @type {string}
     * @memberof DiskDevice
     */
    label?: string;
    /**
     *
     * @type {DiskDeviceOptions}
     * @memberof DiskDevice
     */
    options?: DiskDeviceOptions;
    /**
     * mount point
     * @type {string}
     * @memberof DiskDevice
     */
    mountPoint?: string;
    /**
     * mount type
     * @type {string}
     * @memberof DiskDevice
     */
    type?: string;
}

/**
 * mount options
 * @export
 * @interface DiskDeviceOptions
 */
export interface DiskDeviceOptions {
    /**
     *
     * @type {string}
     * @memberof DiskDeviceOptions
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof DiskDeviceOptions
     */
    value?: string;
}

/**
 * A set of string facts belonging to a single namespace.
 * @export
 * @interface FactSet
 */
export interface FactSet {
    /**
     * A namespace the facts belong to.
     * @type {string}
     * @memberof FactSet
     */
    namespace: string;
    /**
     * The facts themselves.
     * @type {any}
     * @memberof FactSet
     */
    facts: any;
}

/**
 * A database entry representing a single host with its Inventory metadata.
 * @export
 * @interface HostOut
 */
export interface HostOut {
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof HostOut
     */
    displayName?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof HostOut
     */
    ansibleHost?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof HostOut
     */
    account: string;
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    insightsId?: string | null;
    /**
     * A Machine ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    rhelMachineId?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    subscriptionManagerId?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    satelliteId?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    biosUuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof HostOut
     */
    ipAddresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof HostOut
     */
    macAddresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. AWS EC2, Azure, OpenStack, etc. This field is considered to be a canonical fact.
     * @type {string}
     * @memberof HostOut
     */
    externalId?: string | null;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof HostOut
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {Date}
     * @memberof HostOut
     */
    created?: Date;
    /**
     * A timestamp when the entry was last updated.
     * @type {Date}
     * @memberof HostOut
     */
    updated?: Date;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOut
     */
    facts?: Array<FactSet>;
}

/**
 * A paginated host search query result with host entries and their Inventory metadata.
 * @export
 * @interface HostQueryOutput
 */
export interface HostQueryOutput {
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof HostQueryOutput
     */
    count: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof HostQueryOutput
     */
    page: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof HostQueryOutput
     */
    perPage: number;
    /**
     * A total count of the found entries.
     * @type {number}
     * @memberof HostQueryOutput
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostOut>}
     * @memberof HostQueryOutput
     */
    results: Array<HostOut>;
}

/**
 * Individual host record that contains only the host id and system profile
 * @export
 * @interface HostSystemProfileOut
 */
export interface HostSystemProfileOut {
    /**
     *
     * @type {string}
     * @memberof HostSystemProfileOut
     */
    id?: string;
    /**
     *
     * @type {SystemProfileIn}
     * @memberof HostSystemProfileOut
     */
    systemProfile?: SystemProfileIn;
}

/**
 * Representation of one installed product
 * @export
 * @interface InstalledProduct
 */
export interface InstalledProduct {
    /**
     *
     * @type {string}
     * @memberof InstalledProduct
     */
    name?: string;
    /**
     * the product ID
     * @type {string}
     * @memberof InstalledProduct
     */
    id?: string;
    /**
     * subscription status for product
     * @type {string}
     * @memberof InstalledProduct
     */
    status?: string;
}

/**
 * Representation of one network interface
 * @export
 * @interface NetworkInterface
 */
export interface NetworkInterface {
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv4Addresses?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv6Addresses?: Array<string>;
    /**
     * MTU
     * @type {number}
     * @memberof NetworkInterface
     */
    mtu?: number;
    /**
     * MAC address
     * @type {string}
     * @memberof NetworkInterface
     */
    macAddress?: string;
    /**
     * name of interface
     * @type {string}
     * @memberof NetworkInterface
     */
    name?: string;
    /**
     * interface state
     * @type {string}
     * @memberof NetworkInterface
     */
    state?: string;
    /**
     * interface type
     * @type {string}
     * @memberof NetworkInterface
     */
    type?: string;
}

/**
 * Data of a single host to be updated.
 * @export
 * @interface PatchHostIn
 */
export interface PatchHostIn {
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof PatchHostIn
     */
    ansibleHost?: string;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof PatchHostIn
     */
    displayName?: string;
}

/**
 * Structure of the output of the host system profile query
 * @export
 * @interface SystemProfileByHostOut
 */
export interface SystemProfileByHostOut {
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    count: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    page: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    perPage: number;
    /**
     * A total count of the found entries.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostSystemProfileOut>}
     * @memberof SystemProfileByHostOut
     */
    results: Array<HostSystemProfileOut>;
}

/**
 * Representation of the system profile fields
 * @export
 * @interface SystemProfileIn
 */
export interface SystemProfileIn {
    /**
     *
     * @type {number}
     * @memberof SystemProfileIn
     */
    numberOfCpus?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfileIn
     */
    numberOfSockets?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfileIn
     */
    coresPerSocket?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfileIn
     */
    systemMemoryBytes?: number;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    infrastructureType?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    infrastructureVendor?: string;
    /**
     *
     * @type {Array<NetworkInterface>}
     * @memberof SystemProfileIn
     */
    networkInterfaces?: Array<NetworkInterface>;
    /**
     *
     * @type {Array<DiskDevice>}
     * @memberof SystemProfileIn
     */
    diskDevices?: Array<DiskDevice>;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    biosVendor?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    biosVersion?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    biosReleaseDate?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileIn
     */
    cpuFlags?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    osRelease?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    osKernelVersion?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    arch?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileIn
     */
    kernelModules?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof SystemProfileIn
     */
    lastBootTime?: Date;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileIn
     */
    runningProcesses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    subscriptionStatus?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    subscriptionAutoAttach?: string;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfileIn
     */
    katelloAgentRunning?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfileIn
     */
    satelliteManaged?: boolean;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    cloudProvider?: string;
    /**
     *
     * @type {Array<YumRepo>}
     * @memberof SystemProfileIn
     */
    yumRepos?: Array<YumRepo>;
    /**
     *
     * @type {Array<InstalledProduct>}
     * @memberof SystemProfileIn
     */
    installedProducts?: Array<InstalledProduct>;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    insightsClientVersion?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfileIn
     */
    insightsEggVersion?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileIn
     */
    installedPackages?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileIn
     */
    installedServices?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfileIn
     */
    enabledServices?: Array<string>;
}

/**
 * Representation of one yum repository
 * @export
 * @interface YumRepo
 */
export interface YumRepo {
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    gpgcheck?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    baseurl?: string;
}


/**
 * HostsApi - axios parameter creator
 * @export
 */
export const HostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new host and add it to the host list or update an existing hosts. A host is updated if there is already one with the same canonicals facts and belonging to the same account.
         * @summary Create/update multiple host and add them to the host list
         * @param {Array<CreateHostIn>} createHostIn A list of host objects to be added to the host list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostAddHostList(createHostIn: Array<CreateHostIn>, options: any = {}): RequestArgs {
            // verify required parameter 'createHostIn' is not null or undefined
            if (createHostIn === null || createHostIn === undefined) {
                throw new RequiredError('createHostIn','Required parameter createHostIn was null or undefined when calling apiHostAddHostList.');
            }
            const localVarPath = `/hosts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-rh-identity")
					: configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;CreateHostIn&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHostIn || {}) : (createHostIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete hosts by IDs
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById(hostIdList: Array<string>, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostDeleteById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-rh-identity")
					: configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID.
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-rh-identity")
					: configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all hosts available to the account.
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, options: any = {}): RequestArgs {
            const localVarPath = `/hosts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-rh-identity")
					: configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostSystemProfileById.');
            }
            const localVarPath = `/hosts/{host_id_list}/system_profile`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-rh-identity")
					: configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace.
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList IDs of the hosts that own the facts to be merged.
         * @param {string} namespace A namespace of the merged facts.
         * @param {any} body A dictionary with the new facts to merge with the original ones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: any, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostMergeFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-rh-identity")
					: configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a host
         * @summary Update a host
         * @param {Array<string>} hostIdList A host ID
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostPatchById.');
            }
            // verify required parameter 'patchHostIn' is not null or undefined
            if (patchHostIn === null || patchHostIn === undefined) {
                throw new RequiredError('patchHostIn','Required parameter patchHostIn was null or undefined when calling apiHostPatchById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-rh-identity")
					: configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchHostIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchHostIn || {}) : (patchHostIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace facts under a namespace
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList IDs of the hosts that own the facts to be replaced.
         * @param {string} namespace A namespace of the merged facts.
         * @param {any} body A dictionary with the new facts to replace the original ones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: any, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostReplaceFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-rh-identity")
					: configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostsApi - functional programming interface
 * @export
 */
export const HostsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new host and add it to the host list or update an existing hosts. A host is updated if there is already one with the same canonicals facts and belonging to the same account.
         * @summary Create/update multiple host and add them to the host list
         * @param {Array<CreateHostIn>} createHostIn A list of host objects to be added to the host list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostAddHostList(createHostIn: Array<CreateHostIn>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkHostOut> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostAddHostList(createHostIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete hosts by IDs
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById(hostIdList: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostDeleteById(hostIdList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID.
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all hosts available to the account.
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileByHostOut> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace.
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList IDs of the hosts that own the facts to be merged.
         * @param {string} namespace A namespace of the merged facts.
         * @param {any} body A dictionary with the new facts to merge with the original ones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostMergeFacts(hostIdList, namespace, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a host
         * @summary Update a host
         * @param {Array<string>} hostIdList A host ID
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace facts under a namespace
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList IDs of the hosts that own the facts to be replaced.
         * @param {string} namespace A namespace of the merged facts.
         * @param {any} body A dictionary with the new facts to replace the original ones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostReplaceFacts(hostIdList, namespace, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HostsApi - factory interface
 * @export
 */
export const HostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new host and add it to the host list or update an existing hosts. A host is updated if there is already one with the same canonicals facts and belonging to the same account.
         * @summary Create/update multiple host and add them to the host list
         * @param {Array<CreateHostIn>} createHostIn A list of host objects to be added to the host list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostAddHostList(createHostIn: Array<CreateHostIn>, options?: any) {
            return HostsApiFp(configuration).apiHostAddHostList(createHostIn, options)(axios, basePath);
        },
        /**
         * Delete hosts by IDs
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById(hostIdList: Array<string>, options?: any) {
            return HostsApiFp(configuration).apiHostDeleteById(hostIdList, options)(axios, basePath);
        },
        /**
         * Find one or more hosts by their ID.
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, options?: any) {
            return HostsApiFp(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, options)(axios, basePath);
        },
        /**
         * Read the entire list of all hosts available to the account.
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, options?: any) {
            return HostsApiFp(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, options)(axios, basePath);
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, options?: any) {
            return HostsApiFp(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, options)(axios, basePath);
        },
        /**
         * Merge one or multiple hosts facts under a namespace.
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList IDs of the hosts that own the facts to be merged.
         * @param {string} namespace A namespace of the merged facts.
         * @param {any} body A dictionary with the new facts to merge with the original ones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: any, options?: any) {
            return HostsApiFp(configuration).apiHostMergeFacts(hostIdList, namespace, body, options)(axios, basePath);
        },
        /**
         * Update a host
         * @summary Update a host
         * @param {Array<string>} hostIdList A host ID
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any) {
            return HostsApiFp(configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options)(axios, basePath);
        },
        /**
         * Replace facts under a namespace
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList IDs of the hosts that own the facts to be replaced.
         * @param {string} namespace A namespace of the merged facts.
         * @param {any} body A dictionary with the new facts to replace the original ones.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: any, options?: any) {
            return HostsApiFp(configuration).apiHostReplaceFacts(hostIdList, namespace, body, options)(axios, basePath);
        },
    };
};

/**
 * HostsApi - object-oriented interface
 * @export
 * @class HostsApi
 * @extends {BaseAPI}
 */
export class HostsApi extends BaseAPI {
    /**
     * Create a new host and add it to the host list or update an existing hosts. A host is updated if there is already one with the same canonicals facts and belonging to the same account.
     * @summary Create/update multiple host and add them to the host list
     * @param {Array<CreateHostIn>} createHostIn A list of host objects to be added to the host list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostAddHostList(createHostIn: Array<CreateHostIn>, options?: any) {
        return HostsApiFp(this.configuration).apiHostAddHostList(createHostIn, options)(this.axios, this.basePath);
    }

    /**
     * Delete hosts by IDs
     * @summary Delete hosts by IDs
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteById(hostIdList: Array<string>, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteById(hostIdList, options)(this.axios, this.basePath);
    }

    /**
     * Find one or more hosts by their ID.
     * @summary Find hosts by their IDs
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, options)(this.axios, this.basePath);
    }

    /**
     * Read the entire list of all hosts available to the account.
     * @summary Read the entire list of hosts
     * @param {string} [displayName] A part of a searched host’s display name.
     * @param {string} [fqdn] Filter by a host&#39;s FQDN
     * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
     * @param {string} [insightsId] Search for a host by insights_id
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, options)(this.axios, this.basePath);
    }

    /**
     * Find one or more hosts by their ID and return the id and system profile
     * @summary Return one or more hosts system profile
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, options)(this.axios, this.basePath);
    }

    /**
     * Merge one or multiple hosts facts under a namespace.
     * @summary Merge facts under a namespace
     * @param {Array<string>} hostIdList IDs of the hosts that own the facts to be merged.
     * @param {string} namespace A namespace of the merged facts.
     * @param {any} body A dictionary with the new facts to merge with the original ones.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: any, options?: any) {
        return HostsApiFp(this.configuration).apiHostMergeFacts(hostIdList, namespace, body, options)(this.axios, this.basePath);
    }

    /**
     * Update a host
     * @summary Update a host
     * @param {Array<string>} hostIdList A host ID
     * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options)(this.axios, this.basePath);
    }

    /**
     * Replace facts under a namespace
     * @summary Replace facts under a namespace
     * @param {Array<string>} hostIdList IDs of the hosts that own the facts to be replaced.
     * @param {string} namespace A namespace of the merged facts.
     * @param {any} body A dictionary with the new facts to replace the original ones.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: any, options?: any) {
        return HostsApiFp(this.configuration).apiHostReplaceFacts(hostIdList, namespace, body, options)(this.axios, this.basePath);
    }

}

