// tslint:disable
/**
 * Insights Host Inventory REST Interface
 * REST interface for the Insights Platform Host Inventory application.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Information about a host tag
 * @export
 * @interface ActiveTag
 */
export interface ActiveTag {
    /**
     *
     * @type {StructuredTag}
     * @memberof ActiveTag
     */
    tag: StructuredTag;
    /**
     * The number of hosts with the given tag. If the value is null this indicates that the count is unknown.
     * @type {number}
     * @memberof ActiveTag
     */
    count: number | null;
}
/**
 *
 * @export
 * @interface ActiveTags
 */
export interface ActiveTags {
    /**
     * Total number of items
     * @type {number}
     * @memberof ActiveTags
     */
    total: number;
    /**
     * The number of items on the current page
     * @type {number}
     * @memberof ActiveTags
     */
    count: number;
    /**
     * The page number
     * @type {number}
     * @memberof ActiveTags
     */
    page: number;
    /**
     * The number of items to return per page
     * @type {number}
     * @memberof ActiveTags
     */
    per_page: number;
    /**
     *
     * @type {Array<ActiveTag>}
     * @memberof ActiveTags
     */
    results: Array<ActiveTag>;
}
/**
 *
 * @export
 * @interface BulkHostOut
 */
export interface BulkHostOut {
    /**
     * Total number of items in the \"data\" list.
     * @type {number}
     * @memberof BulkHostOut
     */
    total?: number;
    /**
     * Number of items in the \"data\" list that contain errors.
     * @type {number}
     * @memberof BulkHostOut
     */
    errors?: number;
    /**
     * List of hosts that were created, updated or failed to be processed.
     * @type {Array<BulkHostOutDetails>}
     * @memberof BulkHostOut
     */
    data?: Array<BulkHostOutDetails>;
}
/**
 *
 * @export
 * @interface BulkHostOutDetails
 */
export interface BulkHostOutDetails {
    /**
     * HTTP status code of the results of the host create/update process
     * @type {number}
     * @memberof BulkHostOutDetails
     */
    status?: number;
    /**
     *
     * @type {CreateHostOut}
     * @memberof BulkHostOutDetails
     */
    host?: CreateHostOut;
    /**
     * Short description of why a host failed to be created or updated.
     * @type {string}
     * @memberof BulkHostOutDetails
     */
    title?: string;
    /**
     * Details about why a host failed to be created or updated.
     * @type {string}
     * @memberof BulkHostOutDetails
     */
    detail?: string;
}
/**
 * Data of a single host belonging to an account. Represents the hosts without its Inventory metadata.
 * @export
 * @interface CreateHostIn
 */
export interface CreateHostIn {
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof CreateHostIn
     */
    display_name?: string;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof CreateHostIn
     */
    ansible_host?: string;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof CreateHostIn
     */
    account: string;
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    insights_id?: string;
    /**
     * A Machine ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    rhel_machine_id?: string;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    subscription_manager_id?: string;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    satellite_id?: string;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    bios_uuid?: string;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostIn
     */
    ip_addresses?: Array<string>;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    fqdn?: string;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostIn
     */
    mac_addresses?: Array<string>;
    /**
     * Host’s reference in the external source e.g. AWS EC2, Azure, OpenStack, etc. This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostIn
     */
    external_id?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof CreateHostIn
     */
    facts?: Array<FactSet>;
    /**
     *
     * @type {SystemProfile}
     * @memberof CreateHostIn
     */
    system_profile?: SystemProfile;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof CreateHostIn
     */
    stale_timestamp: string;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof CreateHostIn
     */
    reporter: string;
}
/**
 * Data of a single host belonging to an account. Represents the hosts without its Inventory metadata.
 * @export
 * @interface CreateHostOut
 */
export interface CreateHostOut {
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof CreateHostOut
     */
    display_name?: string | null;
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof CreateHostOut
     */
    ansible_host?: string | null;
    /**
     * A Red Hat Account number that owns the host.
     * @type {string}
     * @memberof CreateHostOut
     */
    account: string;
    /**
     * An ID defined in /etc/insights-client/machine-id. This field is considered a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    insights_id?: string | null;
    /**
     * A Machine ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    rhel_machine_id?: string | null;
    /**
     * A Red Hat Subcription Manager ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    subscription_manager_id?: string | null;
    /**
     * A Red Hat Satellite ID of a RHEL host.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    satellite_id?: string | null;
    /**
     * A UUID of the host machine BIOS.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    bios_uuid?: string | null;
    /**
     * Host’s network IP addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostOut
     */
    ip_addresses?: Array<string> | null;
    /**
     * A host’s Fully Qualified Domain Name.  This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    fqdn?: string | null;
    /**
     * Host’s network interfaces MAC addresses.  This field is considered to be a canonical fact.
     * @type {Array<string>}
     * @memberof CreateHostOut
     */
    mac_addresses?: Array<string> | null;
    /**
     * Host’s reference in the external source e.g. AWS EC2, Azure, OpenStack, etc. This field is considered to be a canonical fact.
     * @type {string}
     * @memberof CreateHostOut
     */
    external_id?: string | null;
    /**
     * A durable and reliable platform-wide host identifier. Applications should use this identifier to reference hosts.
     * @type {string}
     * @memberof CreateHostOut
     */
    id?: string;
    /**
     * A timestamp when the entry was created.
     * @type {string}
     * @memberof CreateHostOut
     */
    created?: string;
    /**
     * A timestamp when the entry was last updated.
     * @type {string}
     * @memberof CreateHostOut
     */
    updated?: string;
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof CreateHostOut
     */
    facts?: Array<FactSet>;
    /**
     * Timestamp from which the host is considered stale.
     * @type {string}
     * @memberof CreateHostOut
     */
    stale_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered too stale to be listed without an explicit toggle.
     * @type {string}
     * @memberof CreateHostOut
     */
    stale_warning_timestamp?: string | null;
    /**
     * Timestamp from which the host is considered deleted.
     * @type {string}
     * @memberof CreateHostOut
     */
    culled_timestamp?: string | null;
    /**
     * Reporting source of the host. Used when updating the stale_timestamp.
     * @type {string}
     * @memberof CreateHostOut
     */
    reporter?: string | null;
}
/**
 * Representation of one mounted device
 * @export
 * @interface DiskDevice
 */
export interface DiskDevice {
    /**
     *
     * @type {string}
     * @memberof DiskDevice
     */
    device?: string;
    /**
     * user-defined mount label
     * @type {string}
     * @memberof DiskDevice
     */
    label?: string;
    /**
     *
     * @type {DiskDeviceOptions}
     * @memberof DiskDevice
     */
    options?: DiskDeviceOptions;
    /**
     * mount point
     * @type {string}
     * @memberof DiskDevice
     */
    mount_point?: string;
    /**
     * mount type
     * @type {string}
     * @memberof DiskDevice
     */
    type?: string;
}
/**
 * mount options
 * @export
 * @interface DiskDeviceOptions
 */
export interface DiskDeviceOptions {
    /**
     *
     * @type {string}
     * @memberof DiskDeviceOptions
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof DiskDeviceOptions
     */
    value?: string;
}
/**
 * Representation of one DNF module
 * @export
 * @interface DnfModule
 */
export interface DnfModule {
    /**
     *
     * @type {string}
     * @memberof DnfModule
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof DnfModule
     */
    stream?: string;
}
/**
 * A set of string facts belonging to a single namespace.
 * @export
 * @interface FactSet
 */
export interface FactSet {
    /**
     * A namespace the facts belong to.
     * @type {string}
     * @memberof FactSet
     */
    namespace: string;
    /**
     * The facts themselves.
     * @type {object}
     * @memberof FactSet
     */
    facts: object;
}
/**
 * A database entry representing a single host with its Inventory metadata.
 * @export
 * @interface HostOut
 */
export interface HostOut extends CreateHostOut {
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOut
     */
    facts?: Array<FactSet>;
}
/**
 *
 * @export
 * @interface HostOutAllOf
 */
export interface HostOutAllOf {
    /**
     * A set of facts belonging to the host.
     * @type {Array<FactSet>}
     * @memberof HostOutAllOf
     */
    facts?: Array<FactSet>;
}
/**
 * A paginated host search query result with host entries and their Inventory metadata.
 * @export
 * @interface HostQueryOutput
 */
export interface HostQueryOutput {
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof HostQueryOutput
     */
    count: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof HostQueryOutput
     */
    page: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof HostQueryOutput
     */
    per_page: number;
    /**
     * A total count of the found entries.
     * @type {number}
     * @memberof HostQueryOutput
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostOut>}
     * @memberof HostQueryOutput
     */
    results: Array<HostOut>;
}
/**
 * Individual host record that contains only the host id and system profile
 * @export
 * @interface HostSystemProfileOut
 */
export interface HostSystemProfileOut {
    /**
     *
     * @type {string}
     * @memberof HostSystemProfileOut
     */
    id?: string;
    /**
     *
     * @type {SystemProfile}
     * @memberof HostSystemProfileOut
     */
    system_profile?: SystemProfile;
}
/**
 * Representation of one installed product
 * @export
 * @interface InstalledProduct
 */
export interface InstalledProduct {
    /**
     *
     * @type {string}
     * @memberof InstalledProduct
     */
    name?: string;
    /**
     * the product ID
     * @type {string}
     * @memberof InstalledProduct
     */
    id?: string;
    /**
     * subscription status for product
     * @type {string}
     * @memberof InstalledProduct
     */
    status?: string;
}
/**
 * Representation of one network interface
 * @export
 * @interface NetworkInterface
 */
export interface NetworkInterface {
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv4_addresses?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof NetworkInterface
     */
    ipv6_addresses?: Array<string>;
    /**
     * MTU
     * @type {number}
     * @memberof NetworkInterface
     */
    mtu?: number;
    /**
     * MAC address (with or without colons)
     * @type {string}
     * @memberof NetworkInterface
     */
    mac_address?: string;
    /**
     * name of interface
     * @type {string}
     * @memberof NetworkInterface
     */
    name?: string;
    /**
     * interface state (UP, DOWN, UNKNOWN)
     * @type {string}
     * @memberof NetworkInterface
     */
    state?: string;
    /**
     * interface type (ether, loopback)
     * @type {string}
     * @memberof NetworkInterface
     */
    type?: string;
}
/**
 * Data of a single host to be updated.
 * @export
 * @interface PatchHostIn
 */
export interface PatchHostIn {
    /**
     * The ansible host name for remediations
     * @type {string}
     * @memberof PatchHostIn
     */
    ansible_host?: string;
    /**
     * A host’s human-readable display name, e.g. in a form of a domain name.
     * @type {string}
     * @memberof PatchHostIn
     */
    display_name?: string;
}
/**
 *
 * @export
 * @interface StructuredTag
 */
export interface StructuredTag {
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    namespace?: string | null;
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof StructuredTag
     */
    value?: string | null;
}
/**
 * Representation of the system profile fields
 * @export
 * @interface SystemProfile
 */
export interface SystemProfile {
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    number_of_cpus?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    number_of_sockets?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    cores_per_socket?: number;
    /**
     *
     * @type {number}
     * @memberof SystemProfile
     */
    system_memory_bytes?: number;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    infrastructure_type?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    infrastructure_vendor?: string;
    /**
     *
     * @type {Array<NetworkInterface>}
     * @memberof SystemProfile
     */
    network_interfaces?: Array<NetworkInterface>;
    /**
     *
     * @type {Array<DiskDevice>}
     * @memberof SystemProfile
     */
    disk_devices?: Array<DiskDevice>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_vendor?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    bios_release_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    cpu_flags?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    os_release?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    os_kernel_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    arch?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    kernel_modules?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    last_boot_time?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    running_processes?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    subscription_status?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    subscription_auto_attach?: string;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfile
     */
    katello_agent_running?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof SystemProfile
     */
    satellite_managed?: boolean;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    cloud_provider?: string;
    /**
     *
     * @type {Array<YumRepo>}
     * @memberof SystemProfile
     */
    yum_repos?: Array<YumRepo>;
    /**
     *
     * @type {Array<DnfModule>}
     * @memberof SystemProfile
     */
    dnf_modules?: Array<DnfModule>;
    /**
     *
     * @type {Array<InstalledProduct>}
     * @memberof SystemProfile
     */
    installed_products?: Array<InstalledProduct>;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    insights_client_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    insights_egg_version?: string;
    /**
     *
     * @type {string}
     * @memberof SystemProfile
     */
    captured_date?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_packages?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    installed_services?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SystemProfile
     */
    enabled_services?: Array<string>;
}
/**
 * Structure of the output of the host system profile query
 * @export
 * @interface SystemProfileByHostOut
 */
export interface SystemProfileByHostOut {
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    count: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    page: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    per_page: number;
    /**
     * A total count of the found entries.
     * @type {number}
     * @memberof SystemProfileByHostOut
     */
    total: number;
    /**
     * Actual host search query result entries.
     * @type {Array<HostSystemProfileOut>}
     * @memberof SystemProfileByHostOut
     */
    results: Array<HostSystemProfileOut>;
}
/**
 *
 * @export
 * @interface TagCountOut
 */
export interface TagCountOut {
    /**
     * Total number of items in the \"data\" list.
     * @type {number}
     * @memberof TagCountOut
     */
    total?: number;
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof TagCountOut
     */
    count?: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof TagCountOut
     */
    page?: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof TagCountOut
     */
    per_page?: number;
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: number; }}
     * @memberof TagCountOut
     */
    results?: { [key: string]: number; };
}
/**
 *
 * @export
 * @interface TagsOut
 */
export interface TagsOut {
    /**
     * Total number of items in the \"data\" list.
     * @type {number}
     * @memberof TagsOut
     */
    total?: number;
    /**
     * A number of entries on the current page.
     * @type {number}
     * @memberof TagsOut
     */
    count?: number;
    /**
     * A current page number.
     * @type {number}
     * @memberof TagsOut
     */
    page?: number;
    /**
     * A page size – a number of entries per single page.
     * @type {number}
     * @memberof TagsOut
     */
    per_page?: number;
    /**
     * The list of tags on the systems
     * @type {{ [key: string]: Array<StructuredTag>; }}
     * @memberof TagsOut
     */
    results?: { [key: string]: Array<StructuredTag>; };
}
/**
 * Representation of one yum repository
 * @export
 * @interface YumRepo
 */
export interface YumRepo {
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    gpgcheck?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof YumRepo
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof YumRepo
     */
    baseurl?: string;
}

/**
 * HostsApi - axios parameter creator
 * @export
 */
export const HostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new host and add it to the host list or update an existing hosts. A host is updated if there is already one with the same canonicals facts and belonging to the same account. <br /><br /> NOTICE: This operation is deprecated. The explicit creation of hosts is no longer supported. Hosts are created automatically based on uploads processed by the [payload ingress service](/docs/api/ingress#operations-default-post_upload) instead.
         * @summary Create/update multiple host and add them to the host list
         * @param {Array<CreateHostIn>} createHostIn A list of host objects to be added to the host list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostAddHostList(createHostIn: Array<CreateHostIn>, options: any = {}): RequestArgs {
            // verify required parameter 'createHostIn' is not null or undefined
            if (createHostIn === null || createHostIn === undefined) {
                throw new RequiredError('createHostIn','Required parameter createHostIn was null or undefined when calling apiHostAddHostList.');
            }
            const localVarPath = `/hosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createHostIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createHostIn !== undefined ? createHostIn : {}) : (createHostIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete hosts by IDs
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostDeleteById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID.
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the entire list of all hosts available to the account.
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host\&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: 'insights', options: any = {}): RequestArgs {
            const localVarPath = `/hosts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (fqdn !== undefined) {
                localVarQueryParameter['fqdn'] = fqdn;
            }

            if (hostnameOrId !== undefined) {
                localVarQueryParameter['hostname_or_id'] = hostnameOrId;
            }

            if (insightsId !== undefined) {
                localVarQueryParameter['insights_id'] = insightsId;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (registeredWith !== undefined) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', branchId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostSystemProfileById.');
            }
            const localVarPath = `/hosts/{host_id_list}/system_profile`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the number of tags on a host
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostTagCount.');
            }
            const localVarPath = `/hosts/{host_id_list}/tags/count`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the tags on a host
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', search?: string, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostGetHostTags.');
            }
            const localVarPath = `/hosts/{host_id_list}/tags`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace.
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostMergeFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostMergeFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a host
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostPatchById.');
            }
            // verify required parameter 'patchHostIn' is not null or undefined
            if (patchHostIn === null || patchHostIn === undefined) {
                throw new RequiredError('patchHostIn','Required parameter patchHostIn was null or undefined when calling apiHostPatchById.');
            }
            const localVarPath = `/hosts/{host_id_list}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchHostIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchHostIn !== undefined ? patchHostIn : {}) : (patchHostIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace facts under a namespace
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'hostIdList' is not null or undefined
            if (hostIdList === null || hostIdList === undefined) {
                throw new RequiredError('hostIdList','Required parameter hostIdList was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling apiHostReplaceFacts.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiHostReplaceFacts.');
            }
            const localVarPath = `/hosts/{host_id_list}/facts/{namespace}`
                .replace(`{${"host_id_list"}}`, encodeURIComponent(String(hostIdList)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HostsApi - functional programming interface
 * @export
 */
export const HostsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new host and add it to the host list or update an existing hosts. A host is updated if there is already one with the same canonicals facts and belonging to the same account. <br /><br /> NOTICE: This operation is deprecated. The explicit creation of hosts is no longer supported. Hosts are created automatically based on uploads processed by the [payload ingress service](/docs/api/ingress#operations-default-post_upload) instead.
         * @summary Create/update multiple host and add them to the host list
         * @param {Array<CreateHostIn>} createHostIn A list of host objects to be added to the host list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostAddHostList(createHostIn: Array<CreateHostIn>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkHostOut> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostAddHostList(createHostIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete hosts by IDs
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostDeleteById(hostIdList, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID.
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Read the entire list of all hosts available to the account.
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host\&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: 'insights', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostQueryOutput> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', branchId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemProfileByHostOut> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the number of tags on a host
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagCountOut> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the tags on a host
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', search?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsOut> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Merge one or multiple hosts facts under a namespace.
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a host
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace facts under a namespace
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = HostsApiAxiosParamCreator(configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HostsApi - factory interface
 * @export
 */
export const HostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new host and add it to the host list or update an existing hosts. A host is updated if there is already one with the same canonicals facts and belonging to the same account. <br /><br /> NOTICE: This operation is deprecated. The explicit creation of hosts is no longer supported. Hosts are created automatically based on uploads processed by the [payload ingress service](/docs/api/ingress#operations-default-post_upload) instead.
         * @summary Create/update multiple host and add them to the host list
         * @param {Array<CreateHostIn>} createHostIn A list of host objects to be added to the host list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostAddHostList(createHostIn: Array<CreateHostIn>, options?: any): AxiosPromise<BulkHostOut> {
            return HostsApiFp(configuration).apiHostAddHostList(createHostIn, options)(axios, basePath);
        },
        /**
         * Delete hosts by IDs
         * @summary Delete hosts by IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostDeleteById(hostIdList, branchId, options)(axios, basePath);
        },
        /**
         * Find one or more hosts by their ID.
         * @summary Find hosts by their IDs
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<HostQueryOutput> {
            return HostsApiFp(configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options)(axios, basePath);
        },
        /**
         * Read the entire list of all hosts available to the account.
         * @summary Read the entire list of hosts
         * @param {string} [displayName] A part of a searched host’s display name.
         * @param {string} [fqdn] Filter by a host\&#39;s FQDN
         * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
         * @param {string} [insightsId] Search for a host by insights_id
         * @param {string} [branchId] Filter by branch_id
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: 'insights', options?: any): AxiosPromise<HostQueryOutput> {
            return HostsApiFp(configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, options)(axios, basePath);
        },
        /**
         * Find one or more hosts by their ID and return the id and system profile
         * @summary Return one or more hosts system profile
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', branchId?: string, options?: any): AxiosPromise<SystemProfileByHostOut> {
            return HostsApiFp(configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, options)(axios, basePath);
        },
        /**
         * Get the number of tags on a host
         * @summary Get the number of tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any): AxiosPromise<TagCountOut> {
            return HostsApiFp(configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options)(axios, basePath);
        },
        /**
         * Get the tags on a host
         * @summary Get the tags on a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {'display_name' | 'updated'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', search?: string, options?: any): AxiosPromise<TagsOut> {
            return HostsApiFp(configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options)(axios, basePath);
        },
        /**
         * Merge one or multiple hosts facts under a namespace.
         * @summary Merge facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to merge with the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options)(axios, basePath);
        },
        /**
         * Update a host
         * @summary Update a host
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options)(axios, basePath);
        },
        /**
         * Replace facts under a namespace
         * @summary Replace facts under a namespace
         * @param {Array<string>} hostIdList A comma separated list of host IDs.
         * @param {string} namespace A namespace of the merged facts.
         * @param {object} body A dictionary with the new facts to replace the original ones.
         * @param {string} [branchId] Filter by branch_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any): AxiosPromise<void> {
            return HostsApiFp(configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options)(axios, basePath);
        },
    };
};

/**
 * HostsApi - object-oriented interface
 * @export
 * @class HostsApi
 * @extends {BaseAPI}
 */
export class HostsApi extends BaseAPI {
    /**
     * Create a new host and add it to the host list or update an existing hosts. A host is updated if there is already one with the same canonicals facts and belonging to the same account. <br /><br /> NOTICE: This operation is deprecated. The explicit creation of hosts is no longer supported. Hosts are created automatically based on uploads processed by the [payload ingress service](/docs/api/ingress#operations-default-post_upload) instead.
     * @summary Create/update multiple host and add them to the host list
     * @param {Array<CreateHostIn>} createHostIn A list of host objects to be added to the host list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostAddHostList(createHostIn: Array<CreateHostIn>, options?: any) {
        return HostsApiFp(this.configuration).apiHostAddHostList(createHostIn, options)(this.axios, this.basePath);
    }

    /**
     * Delete hosts by IDs
     * @summary Delete hosts by IDs
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostDeleteById(hostIdList: Array<string>, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostDeleteById(hostIdList, branchId, options)(this.axios, this.basePath);
    }

    /**
     * Find one or more hosts by their ID.
     * @summary Find hosts by their IDs
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostById(hostIdList: Array<string>, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostById(hostIdList, branchId, perPage, page, orderBy, orderHow, options)(this.axios, this.basePath);
    }

    /**
     * Read the entire list of all hosts available to the account.
     * @summary Read the entire list of hosts
     * @param {string} [displayName] A part of a searched host’s display name.
     * @param {string} [fqdn] Filter by a host\&#39;s FQDN
     * @param {string} [hostnameOrId] Search for a host by display_name, fqdn, id
     * @param {string} [insightsId] Search for a host by insights_id
     * @param {string} [branchId] Filter by branch_id
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostList(displayName?: string, fqdn?: string, hostnameOrId?: string, insightsId?: string, branchId?: string, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, tags?: Array<string>, registeredWith?: 'insights', options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostList(displayName, fqdn, hostnameOrId, insightsId, branchId, perPage, page, orderBy, orderHow, staleness, tags, registeredWith, options)(this.axios, this.basePath);
    }

    /**
     * Find one or more hosts by their ID and return the id and system profile
     * @summary Return one or more hosts system profile
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostSystemProfileById(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostSystemProfileById(hostIdList, perPage, page, orderBy, orderHow, branchId, options)(this.axios, this.basePath);
    }

    /**
     * Get the number of tags on a host
     * @summary Get the number of tags on a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostTagCount(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostTagCount(hostIdList, perPage, page, orderBy, orderHow, options)(this.axios, this.basePath);
    }

    /**
     * Get the tags on a host
     * @summary Get the tags on a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {'display_name' | 'updated'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering, defaults to ASC for display_name and to DESC for updated
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostGetHostTags(hostIdList: Array<string>, perPage?: number, page?: number, orderBy?: 'display_name' | 'updated', orderHow?: 'ASC' | 'DESC', search?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostGetHostTags(hostIdList, perPage, page, orderBy, orderHow, search, options)(this.axios, this.basePath);
    }

    /**
     * Merge one or multiple hosts facts under a namespace.
     * @summary Merge facts under a namespace
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} namespace A namespace of the merged facts.
     * @param {object} body A dictionary with the new facts to merge with the original ones.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostMergeFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostMergeFacts(hostIdList, namespace, body, branchId, options)(this.axios, this.basePath);
    }

    /**
     * Update a host
     * @summary Update a host
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {PatchHostIn} patchHostIn A group of fields to be updated on the host
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostPatchById(hostIdList: Array<string>, patchHostIn: PatchHostIn, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostPatchById(hostIdList, patchHostIn, branchId, options)(this.axios, this.basePath);
    }

    /**
     * Replace facts under a namespace
     * @summary Replace facts under a namespace
     * @param {Array<string>} hostIdList A comma separated list of host IDs.
     * @param {string} namespace A namespace of the merged facts.
     * @param {object} body A dictionary with the new facts to replace the original ones.
     * @param {string} [branchId] Filter by branch_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HostsApi
     */
    public apiHostReplaceFacts(hostIdList: Array<string>, namespace: string, body: object, branchId?: string, options?: any) {
        return HostsApiFp(this.configuration).apiHostReplaceFacts(hostIdList, namespace, body, branchId, options)(this.axios, this.basePath);
    }

}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, registeredWith?: 'insights', options: any = {}): RequestArgs {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("x-rh-identity")
                    : configuration.apiKey;
                localVarHeaderParameter["x-rh-identity"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderHow !== undefined) {
                localVarQueryParameter['order_how'] = orderHow;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (staleness) {
                localVarQueryParameter['staleness'] = staleness;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (registeredWith !== undefined) {
                localVarQueryParameter['registered_with'] = registeredWith;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, registeredWith?: 'insights', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveTags> {
            const localVarAxiosArgs = TagsApiAxiosParamCreator(configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, registeredWith, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Get the active host tags for a given account
         * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
         * @param {'tag' | 'count'} [orderBy] Ordering field name
         * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
         * @param {number} [perPage] A number of items to return per page.
         * @param {number} [page] A page number of the items to return.
         * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
         * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
         * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, registeredWith?: 'insights', options?: any): AxiosPromise<ActiveTags> {
            return TagsApiFp(configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, registeredWith, options)(axios, basePath);
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     *
     * @summary Get the active host tags for a given account
     * @param {Array<string>} [tags] filters out hosts not tagged by the given tags
     * @param {'tag' | 'count'} [orderBy] Ordering field name
     * @param {'ASC' | 'DESC'} [orderHow] Direction of the ordering. Default to ASC
     * @param {number} [perPage] A number of items to return per page.
     * @param {number} [page] A page number of the items to return.
     * @param {Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>} [staleness] Culling states of the hosts. Default: fresh,stale,unknown
     * @param {string} [search] Only include tags that match the given search string. The value is matched against namespace, key and value.
     * @param {'insights'} [registeredWith] Filters out any host not registered with the specified service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public apiTagGetTags(tags?: Array<string>, orderBy?: 'tag' | 'count', orderHow?: 'ASC' | 'DESC', perPage?: number, page?: number, staleness?: Array<'fresh' | 'stale' | 'stale_warning' | 'unknown'>, search?: string, registeredWith?: 'insights', options?: any) {
        return TagsApiFp(this.configuration).apiTagGetTags(tags, orderBy, orderHow, perPage, page, staleness, search, registeredWith, options)(this.axios, this.basePath);
    }

}


