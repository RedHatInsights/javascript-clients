// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Insights Remediations
 * Insights Remediations Service
 *
 * OpenAPI spec version: 1.0.0
 * Contact: jozef@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cloud.redhat.com/api/remediations/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface Diagnosis
 */
export interface Diagnosis {
    /**
     *
     * @type {string}
     * @memberof Diagnosis
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Diagnosis
     */
    insightsId: string;
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof Diagnosis
     */
    details: { [key: string]: any; };
}

/**
 *
 * @export
 * @interface ExecuteRemediation
 */
export interface ExecuteRemediation {
    /**
     *
     * @type {string}
     * @memberof ExecuteRemediation
     */
    id: string;
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    version: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    commit: string;
}

/**
 *
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * number of results returned
     * @type {number}
     * @memberof Meta
     */
    count: number;
    /**
     * total number of results matching the query
     * @type {number}
     * @memberof Meta
     */
    total: number;
}

/**
 *
 * @export
 * @interface PlaybookDefinition
 */
export interface PlaybookDefinition {
    /**
     *
     * @type {Array<PlaybookDefinitionIssues>}
     * @memberof PlaybookDefinition
     */
    issues: Array<PlaybookDefinitionIssues>;
    /**
     * Indicates whether systems that require reboot for the remediation to be properly applied should be rebooted automatically or not
     * @type {boolean}
     * @memberof PlaybookDefinition
     */
    autoReboot?: boolean;
}

/**
 *
 * @export
 * @interface PlaybookDefinitionIssues
 */
export interface PlaybookDefinitionIssues {
    /**
     *
     * @type {string}
     * @memberof PlaybookDefinitionIssues
     */
    id: string;
    /**
     *
     * @type {Array<string>}
     * @memberof PlaybookDefinitionIssues
     */
    systems: Array<string>;
    /**
     *
     * @type {string}
     * @memberof PlaybookDefinitionIssues
     */
    resolution?: string;
}

/**
 *
 * @export
 * @interface PlaybookExecutorStatus
 */
export interface PlaybookExecutorStatus {
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    executorId: string | null;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    executorType: string | null;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    executorName: string | null;
    /**
     *
     * @type {number}
     * @memberof PlaybookExecutorStatus
     */
    systemCount: number;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    connectionStatus: PlaybookExecutorStatus.ConnectionStatusEnum;
}

/**
 * @export
 * @namespace PlaybookExecutorStatus
 */
export namespace PlaybookExecutorStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum ConnectionStatusEnum {
        Connected = 'connected',
        Disconnected = 'disconnected',
        NoExecutor = 'no_executor',
        NoSource = 'no_source',
        NoReceptor = 'no_receptor'
    }
}

/**
 *
 * @export
 * @interface RemediationConnectionStatus
 */
export interface RemediationConnectionStatus {
    /**
     *
     * @type {Meta}
     * @memberof RemediationConnectionStatus
     */
    meta: Meta;
    /**
     *
     * @type {Array<PlaybookExecutorStatus>}
     * @memberof RemediationConnectionStatus
     */
    data: Array<PlaybookExecutorStatus>;
}

/**
 *
 * @export
 * @interface RemediationCreated
 */
export interface RemediationCreated {
    /**
     *
     * @type {string}
     * @memberof RemediationCreated
     */
    id: string;
}

/**
 *
 * @export
 * @interface RemediationDetails
 */
export interface RemediationDetails {
    /**
     *
     * @type {string}
     * @memberof RemediationDetails
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationDetails
     */
    name: string | null;
    /**
     * Indicates whether any of the issues contained in the remediation require system reboot
     * @type {boolean}
     * @memberof RemediationDetails
     */
    needsReboot: boolean;
    /**
     * Indicates whether systems that require reboot for the remediation to be properly applied should be rebooted automatically or not
     * @type {boolean}
     * @memberof RemediationDetails
     */
    autoReboot: boolean;
    /**
     *
     * @type {UserOut}
     * @memberof RemediationDetails
     */
    createdBy: UserOut;
    /**
     *
     * @type {Date}
     * @memberof RemediationDetails
     */
    createdAt: Date;
    /**
     *
     * @type {UserOut}
     * @memberof RemediationDetails
     */
    updatedBy: UserOut;
    /**
     *
     * @type {Date}
     * @memberof RemediationDetails
     */
    updatedAt: Date;
    /**
     *
     * @type {Array<RemediationIssue>}
     * @memberof RemediationDetails
     */
    issues: Array<RemediationIssue>;
}

/**
 *
 * @export
 * @interface RemediationInput
 */
export interface RemediationInput {
    /**
     *
     * @type {string}
     * @memberof RemediationInput
     */
    name?: string | null;
    /**
     * Indicates whether systems that require reboot for the remediation to be properly applied should be rebooted automatically or not
     * @type {boolean}
     * @memberof RemediationInput
     */
    autoReboot?: boolean;
    /**
     *
     * @type {RemediationInputAdd}
     * @memberof RemediationInput
     */
    add?: RemediationInputAdd;
}

/**
 *
 * @export
 * @interface RemediationInputAdd
 */
export interface RemediationInputAdd {
    /**
     *
     * @type {Array<RemediationInputAddIssues>}
     * @memberof RemediationInputAdd
     */
    issues: Array<RemediationInputAddIssues>;
    /**
     *
     * @type {Array<string>}
     * @memberof RemediationInputAdd
     */
    systems?: Array<string>;
}

/**
 *
 * @export
 * @interface RemediationInputAddIssues
 */
export interface RemediationInputAddIssues {
    /**
     *
     * @type {string}
     * @memberof RemediationInputAddIssues
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationInputAddIssues
     */
    resolution?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof RemediationInputAddIssues
     */
    systems?: Array<string>;
}

/**
 *
 * @export
 * @interface RemediationIssue
 */
export interface RemediationIssue {
    /**
     *
     * @type {string}
     * @memberof RemediationIssue
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationIssue
     */
    description: string;
    /**
     *
     * @type {RemediationIssueResolution}
     * @memberof RemediationIssue
     */
    resolution: RemediationIssueResolution;
    /**
     * The total number of available resolutions for this issue
     * @type {number}
     * @memberof RemediationIssue
     */
    resolutionsAvailable?: number;
    /**
     *
     * @type {Array<SystemOut>}
     * @memberof RemediationIssue
     */
    systems: Array<SystemOut>;
}

/**
 *
 * @export
 * @interface RemediationIssueIn
 */
export interface RemediationIssueIn {
    /**
     *
     * @type {string}
     * @memberof RemediationIssueIn
     */
    resolution: string;
}

/**
 *
 * @export
 * @interface RemediationIssueResolution
 */
export interface RemediationIssueResolution {
    /**
     *
     * @type {string}
     * @memberof RemediationIssueResolution
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationIssueResolution
     */
    description: string;
    /**
     *
     * @type {ResolutionRisk}
     * @memberof RemediationIssueResolution
     */
    resolutionRisk: ResolutionRisk;
    /**
     * Indicates whether the given resolution involves system reboot
     * @type {boolean}
     * @memberof RemediationIssueResolution
     */
    needsReboot: boolean;
}

/**
 *
 * @export
 * @interface RemediationList
 */
export interface RemediationList {
    /**
     *
     * @type {Array<RemediationListItem>}
     * @memberof RemediationList
     */
    data: Array<RemediationListItem>;
    /**
     *
     * @type {Meta}
     * @memberof RemediationList
     */
    meta: Meta;
    /**
     *
     * @type {RemediationListLinks}
     * @memberof RemediationList
     */
    links: RemediationListLinks;
}

/**
 *
 * @export
 * @interface RemediationListItem
 */
export interface RemediationListItem {
    /**
     *
     * @type {string}
     * @memberof RemediationListItem
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationListItem
     */
    name: string | null;
    /**
     *
     * @type {UserOut}
     * @memberof RemediationListItem
     */
    createdBy: UserOut;
    /**
     *
     * @type {Date}
     * @memberof RemediationListItem
     */
    createdAt: Date;
    /**
     *
     * @type {UserOut}
     * @memberof RemediationListItem
     */
    updatedBy: UserOut;
    /**
     *
     * @type {Date}
     * @memberof RemediationListItem
     */
    updatedAt: Date;
    /**
     *
     * @type {number}
     * @memberof RemediationListItem
     */
    issueCount: number;
    /**
     *
     * @type {number}
     * @memberof RemediationListItem
     */
    systemCount: number;
    /**
     * Indicates whether any of the issues contained in the remediation require system reboot
     * @type {boolean}
     * @memberof RemediationListItem
     */
    needsReboot: boolean;
}

/**
 *
 * @export
 * @interface RemediationListLinks
 */
export interface RemediationListLinks {
    /**
     * relative link to the first page of the query results
     * @type {string}
     * @memberof RemediationListLinks
     */
    first: string;
    /**
     * relative link to the last page of the query results
     * @type {string}
     * @memberof RemediationListLinks
     */
    last: string;
    /**
     * relative link to the next page of the query results (or null if this is the last page)
     * @type {string}
     * @memberof RemediationListLinks
     */
    next: string | null;
    /**
     * relative link to the previous page of the query results (or null if this is the first page)
     * @type {string}
     * @memberof RemediationListLinks
     */
    previous: string | null;
}

/**
 *
 * @export
 * @interface RequestError
 */
export interface RequestError {
    /**
     *
     * @type {Array<RequestErrorErrors>}
     * @memberof RequestError
     */
    errors: Array<RequestErrorErrors>;
}

/**
 *
 * @export
 * @interface RequestErrorErrors
 */
export interface RequestErrorErrors {
    /**
     *
     * @type {string}
     * @memberof RequestErrorErrors
     */
    id: string;
    /**
     *
     * @type {number}
     * @memberof RequestErrorErrors
     */
    status: number;
    /**
     *
     * @type {string}
     * @memberof RequestErrorErrors
     */
    code: string;
    /**
     *
     * @type {string}
     * @memberof RequestErrorErrors
     */
    title: string;
    /**
     *
     * @type {any}
     * @memberof RequestErrorErrors
     */
    details?: any;
}

/**
 *
 * @export
 * @enum {string}
 */
export enum ResolutionRisk {
    NUMBER_MINUS_1 = -1,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3,
    NUMBER_4 = 4
}

/**
 *
 * @export
 * @interface Resolutions
 */
export interface Resolutions {
    /**
     *
     * @type {string}
     * @memberof Resolutions
     */
    id: string;
    /**
     *
     * @type {ResolutionRisk}
     * @memberof Resolutions
     */
    resolutionRisk: ResolutionRisk;
    /**
     *
     * @type {Array<ResolutionsResolutions>}
     * @memberof Resolutions
     */
    resolutions: Array<ResolutionsResolutions>;
}

/**
 *
 * @export
 * @interface ResolutionsBatchInput
 */
export interface ResolutionsBatchInput {
    /**
     *
     * @type {Array<string>}
     * @memberof ResolutionsBatchInput
     */
    issues: Array<string>;
}

/**
 *
 * @export
 * @interface ResolutionsResolutions
 */
export interface ResolutionsResolutions {
    /**
     *
     * @type {string}
     * @memberof ResolutionsResolutions
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ResolutionsResolutions
     */
    description: string;
    /**
     * Indicates whether the given resolution involves system reboot
     * @type {boolean}
     * @memberof ResolutionsResolutions
     */
    needsReboot: boolean;
    /**
     *
     * @type {ResolutionRisk}
     * @memberof ResolutionsResolutions
     */
    resolutionRisk: ResolutionRisk;
}

/**
 *
 * @export
 * @interface SystemOut
 */
export interface SystemOut {
    /**
     *
     * @type {string}
     * @memberof SystemOut
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof SystemOut
     */
    hostname: string | null;
    /**
     *
     * @type {string}
     * @memberof SystemOut
     */
    displayName: string | null;
}

/**
 *
 * @export
 * @interface UserOut
 */
export interface UserOut {
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    firstName: string;
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    lastName: string;
}


/**
 * DiagnosisApi - axios parameter creator
 * @export
 */
export const DiagnosisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides host-specific diagnosis information
         * @summary host-specific diagnosis
         * @param {string} system System identifier
         * @param {string} [remediation] Remediation identifier (uuid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnosis(system: string, remediation?: string, options: any = {}): RequestArgs {
            // verify required parameter 'system' is not null or undefined
            if (system === null || system === undefined) {
                throw new RequiredError('system','Required parameter system was null or undefined when calling getDiagnosis.');
            }
            const localVarPath = `/diagnosis/{system}`
                .replace(`{${"system"}}`, encodeURIComponent(String(system)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (remediation !== undefined) {
                localVarQueryParameter['remediation'] = remediation;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosisApi - functional programming interface
 * @export
 */
export const DiagnosisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides host-specific diagnosis information
         * @summary host-specific diagnosis
         * @param {string} system System identifier
         * @param {string} [remediation] Remediation identifier (uuid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnosis(system: string, remediation?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Diagnosis> {
            const localVarAxiosArgs = DiagnosisApiAxiosParamCreator(configuration).getDiagnosis(system, remediation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DiagnosisApi - factory interface
 * @export
 */
export const DiagnosisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Provides host-specific diagnosis information
         * @summary host-specific diagnosis
         * @param {string} system System identifier
         * @param {string} [remediation] Remediation identifier (uuid)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnosis(system: string, remediation?: string, options?: any) {
            return DiagnosisApiFp(configuration).getDiagnosis(system, remediation, options)(axios, basePath);
        },
    };
};

/**
 * DiagnosisApi - object-oriented interface
 * @export
 * @class DiagnosisApi
 * @extends {BaseAPI}
 */
export class DiagnosisApi extends BaseAPI {
    /**
     * Provides host-specific diagnosis information
     * @summary host-specific diagnosis
     * @param {string} system System identifier
     * @param {string} [remediation] Remediation identifier (uuid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosisApi
     */
    public getDiagnosis(system: string, remediation?: string, options?: any) {
        return DiagnosisApiFp(this.configuration).getDiagnosis(system, remediation, options)(this.axios, this.basePath);
    }

}

/**
 * GeneratorApi - axios parameter creator
 * @export
 */
export const GeneratorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates an Ansible Playbook based on input parameters
         * @summary Generate an Ansible Playbook
         * @param {PlaybookDefinition} playbookDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(playbookDefinition: PlaybookDefinition, options: any = {}): RequestArgs {
            // verify required parameter 'playbookDefinition' is not null or undefined
            if (playbookDefinition === null || playbookDefinition === undefined) {
                throw new RequiredError('playbookDefinition','Required parameter playbookDefinition was null or undefined when calling generate.');
            }
            const localVarPath = `/playbook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PlaybookDefinition" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbookDefinition || {}) : (playbookDefinition || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneratorApi - functional programming interface
 * @export
 */
export const GeneratorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generates an Ansible Playbook based on input parameters
         * @summary Generate an Ansible Playbook
         * @param {PlaybookDefinition} playbookDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(playbookDefinition: PlaybookDefinition, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = GeneratorApiAxiosParamCreator(configuration).generate(playbookDefinition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GeneratorApi - factory interface
 * @export
 */
export const GeneratorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Generates an Ansible Playbook based on input parameters
         * @summary Generate an Ansible Playbook
         * @param {PlaybookDefinition} playbookDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(playbookDefinition: PlaybookDefinition, options?: any) {
            return GeneratorApiFp(configuration).generate(playbookDefinition, options)(axios, basePath);
        },
    };
};

/**
 * GeneratorApi - object-oriented interface
 * @export
 * @class GeneratorApi
 * @extends {BaseAPI}
 */
export class GeneratorApi extends BaseAPI {
    /**
     * Generates an Ansible Playbook based on input parameters
     * @summary Generate an Ansible Playbook
     * @param {PlaybookDefinition} playbookDefinition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneratorApi
     */
    public generate(playbookDefinition: PlaybookDefinition, options?: any) {
        return GeneratorApiFp(this.configuration).generate(playbookDefinition, options)(this.axios, this.basePath);
    }

}

/**
 * RemediationsApi - axios parameter creator
 * @export
 */
export const RemediationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Remediation based on given information
         * @summary Create Remediation
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemediation(remediationInput: RemediationInput, options: any = {}): RequestArgs {
            // verify required parameter 'remediationInput' is not null or undefined
            if (remediationInput === null || remediationInput === undefined) {
                throw new RequiredError('remediationInput','Required parameter remediationInput was null or undefined when calling createRemediation.');
            }
            const localVarPath = `/remediations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RemediationInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remediationInput || {}) : (remediationInput || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given Remediation
         * @summary Remove Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediation(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRemediation.');
            }
            const localVarPath = `/remediations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given Issue from the Remediation
         * @summary Remove Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssue(id: string, issue: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRemediationIssue.');
            }
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling deleteRemediationIssue.');
            }
            const localVarPath = `/remediations/{id}/issues/{issue}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given System from the Issue Remediation
         * @summary Remove Remediation Issue System
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssueSystem(id: string, issue: string, system: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRemediationIssueSystem.');
            }
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling deleteRemediationIssueSystem.');
            }
            // verify required parameter 'system' is not null or undefined
            if (system === null || system === undefined) {
                throw new RequiredError('system','Required parameter system was null or undefined when calling deleteRemediationIssueSystem.');
            }
            const localVarPath = `/remediations/{id}/issues/{issue}/systems/{system}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)))
                .replace(`{${"system"}}`, encodeURIComponent(String(system)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about the given Remediation
         * @summary Get Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediation(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemediation.');
            }
            const localVarPath = `/remediations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get satellite connection status for a given host
         * @summary Pre-flight check
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationConnectionStatus(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemediationConnectionStatus.');
            }
            const localVarPath = `/remediations/{id}/connection_status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides Ansible Playbook
         * @summary Get Remediation Playbook
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationPlaybook(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemediationPlaybook.');
            }
            const localVarPath = `/remediations/{id}/playbook`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about Remediations
         * @summary List Remediations
         * @param {'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count'} [sort] Sort order
         * @param {string} [filter] Remediation name filter. If specified only remediations whose name matches the given string will be returned.
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [system] System identifier. If specified only remediations that involve the given system will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediations(sort?: 'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count', filter?: string, limit?: number, offset?: number, system?: string, options: any = {}): RequestArgs {
            const localVarPath = `/remediations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute remediation
         * @summary Execute remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runRemediation(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling runRemediation.');
            }
            const localVarPath = `/remediations/{id}/playbook_runs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given Remediation
         * @summary Update Remediation
         * @param {string} id Remediation identifier
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediation(id: string, remediationInput: RemediationInput, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRemediation.');
            }
            // verify required parameter 'remediationInput' is not null or undefined
            if (remediationInput === null || remediationInput === undefined) {
                throw new RequiredError('remediationInput','Required parameter remediationInput was null or undefined when calling updateRemediation.');
            }
            const localVarPath = `/remediations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RemediationInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remediationInput || {}) : (remediationInput || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given Remediation Issue
         * @summary Update Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {RemediationIssueIn} remediationIssueIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediationIssue(id: string, issue: string, remediationIssueIn: RemediationIssueIn, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRemediationIssue.');
            }
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling updateRemediationIssue.');
            }
            // verify required parameter 'remediationIssueIn' is not null or undefined
            if (remediationIssueIn === null || remediationIssueIn === undefined) {
                throw new RequiredError('remediationIssueIn','Required parameter remediationIssueIn was null or undefined when calling updateRemediationIssue.');
            }
            const localVarPath = `/remediations/{id}/issues/{issue}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RemediationIssueIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remediationIssueIn || {}) : (remediationIssueIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemediationsApi - functional programming interface
 * @export
 */
export const RemediationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new Remediation based on given information
         * @summary Create Remediation
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemediation(remediationInput: RemediationInput, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationCreated> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).createRemediation(remediationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the given Remediation
         * @summary Remove Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediation(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).deleteRemediation(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the given Issue from the Remediation
         * @summary Remove Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssue(id: string, issue: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).deleteRemediationIssue(id, issue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the given System from the Issue Remediation
         * @summary Remove Remediation Issue System
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssueSystem(id: string, issue: string, system: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).deleteRemediationIssueSystem(id, issue, system, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides information about the given Remediation
         * @summary Get Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediation(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationDetails> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).getRemediation(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get satellite connection status for a given host
         * @summary Pre-flight check
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationConnectionStatus(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationConnectionStatus> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).getRemediationConnectionStatus(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides Ansible Playbook
         * @summary Get Remediation Playbook
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationPlaybook(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).getRemediationPlaybook(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides information about Remediations
         * @summary List Remediations
         * @param {'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count'} [sort] Sort order
         * @param {string} [filter] Remediation name filter. If specified only remediations whose name matches the given string will be returned.
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [system] System identifier. If specified only remediations that involve the given system will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediations(sort?: 'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count', filter?: string, limit?: number, offset?: number, system?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationList> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).getRemediations(sort, filter, limit, offset, system, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Execute remediation
         * @summary Execute remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runRemediation(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteRemediation> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).runRemediation(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the given Remediation
         * @summary Update Remediation
         * @param {string} id Remediation identifier
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediation(id: string, remediationInput: RemediationInput, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).updateRemediation(id, remediationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the given Remediation Issue
         * @summary Update Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {RemediationIssueIn} remediationIssueIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediationIssue(id: string, issue: string, remediationIssueIn: RemediationIssueIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = RemediationsApiAxiosParamCreator(configuration).updateRemediationIssue(id, issue, remediationIssueIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RemediationsApi - factory interface
 * @export
 */
export const RemediationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new Remediation based on given information
         * @summary Create Remediation
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemediation(remediationInput: RemediationInput, options?: any) {
            return RemediationsApiFp(configuration).createRemediation(remediationInput, options)(axios, basePath);
        },
        /**
         * Removes the given Remediation
         * @summary Remove Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediation(id: string, options?: any) {
            return RemediationsApiFp(configuration).deleteRemediation(id, options)(axios, basePath);
        },
        /**
         * Removes the given Issue from the Remediation
         * @summary Remove Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssue(id: string, issue: string, options?: any) {
            return RemediationsApiFp(configuration).deleteRemediationIssue(id, issue, options)(axios, basePath);
        },
        /**
         * Removes the given System from the Issue Remediation
         * @summary Remove Remediation Issue System
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssueSystem(id: string, issue: string, system: string, options?: any) {
            return RemediationsApiFp(configuration).deleteRemediationIssueSystem(id, issue, system, options)(axios, basePath);
        },
        /**
         * Provides information about the given Remediation
         * @summary Get Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediation(id: string, options?: any) {
            return RemediationsApiFp(configuration).getRemediation(id, options)(axios, basePath);
        },
        /**
         * Get satellite connection status for a given host
         * @summary Pre-flight check
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationConnectionStatus(id: string, options?: any) {
            return RemediationsApiFp(configuration).getRemediationConnectionStatus(id, options)(axios, basePath);
        },
        /**
         * Provides Ansible Playbook
         * @summary Get Remediation Playbook
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationPlaybook(id: string, options?: any) {
            return RemediationsApiFp(configuration).getRemediationPlaybook(id, options)(axios, basePath);
        },
        /**
         * Provides information about Remediations
         * @summary List Remediations
         * @param {'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count'} [sort] Sort order
         * @param {string} [filter] Remediation name filter. If specified only remediations whose name matches the given string will be returned.
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [system] System identifier. If specified only remediations that involve the given system will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediations(sort?: 'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count', filter?: string, limit?: number, offset?: number, system?: string, options?: any) {
            return RemediationsApiFp(configuration).getRemediations(sort, filter, limit, offset, system, options)(axios, basePath);
        },
        /**
         * Execute remediation
         * @summary Execute remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runRemediation(id: string, options?: any) {
            return RemediationsApiFp(configuration).runRemediation(id, options)(axios, basePath);
        },
        /**
         * Updates the given Remediation
         * @summary Update Remediation
         * @param {string} id Remediation identifier
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediation(id: string, remediationInput: RemediationInput, options?: any) {
            return RemediationsApiFp(configuration).updateRemediation(id, remediationInput, options)(axios, basePath);
        },
        /**
         * Updates the given Remediation Issue
         * @summary Update Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {RemediationIssueIn} remediationIssueIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediationIssue(id: string, issue: string, remediationIssueIn: RemediationIssueIn, options?: any) {
            return RemediationsApiFp(configuration).updateRemediationIssue(id, issue, remediationIssueIn, options)(axios, basePath);
        },
    };
};

/**
 * RemediationsApi - object-oriented interface
 * @export
 * @class RemediationsApi
 * @extends {BaseAPI}
 */
export class RemediationsApi extends BaseAPI {
    /**
     * Creates a new Remediation based on given information
     * @summary Create Remediation
     * @param {RemediationInput} remediationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public createRemediation(remediationInput: RemediationInput, options?: any) {
        return RemediationsApiFp(this.configuration).createRemediation(remediationInput, options)(this.axios, this.basePath);
    }

    /**
     * Removes the given Remediation
     * @summary Remove Remediation
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public deleteRemediation(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).deleteRemediation(id, options)(this.axios, this.basePath);
    }

    /**
     * Removes the given Issue from the Remediation
     * @summary Remove Remediation Issue
     * @param {string} id Remediation identifier
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public deleteRemediationIssue(id: string, issue: string, options?: any) {
        return RemediationsApiFp(this.configuration).deleteRemediationIssue(id, issue, options)(this.axios, this.basePath);
    }

    /**
     * Removes the given System from the Issue Remediation
     * @summary Remove Remediation Issue System
     * @param {string} id Remediation identifier
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {string} system System identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public deleteRemediationIssueSystem(id: string, issue: string, system: string, options?: any) {
        return RemediationsApiFp(this.configuration).deleteRemediationIssueSystem(id, issue, system, options)(this.axios, this.basePath);
    }

    /**
     * Provides information about the given Remediation
     * @summary Get Remediation
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediation(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).getRemediation(id, options)(this.axios, this.basePath);
    }

    /**
     * Get satellite connection status for a given host
     * @summary Pre-flight check
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediationConnectionStatus(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).getRemediationConnectionStatus(id, options)(this.axios, this.basePath);
    }

    /**
     * Provides Ansible Playbook
     * @summary Get Remediation Playbook
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediationPlaybook(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).getRemediationPlaybook(id, options)(this.axios, this.basePath);
    }

    /**
     * Provides information about Remediations
     * @summary List Remediations
     * @param {'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count'} [sort] Sort order
     * @param {string} [filter] Remediation name filter. If specified only remediations whose name matches the given string will be returned.
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
     * @param {string} [system] System identifier. If specified only remediations that involve the given system will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediations(sort?: 'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count', filter?: string, limit?: number, offset?: number, system?: string, options?: any) {
        return RemediationsApiFp(this.configuration).getRemediations(sort, filter, limit, offset, system, options)(this.axios, this.basePath);
    }

    /**
     * Execute remediation
     * @summary Execute remediation
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public runRemediation(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).runRemediation(id, options)(this.axios, this.basePath);
    }

    /**
     * Updates the given Remediation
     * @summary Update Remediation
     * @param {string} id Remediation identifier
     * @param {RemediationInput} remediationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public updateRemediation(id: string, remediationInput: RemediationInput, options?: any) {
        return RemediationsApiFp(this.configuration).updateRemediation(id, remediationInput, options)(this.axios, this.basePath);
    }

    /**
     * Updates the given Remediation Issue
     * @summary Update Remediation Issue
     * @param {string} id Remediation identifier
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {RemediationIssueIn} remediationIssueIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public updateRemediationIssue(id: string, issue: string, remediationIssueIn: RemediationIssueIn, options?: any) {
        return RemediationsApiFp(this.configuration).updateRemediationIssue(id, issue, remediationIssueIn, options)(this.axios, this.basePath);
    }

}

/**
 * ResolutionsApi - axios parameter creator
 * @export
 */
export const ResolutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides information about resolutions available for the given issue
         * @summary Resolution metadata
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssue(issue: string, options: any = {}): RequestArgs {
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling getResolutionsForIssue.');
            }
            const localVarPath = `/resolutions/{issue}`
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about resolutions available for the given issues
         * @summary Resolution metadata (batch)
         * @param {ResolutionsBatchInput} resolutionsBatchInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssues(resolutionsBatchInput: ResolutionsBatchInput, options: any = {}): RequestArgs {
            // verify required parameter 'resolutionsBatchInput' is not null or undefined
            if (resolutionsBatchInput === null || resolutionsBatchInput === undefined) {
                throw new RequiredError('resolutionsBatchInput','Required parameter resolutionsBatchInput was null or undefined when calling getResolutionsForIssues.');
            }
            const localVarPath = `/resolutions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResolutionsBatchInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resolutionsBatchInput || {}) : (resolutionsBatchInput || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResolutionsApi - functional programming interface
 * @export
 */
export const ResolutionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides information about resolutions available for the given issue
         * @summary Resolution metadata
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssue(issue: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resolutions> {
            const localVarAxiosArgs = ResolutionsApiAxiosParamCreator(configuration).getResolutionsForIssue(issue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides information about resolutions available for the given issues
         * @summary Resolution metadata (batch)
         * @param {ResolutionsBatchInput} resolutionsBatchInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssues(resolutionsBatchInput: ResolutionsBatchInput, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Resolutions | boolean; }> {
            const localVarAxiosArgs = ResolutionsApiAxiosParamCreator(configuration).getResolutionsForIssues(resolutionsBatchInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResolutionsApi - factory interface
 * @export
 */
export const ResolutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Provides information about resolutions available for the given issue
         * @summary Resolution metadata
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssue(issue: string, options?: any) {
            return ResolutionsApiFp(configuration).getResolutionsForIssue(issue, options)(axios, basePath);
        },
        /**
         * Provides information about resolutions available for the given issues
         * @summary Resolution metadata (batch)
         * @param {ResolutionsBatchInput} resolutionsBatchInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssues(resolutionsBatchInput: ResolutionsBatchInput, options?: any) {
            return ResolutionsApiFp(configuration).getResolutionsForIssues(resolutionsBatchInput, options)(axios, basePath);
        },
    };
};

/**
 * ResolutionsApi - object-oriented interface
 * @export
 * @class ResolutionsApi
 * @extends {BaseAPI}
 */
export class ResolutionsApi extends BaseAPI {
    /**
     * Provides information about resolutions available for the given issue
     * @summary Resolution metadata
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionsApi
     */
    public getResolutionsForIssue(issue: string, options?: any) {
        return ResolutionsApiFp(this.configuration).getResolutionsForIssue(issue, options)(this.axios, this.basePath);
    }

    /**
     * Provides information about resolutions available for the given issues
     * @summary Resolution metadata (batch)
     * @param {ResolutionsBatchInput} resolutionsBatchInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionsApi
     */
    public getResolutionsForIssues(resolutionsBatchInput: ResolutionsBatchInput, options?: any) {
        return ResolutionsApiFp(this.configuration).getResolutionsForIssues(resolutionsBatchInput, options)(this.axios, this.basePath);
    }

}

/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides information about the version of the service
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options: any = {}): RequestArgs {
            const localVarPath = `/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides information about the version of the service
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = VersionApiAxiosParamCreator(configuration).getVersion(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Provides information about the version of the service
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any) {
            return VersionApiFp(configuration).getVersion(options)(axios, basePath);
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * Provides information about the version of the service
     * @summary Get service version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getVersion(options?: any) {
        return VersionApiFp(this.configuration).getVersion(options)(this.axios, this.basePath);
    }

}

