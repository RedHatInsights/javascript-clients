// tslint:disable
/**
 * Insights Remediations
 * Insights Remediations Service
 *
 * The version of the OpenAPI document: 1.3.3
 * Contact: jharting@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Counts
 */
export interface Counts {
    /**
     *
     * @type {number}
     * @memberof Counts
     */
    pending: number;
    /**
     *
     * @type {number}
     * @memberof Counts
     */
    running: number;
    /**
     *
     * @type {number}
     * @memberof Counts
     */
    success: number;
    /**
     *
     * @type {number}
     * @memberof Counts
     */
    failure: number;
    /**
     *
     * @type {number}
     * @memberof Counts
     */
    canceled: number;
}
/**
 *
 * @export
 * @interface Diagnosis
 */
export interface Diagnosis {
    /**
     *
     * @type {string}
     * @memberof Diagnosis
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Diagnosis
     */
    insights_id: string;
    /**
     *
     * @type {{ [key: string]: object; }}
     * @memberof Diagnosis
     */
    details: { [key: string]: object; };
}
/**
 *
 * @export
 * @interface ExecuteRemediation
 */
export interface ExecuteRemediation {
    /**
     *
     * @type {string}
     * @memberof ExecuteRemediation
     */
    id: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    version: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    commit: string;
}
/**
 *
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * number of results returned
     * @type {number}
     * @memberof Meta
     */
    count: number;
    /**
     * total number of results matching the query
     * @type {number}
     * @memberof Meta
     */
    total: number;
}
/**
 *
 * @export
 * @interface MultipleDelete
 */
export interface MultipleDelete {
    /**
     * Count of remediations deleted
     * @type {number}
     * @memberof MultipleDelete
     */
    deleted_count?: number;
}
/**
 *
 * @export
 * @interface PlaybookDefinition
 */
export interface PlaybookDefinition {
    /**
     *
     * @type {Array<PlaybookDefinitionIssues>}
     * @memberof PlaybookDefinition
     */
    issues: Array<PlaybookDefinitionIssues>;
    /**
     * Indicates whether systems that require reboot for the remediation to be properly applied should be rebooted automatically or not
     * @type {boolean}
     * @memberof PlaybookDefinition
     */
    auto_reboot?: boolean;
}
/**
 *
 * @export
 * @interface PlaybookDefinitionIssues
 */
export interface PlaybookDefinitionIssues {
    /**
     *
     * @type {string}
     * @memberof PlaybookDefinitionIssues
     */
    id: string;
    /**
     *
     * @type {Array<string>}
     * @memberof PlaybookDefinitionIssues
     */
    systems: Array<string>;
    /**
     *
     * @type {string}
     * @memberof PlaybookDefinitionIssues
     */
    resolution?: string;
}
/**
 *
 * @export
 * @interface PlaybookExecutorDetails
 */
export interface PlaybookExecutorDetails {
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorDetails
     */
    executor_id: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorDetails
     */
    executor_name: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorDetails
     */
    updated_at: string;
    /**
     * Playbook created for the playbook run executor.
     * @type {string}
     * @memberof PlaybookExecutorDetails
     */
    playbook: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorDetails
     */
    playbook_run_id: string;
    /**
     *
     * @type {number}
     * @memberof PlaybookExecutorDetails
     */
    system_count: number;
    /**
     *
     * @type {Counts}
     * @memberof PlaybookExecutorDetails
     */
    counts?: Counts;
    /**
     *
     * @type {PlaybookRunExecutorStatus}
     * @memberof PlaybookExecutorDetails
     */
    status: PlaybookRunExecutorStatus;
}
/**
 *
 * @export
 * @interface PlaybookExecutorStatus
 */
export interface PlaybookExecutorStatus {
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    endpoint_id: string | null;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    executor_id: string | null;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    executor_type: string | null;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    executor_name: string | null;
    /**
     *
     * @type {number}
     * @memberof PlaybookExecutorStatus
     */
    system_count: number;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutorStatus
     */
    connection_status: PlaybookExecutorStatusConnectionStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PlaybookExecutorStatusConnectionStatusEnum {
    Connected = 'connected',
    Disabled = 'disabled',
    Disconnected = 'disconnected',
    NoExecutor = 'no_executor',
    NoSource = 'no_source',
    NoReceptor = 'no_receptor',
    NoSmartManagement = 'no_smart_management',
    NoRhc = 'no_rhc'
}

/**
 *
 * @export
 * @interface PlaybookExecutors
 */
export interface PlaybookExecutors {
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutors
     */
    executor_id: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookExecutors
     */
    executor_name: string;
    /**
     *
     * @type {PlaybookRunExecutorStatus}
     * @memberof PlaybookExecutors
     */
    status: PlaybookRunExecutorStatus;
    /**
     *
     * @type {number}
     * @memberof PlaybookExecutors
     */
    system_count: number;
    /**
     *
     * @type {Counts}
     * @memberof PlaybookExecutors
     */
    counts: Counts;
}
/**
 *
 * @export
 * @interface PlaybookRunDetails
 */
export interface PlaybookRunDetails {
    /**
     *
     * @type {string}
     * @memberof PlaybookRunDetails
     */
    id: string;
    /**
     *
     * @type {Array<PlaybookExecutors>}
     * @memberof PlaybookRunDetails
     */
    executors: Array<PlaybookExecutors>;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunDetails
     */
    remediation_id: string;
    /**
     *
     * @type {UserOut}
     * @memberof PlaybookRunDetails
     */
    created_by: UserOut;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunDetails
     */
    created_at: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunDetails
     */
    updated_at: string;
    /**
     *
     * @type {PlaybookRunStatus}
     * @memberof PlaybookRunDetails
     */
    status: PlaybookRunStatus;
}
/**
 *
 * @export
 * @interface PlaybookRunExecutorDetails
 */
export interface PlaybookRunExecutorDetails {
    /**
     *
     * @type {string}
     * @memberof PlaybookRunExecutorDetails
     */
    id?: string;
    /**
     *
     * @type {Array<PlaybookExecutorDetails>}
     * @memberof PlaybookRunExecutorDetails
     */
    executors: Array<PlaybookExecutorDetails>;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunExecutorDetails
     */
    remediation_id: string;
    /**
     *
     * @type {UserOut}
     * @memberof PlaybookRunExecutorDetails
     */
    created_by: UserOut;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunExecutorDetails
     */
    created_at: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunExecutorDetails
     */
    updated_at: string;
    /**
     *
     * @type {PlaybookRunStatus}
     * @memberof PlaybookRunExecutorDetails
     */
    status: PlaybookRunStatus;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum PlaybookRunExecutorStatus {
    Pending = 'pending',
    Acked = 'acked',
    Running = 'running',
    Success = 'success',
    Failure = 'failure',
    Canceled = 'canceled'
}

/**
 *
 * @export
 * @enum {string}
 */
export enum PlaybookRunStatus {
    Pending = 'pending',
    Running = 'running',
    Success = 'success',
    Failure = 'failure',
    Canceled = 'canceled'
}

/**
 *
 * @export
 * @interface PlaybookRunSystemDetails
 */
export interface PlaybookRunSystemDetails {
    /**
     *
     * @type {string}
     * @memberof PlaybookRunSystemDetails
     */
    system_id: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunSystemDetails
     */
    system_name: string;
    /**
     *
     * @type {PlaybookRunSystemStatus}
     * @memberof PlaybookRunSystemDetails
     */
    status: PlaybookRunSystemStatus;
    /**
     * Current formatted system log from playbook run system.
     * @type {string}
     * @memberof PlaybookRunSystemDetails
     */
    console: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunSystemDetails
     */
    playbook_run_executor_id: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunSystemDetails
     */
    updated_at: string;
}
/**
 *
 * @export
 * @interface PlaybookRunSystemList
 */
export interface PlaybookRunSystemList {
    /**
     *
     * @type {Array<PlaybookRunSystems>}
     * @memberof PlaybookRunSystemList
     */
    data: Array<PlaybookRunSystems>;
    /**
     *
     * @type {Meta}
     * @memberof PlaybookRunSystemList
     */
    meta: Meta;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum PlaybookRunSystemStatus {
    Pending = 'pending',
    Running = 'running',
    Success = 'success',
    Failure = 'failure',
    Canceled = 'canceled'
}

/**
 *
 * @export
 * @interface PlaybookRunSystems
 */
export interface PlaybookRunSystems {
    /**
     *
     * @type {string}
     * @memberof PlaybookRunSystems
     */
    system_id: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunSystems
     */
    system_name: string;
    /**
     *
     * @type {PlaybookRunSystemStatus}
     * @memberof PlaybookRunSystems
     */
    status: PlaybookRunSystemStatus;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunSystems
     */
    updated_at: string;
    /**
     *
     * @type {string}
     * @memberof PlaybookRunSystems
     */
    playbook_run_executor_id: string;
}
/**
 *
 * @export
 * @interface PlaybookRunsInput
 */
export interface PlaybookRunsInput {
    /**
     *
     * @type {Array<string>}
     * @memberof PlaybookRunsInput
     */
    exclude?: Array<string>;
}
/**
 *
 * @export
 * @interface PlaybookRunsList
 */
export interface PlaybookRunsList {
    /**
     *
     * @type {Array<PlaybookRunDetails>}
     * @memberof PlaybookRunsList
     */
    data: Array<PlaybookRunDetails>;
    /**
     *
     * @type {Meta}
     * @memberof PlaybookRunsList
     */
    meta: Meta;
}
/**
 *
 * @export
 * @interface RemediationConnectionStatus
 */
export interface RemediationConnectionStatus {
    /**
     *
     * @type {Meta}
     * @memberof RemediationConnectionStatus
     */
    meta: Meta;
    /**
     *
     * @type {Array<PlaybookExecutorStatus>}
     * @memberof RemediationConnectionStatus
     */
    data: Array<PlaybookExecutorStatus>;
}
/**
 *
 * @export
 * @interface RemediationCreated
 */
export interface RemediationCreated {
    /**
     *
     * @type {string}
     * @memberof RemediationCreated
     */
    id: string;
}
/**
 *
 * @export
 * @interface RemediationDetails
 */
export interface RemediationDetails {
    /**
     *
     * @type {string}
     * @memberof RemediationDetails
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationDetails
     */
    name: string | null;
    /**
     * Indicates whether any of the issues contained in the remediation require system reboot
     * @type {boolean}
     * @memberof RemediationDetails
     */
    needs_reboot: boolean;
    /**
     * Indicates whether a remediation has been marked as archived
     * @type {boolean}
     * @memberof RemediationDetails
     */
    archived: boolean;
    /**
     * Indicates whether systems that require reboot for the remediation to be properly applied should be rebooted automatically or not
     * @type {boolean}
     * @memberof RemediationDetails
     */
    auto_reboot: boolean;
    /**
     *
     * @type {UserOut}
     * @memberof RemediationDetails
     */
    created_by: UserOut;
    /**
     *
     * @type {string}
     * @memberof RemediationDetails
     */
    created_at: string;
    /**
     *
     * @type {UserOut}
     * @memberof RemediationDetails
     */
    updated_by: UserOut;
    /**
     *
     * @type {string}
     * @memberof RemediationDetails
     */
    updated_at: string;
    /**
     *
     * @type {number}
     * @memberof RemediationDetails
     */
    resolved_count: number;
    /**
     *
     * @type {Array<RemediationIssue>}
     * @memberof RemediationDetails
     */
    issues: Array<RemediationIssue>;
}
/**
 *
 * @export
 * @interface RemediationInput
 */
export interface RemediationInput {
    /**
     *
     * @type {string}
     * @memberof RemediationInput
     */
    name?: string | null;
    /**
     * Indicates whether a remediation has been marked as archived
     * @type {boolean}
     * @memberof RemediationInput
     */
    archived?: boolean;
    /**
     * Indicates whether systems that require reboot for the remediation to be properly applied should be rebooted automatically or not
     * @type {boolean}
     * @memberof RemediationInput
     */
    auto_reboot?: boolean;
    /**
     *
     * @type {RemediationInputAdd}
     * @memberof RemediationInput
     */
    add?: RemediationInputAdd;
}
/**
 *
 * @export
 * @interface RemediationInputAdd
 */
export interface RemediationInputAdd {
    /**
     *
     * @type {Array<RemediationInputAddIssues>}
     * @memberof RemediationInputAdd
     */
    issues: Array<RemediationInputAddIssues>;
    /**
     *
     * @type {Array<string>}
     * @memberof RemediationInputAdd
     */
    systems?: Array<string>;
}
/**
 *
 * @export
 * @interface RemediationInputAddIssues
 */
export interface RemediationInputAddIssues {
    /**
     *
     * @type {string}
     * @memberof RemediationInputAddIssues
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationInputAddIssues
     */
    resolution?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof RemediationInputAddIssues
     */
    systems?: Array<string>;
}
/**
 *
 * @export
 * @interface RemediationIssue
 */
export interface RemediationIssue {
    /**
     *
     * @type {string}
     * @memberof RemediationIssue
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationIssue
     */
    description: string;
    /**
     *
     * @type {RemediationIssueResolution}
     * @memberof RemediationIssue
     */
    resolution: RemediationIssueResolution;
    /**
     * The total number of available resolutions for this issue
     * @type {number}
     * @memberof RemediationIssue
     */
    resolutions_available?: number;
    /**
     *
     * @type {Array<SystemOut>}
     * @memberof RemediationIssue
     */
    systems: Array<SystemOut>;
}
/**
 *
 * @export
 * @interface RemediationIssueIn
 */
export interface RemediationIssueIn {
    /**
     *
     * @type {string}
     * @memberof RemediationIssueIn
     */
    resolution: string;
}
/**
 *
 * @export
 * @interface RemediationIssueResolution
 */
export interface RemediationIssueResolution {
    /**
     *
     * @type {string}
     * @memberof RemediationIssueResolution
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationIssueResolution
     */
    description: string;
    /**
     *
     * @type {ResolutionRisk}
     * @memberof RemediationIssueResolution
     */
    resolution_risk: ResolutionRisk;
    /**
     * Indicates whether the given resolution involves system reboot
     * @type {boolean}
     * @memberof RemediationIssueResolution
     */
    needs_reboot: boolean;
}
/**
 *
 * @export
 * @interface RemediationIssueSystemList
 */
export interface RemediationIssueSystemList {
    /**
     *
     * @type {Array<SystemOut>}
     * @memberof RemediationIssueSystemList
     */
    data: Array<SystemOut>;
    /**
     *
     * @type {Meta}
     * @memberof RemediationIssueSystemList
     */
    meta: Meta;
}
/**
 *
 * @export
 * @interface RemediationList
 */
export interface RemediationList {
    /**
     *
     * @type {Array<RemediationListItem>}
     * @memberof RemediationList
     */
    data: Array<RemediationListItem>;
    /**
     *
     * @type {Meta}
     * @memberof RemediationList
     */
    meta: Meta;
    /**
     *
     * @type {RemediationListLinks}
     * @memberof RemediationList
     */
    links: RemediationListLinks;
}
/**
 *
 * @export
 * @interface RemediationListItem
 */
export interface RemediationListItem {
    /**
     *
     * @type {string}
     * @memberof RemediationListItem
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RemediationListItem
     */
    name: string | null;
    /**
     *
     * @type {UserOut}
     * @memberof RemediationListItem
     */
    created_by: UserOut;
    /**
     *
     * @type {string}
     * @memberof RemediationListItem
     */
    created_at: string;
    /**
     *
     * @type {UserOut}
     * @memberof RemediationListItem
     */
    updated_by: UserOut;
    /**
     *
     * @type {string}
     * @memberof RemediationListItem
     */
    updated_at: string;
    /**
     *
     * @type {number}
     * @memberof RemediationListItem
     */
    issue_count: number;
    /**
     *
     * @type {number}
     * @memberof RemediationListItem
     */
    system_count: number;
    /**
     *
     * @type {number}
     * @memberof RemediationListItem
     */
    resolved_count: number;
    /**
     * Indicates whether any of the issues contained in the remediation require system reboot
     * @type {boolean}
     * @memberof RemediationListItem
     */
    needs_reboot: boolean;
    /**
     * Indicates whether a remediation has been marked as archived
     * @type {boolean}
     * @memberof RemediationListItem
     */
    archived: boolean;
    /**
     *
     * @type {Array<PlaybookRunDetails>}
     * @memberof RemediationListItem
     */
    playbook_runs?: Array<PlaybookRunDetails>;
}
/**
 *
 * @export
 * @interface RemediationListLinks
 */
export interface RemediationListLinks {
    /**
     * relative link to the first page of the query results
     * @type {string}
     * @memberof RemediationListLinks
     */
    first: string;
    /**
     * relative link to the last page of the query results
     * @type {string}
     * @memberof RemediationListLinks
     */
    last: string;
    /**
     * relative link to the next page of the query results (or null if this is the last page)
     * @type {string}
     * @memberof RemediationListLinks
     */
    next: string | null;
    /**
     * relative link to the previous page of the query results (or null if this is the first page)
     * @type {string}
     * @memberof RemediationListLinks
     */
    previous: string | null;
}
/**
 *
 * @export
 * @interface RemediationsList
 */
export interface RemediationsList {
    /**
     *
     * @type {Array<string>}
     * @memberof RemediationsList
     */
    remediation_ids: Array<string>;
}
/**
 *
 * @export
 * @interface RequestError
 */
export interface RequestError {
    /**
     *
     * @type {Array<RequestErrorErrors>}
     * @memberof RequestError
     */
    errors: Array<RequestErrorErrors>;
}
/**
 *
 * @export
 * @interface RequestErrorErrors
 */
export interface RequestErrorErrors {
    /**
     *
     * @type {string}
     * @memberof RequestErrorErrors
     */
    id: string;
    /**
     *
     * @type {number}
     * @memberof RequestErrorErrors
     */
    status: number;
    /**
     *
     * @type {string}
     * @memberof RequestErrorErrors
     */
    code: string;
    /**
     *
     * @type {string}
     * @memberof RequestErrorErrors
     */
    title: string;
    /**
     *
     * @type {object}
     * @memberof RequestErrorErrors
     */
    details?: object;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ResolutionRisk {
    NUMBER_MINUS_1 = -1,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3,
    NUMBER_4 = 4
}

/**
 *
 * @export
 * @interface Resolutions
 */
export interface Resolutions {
    /**
     *
     * @type {string}
     * @memberof Resolutions
     */
    id: string;
    /**
     *
     * @type {ResolutionRisk}
     * @memberof Resolutions
     */
    resolution_risk: ResolutionRisk;
    /**
     *
     * @type {Array<ResolutionsResolutions>}
     * @memberof Resolutions
     */
    resolutions: Array<ResolutionsResolutions>;
}
/**
 *
 * @export
 * @interface ResolutionsBatchInput
 */
export interface ResolutionsBatchInput {
    /**
     *
     * @type {Array<string>}
     * @memberof ResolutionsBatchInput
     */
    issues: Array<string>;
}
/**
 *
 * @export
 * @interface ResolutionsResolutions
 */
export interface ResolutionsResolutions {
    /**
     *
     * @type {string}
     * @memberof ResolutionsResolutions
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ResolutionsResolutions
     */
    description: string;
    /**
     * Indicates whether the given resolution involves system reboot
     * @type {boolean}
     * @memberof ResolutionsResolutions
     */
    needs_reboot: boolean;
    /**
     *
     * @type {ResolutionRisk}
     * @memberof ResolutionsResolutions
     */
    resolution_risk: ResolutionRisk;
}
/**
 *
 * @export
 * @interface SystemOut
 */
export interface SystemOut {
    /**
     *
     * @type {string}
     * @memberof SystemOut
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof SystemOut
     */
    hostname: string | null;
    /**
     *
     * @type {string}
     * @memberof SystemOut
     */
    display_name: string | null;
    /**
     *
     * @type {boolean}
     * @memberof SystemOut
     */
    resolved?: boolean;
}
/**
 *
 * @export
 * @interface UserOut
 */
export interface UserOut {
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    first_name?: string;
    /**
     *
     * @type {string}
     * @memberof UserOut
     */
    last_name?: string;
}

/**
 * DiagnosisApi - axios parameter creator
 * @export
 */
export const DiagnosisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides host-specific diagnosis information
         * @summary host-specific diagnosis
         * @param {string} system System identifier
         * @param {string} [remediation] Remediation identifier (uuid)
         * @param {string} [branchId] Branch ID passed by satellite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnosis: async (system: string, remediation?: string, branchId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'system' is not null or undefined
            if (system === null || system === undefined) {
                throw new RequiredError('system','Required parameter system was null or undefined when calling getDiagnosis.');
            }
            const localVarPath = `/diagnosis/{system}`
                .replace(`{${"system"}}`, encodeURIComponent(String(system)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (remediation !== undefined) {
                localVarQueryParameter['remediation'] = remediation;
            }

            if (branchId !== undefined) {
                localVarQueryParameter['branch_id'] = branchId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosisApi - functional programming interface
 * @export
 */
export const DiagnosisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides host-specific diagnosis information
         * @summary host-specific diagnosis
         * @param {string} system System identifier
         * @param {string} [remediation] Remediation identifier (uuid)
         * @param {string} [branchId] Branch ID passed by satellite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiagnosis(system: string, remediation?: string, branchId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Diagnosis>> {
            const localVarAxiosArgs = await DiagnosisApiAxiosParamCreator(configuration).getDiagnosis(system, remediation, branchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DiagnosisApi - factory interface
 * @export
 */
export const DiagnosisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Provides host-specific diagnosis information
         * @summary host-specific diagnosis
         * @param {string} system System identifier
         * @param {string} [remediation] Remediation identifier (uuid)
         * @param {string} [branchId] Branch ID passed by satellite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnosis(system: string, remediation?: string, branchId?: string, options?: any): AxiosPromise<Diagnosis> {
            return DiagnosisApiFp(configuration).getDiagnosis(system, remediation, branchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiagnosisApi - object-oriented interface
 * @export
 * @class DiagnosisApi
 * @extends {BaseAPI}
 */
export class DiagnosisApi extends BaseAPI {
    /**
     * Provides host-specific diagnosis information
     * @summary host-specific diagnosis
     * @param {string} system System identifier
     * @param {string} [remediation] Remediation identifier (uuid)
     * @param {string} [branchId] Branch ID passed by satellite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosisApi
     */
    public getDiagnosis(system: string, remediation?: string, branchId?: string, options?: any) {
        return DiagnosisApiFp(this.configuration).getDiagnosis(system, remediation, branchId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GeneratorApi - axios parameter creator
 * @export
 */
export const GeneratorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates an Ansible Playbook based on input parameters
         * @summary Generate an Ansible Playbook
         * @param {PlaybookDefinition} playbookDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (playbookDefinition: PlaybookDefinition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playbookDefinition' is not null or undefined
            if (playbookDefinition === null || playbookDefinition === undefined) {
                throw new RequiredError('playbookDefinition','Required parameter playbookDefinition was null or undefined when calling generate.');
            }
            const localVarPath = `/playbook`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbookDefinition !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbookDefinition !== undefined ? playbookDefinition : {}) : (playbookDefinition || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneratorApi - functional programming interface
 * @export
 */
export const GeneratorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generates an Ansible Playbook based on input parameters
         * @summary Generate an Ansible Playbook
         * @param {PlaybookDefinition} playbookDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(playbookDefinition: PlaybookDefinition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GeneratorApiAxiosParamCreator(configuration).generate(playbookDefinition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GeneratorApi - factory interface
 * @export
 */
export const GeneratorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Generates an Ansible Playbook based on input parameters
         * @summary Generate an Ansible Playbook
         * @param {PlaybookDefinition} playbookDefinition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(playbookDefinition: PlaybookDefinition, options?: any): AxiosPromise<string> {
            return GeneratorApiFp(configuration).generate(playbookDefinition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeneratorApi - object-oriented interface
 * @export
 * @class GeneratorApi
 * @extends {BaseAPI}
 */
export class GeneratorApi extends BaseAPI {
    /**
     * Generates an Ansible Playbook based on input parameters
     * @summary Generate an Ansible Playbook
     * @param {PlaybookDefinition} playbookDefinition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneratorApi
     */
    public generate(playbookDefinition: PlaybookDefinition, options?: any) {
        return GeneratorApiFp(this.configuration).generate(playbookDefinition, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RemediationsApi - axios parameter creator
 * @export
 */
export const RemediationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel execution of the remediation
         * @summary Cancel execution of the remediation
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPlaybookRuns: async (id: string, playbookRunId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancelPlaybookRuns.');
            }
            // verify required parameter 'playbookRunId' is not null or undefined
            if (playbookRunId === null || playbookRunId === undefined) {
                throw new RequiredError('playbookRunId','Required parameter playbookRunId was null or undefined when calling cancelPlaybookRuns.');
            }
            const localVarPath = `/remediations/{id}/playbook_runs/{playbook_run_id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbook_run_id"}}`, encodeURIComponent(String(playbookRunId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks remediation for the existence of smart_managment flaged systems
         * @summary Check smart_managment systems
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExecutable: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling checkExecutable.');
            }
            const localVarPath = `/remediations/{id}/executable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Remediation based on given information, RBAC permission {remediations:remediation:write}
         * @summary Create Remediation
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemediation: async (remediationInput: RemediationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'remediationInput' is not null or undefined
            if (remediationInput === null || remediationInput === undefined) {
                throw new RequiredError('remediationInput','Required parameter remediationInput was null or undefined when calling createRemediation.');
            }
            const localVarPath = `/remediations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof remediationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remediationInput !== undefined ? remediationInput : {}) : (remediationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediation: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRemediation.');
            }
            const localVarPath = `/remediations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given Issue from the Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssue: async (id: string, issue: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRemediationIssue.');
            }
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling deleteRemediationIssue.');
            }
            const localVarPath = `/remediations/{id}/issues/{issue}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given System from the Issue Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation Issue System
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssueSystem: async (id: string, issue: string, system: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRemediationIssueSystem.');
            }
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling deleteRemediationIssueSystem.');
            }
            // verify required parameter 'system' is not null or undefined
            if (system === null || system === undefined) {
                throw new RequiredError('system','Required parameter system was null or undefined when calling deleteRemediationIssueSystem.');
            }
            const localVarPath = `/remediations/{id}/issues/{issue}/systems/{system}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)))
                .replace(`{${"system"}}`, encodeURIComponent(String(system)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given list of Remediations.  Requests containing malformed remediation IDs are rejected.  Duplicate or missing IDs are ignored. RBAC permission {remediations:remediation:write}
         * @summary Bulk Delete Remediations
         * @param {RemediationsList} remediationsList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediations: async (remediationsList: RemediationsList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'remediationsList' is not null or undefined
            if (remediationsList === null || remediationsList === undefined) {
                throw new RequiredError('remediationsList','Required parameter remediationsList was null or undefined when calling deleteRemediations.');
            }
            const localVarPath = `/remediations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof remediationsList !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remediationsList !== undefined ? remediationsList : {}) : (remediationsList || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a zip file containing selected Remediations, RBAC permission {remediations:remediation:read}
         * @summary Download Remediations
         * @param {Array<string>} [selectedRemediations] Selected Remediations for download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPlaybooks: async (selectedRemediations?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/remediations/download`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (selectedRemediations) {
                localVarQueryParameter['selected_remediations'] = selectedRemediations;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details on execution of the remediation
         * @summary Get details on execution of the remediation
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybookRunDetails: async (id: string, playbookRunId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPlaybookRunDetails.');
            }
            // verify required parameter 'playbookRunId' is not null or undefined
            if (playbookRunId === null || playbookRunId === undefined) {
                throw new RequiredError('playbookRunId','Required parameter playbookRunId was null or undefined when calling getPlaybookRunDetails.');
            }
            const localVarPath = `/remediations/{id}/playbook_runs/{playbook_run_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbook_run_id"}}`, encodeURIComponent(String(playbookRunId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details and updated log of system being executed on in specific playbook run
         * @summary Get details and updated log of system being executed on in specific playbook run
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybookRunSystemDetails: async (id: string, playbookRunId: string, system: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPlaybookRunSystemDetails.');
            }
            // verify required parameter 'playbookRunId' is not null or undefined
            if (playbookRunId === null || playbookRunId === undefined) {
                throw new RequiredError('playbookRunId','Required parameter playbookRunId was null or undefined when calling getPlaybookRunSystemDetails.');
            }
            // verify required parameter 'system' is not null or undefined
            if (system === null || system === undefined) {
                throw new RequiredError('system','Required parameter system was null or undefined when calling getPlaybookRunSystemDetails.');
            }
            const localVarPath = `/remediations/{id}/playbook_runs/{playbook_run_id}/systems/{system}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbook_run_id"}}`, encodeURIComponent(String(playbookRunId)))
                .replace(`{${"system"}}`, encodeURIComponent(String(system)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details on systems being executed on in specific playbook run
         * @summary Get details on systems being executed on in specific playbook run
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {string} [executor] Playbook run executor identifier (UUID)
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [ansibleHost] System Name (STRING)
         * @param {'system_name' | '-system_name'} [sort] Playbook run systems sort order by ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybookRunSystems: async (id: string, playbookRunId: string, executor?: string, limit?: number, offset?: number, ansibleHost?: string, sort?: 'system_name' | '-system_name', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPlaybookRunSystems.');
            }
            // verify required parameter 'playbookRunId' is not null or undefined
            if (playbookRunId === null || playbookRunId === undefined) {
                throw new RequiredError('playbookRunId','Required parameter playbookRunId was null or undefined when calling getPlaybookRunSystems.');
            }
            const localVarPath = `/remediations/{id}/playbook_runs/{playbook_run_id}/systems`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"playbook_run_id"}}`, encodeURIComponent(String(playbookRunId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (executor !== undefined) {
                localVarQueryParameter['executor'] = executor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ansibleHost !== undefined) {
                localVarQueryParameter['ansible_host'] = ansibleHost;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about the given Remediation, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediation: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemediation.');
            }
            const localVarPath = `/remediations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get satellite connection status for a given host, RBAC permission {remediations:remediation:execute}
         * @summary Pre-flight check
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationConnectionStatus: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemediationConnectionStatus.');
            }
            const localVarPath = `/remediations/{id}/connection_status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of systems from a given issue, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation Issue Systems
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {'display_name' | '-display_name'} [sort] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationIssueSystems: async (id: string, issue: string, limit?: number, offset?: number, sort?: 'display_name' | '-display_name', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemediationIssueSystems.');
            }
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling getRemediationIssueSystems.');
            }
            const localVarPath = `/remediations/{id}/issues/{issue}/systems`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides Ansible Playbook, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation Playbook
         * @param {string} id Remediation identifier
         * @param {Array<string>} [hosts] Selected hosts to be included in playbook
         * @param {string} [satOrg] Organization ID passed by satellite
         * @param {boolean} [localhost] Flag for localhost playbook generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationPlaybook: async (id: string, hosts?: Array<string>, satOrg?: string, localhost?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemediationPlaybook.');
            }
            const localVarPath = `/remediations/{id}/playbook`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hosts) {
                localVarQueryParameter['hosts'] = hosts;
            }

            if (satOrg !== undefined) {
                localVarQueryParameter['sat_org'] = satOrg;
            }

            if (localhost !== undefined) {
                localVarQueryParameter['localhost'] = localhost;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about Remediations, RBAC permission {remediations:remediation:read}
         * @summary List Remediations
         * @param {'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count'} [sort] Sort order
         * @param {string} [filter] Remediation name filter. If specified only remediations whose name matches the given string will be returned.
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [system] System identifier. If specified only remediations that involve the given system will be returned.
         * @param {boolean} [hideArchived] Hide archived playbooks
         * @param {Array<'playbook_runs'>} [fieldsData] Add playbook run data to the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediations: async (sort?: 'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count', filter?: string, limit?: number, offset?: number, system?: string, hideArchived?: boolean, fieldsData?: Array<'playbook_runs'>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/remediations`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }

            if (hideArchived !== undefined) {
                localVarQueryParameter['hide_archived'] = hideArchived;
            }

            if (fieldsData) {
                localVarQueryParameter['fields[data]'] = fieldsData;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of executions of this remediation
         * @summary List of executions of this remediation
         * @param {string} id Remediation identifier
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {'updated_at' | '-updated_at'} [sort] Sort Order for Playbook Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaybookRuns: async (id: string, limit?: number, offset?: number, sort?: 'updated_at' | '-updated_at', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling listPlaybookRuns.');
            }
            const localVarPath = `/remediations/{id}/playbook_runs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute remediation, RBAC permission {remediations:remediation:execute}
         * @summary Execute remediation
         * @param {string} id Remediation identifier
         * @param {PlaybookRunsInput} [playbookRunsInput]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runRemediation: async (id: string, playbookRunsInput?: PlaybookRunsInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling runRemediation.');
            }
            const localVarPath = `/remediations/{id}/playbook_runs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbookRunsInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbookRunsInput !== undefined ? playbookRunsInput : {}) : (playbookRunsInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given Remediation, RBAC permission {remediations:remediation:write}
         * @summary Update Remediation
         * @param {string} id Remediation identifier
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediation: async (id: string, remediationInput: RemediationInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRemediation.');
            }
            // verify required parameter 'remediationInput' is not null or undefined
            if (remediationInput === null || remediationInput === undefined) {
                throw new RequiredError('remediationInput','Required parameter remediationInput was null or undefined when calling updateRemediation.');
            }
            const localVarPath = `/remediations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof remediationInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remediationInput !== undefined ? remediationInput : {}) : (remediationInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given Remediation Issue, RBAC permission {remediations:remediation:write}
         * @summary Update Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {RemediationIssueIn} remediationIssueIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediationIssue: async (id: string, issue: string, remediationIssueIn: RemediationIssueIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRemediationIssue.');
            }
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling updateRemediationIssue.');
            }
            // verify required parameter 'remediationIssueIn' is not null or undefined
            if (remediationIssueIn === null || remediationIssueIn === undefined) {
                throw new RequiredError('remediationIssueIn','Required parameter remediationIssueIn was null or undefined when calling updateRemediationIssue.');
            }
            const localVarPath = `/remediations/{id}/issues/{issue}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof remediationIssueIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remediationIssueIn !== undefined ? remediationIssueIn : {}) : (remediationIssueIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemediationsApi - functional programming interface
 * @export
 */
export const RemediationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Cancel execution of the remediation
         * @summary Cancel execution of the remediation
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPlaybookRuns(id: string, playbookRunId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).cancelPlaybookRuns(id, playbookRunId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Checks remediation for the existence of smart_managment flaged systems
         * @summary Check smart_managment systems
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkExecutable(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).checkExecutable(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new Remediation based on given information, RBAC permission {remediations:remediation:write}
         * @summary Create Remediation
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRemediation(remediationInput: RemediationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationCreated>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).createRemediation(remediationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the given Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRemediation(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).deleteRemediation(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the given Issue from the Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRemediationIssue(id: string, issue: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).deleteRemediationIssue(id, issue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the given System from the Issue Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation Issue System
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRemediationIssueSystem(id: string, issue: string, system: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).deleteRemediationIssueSystem(id, issue, system, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the given list of Remediations.  Requests containing malformed remediation IDs are rejected.  Duplicate or missing IDs are ignored. RBAC permission {remediations:remediation:write}
         * @summary Bulk Delete Remediations
         * @param {RemediationsList} remediationsList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRemediations(remediationsList: RemediationsList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleDelete>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).deleteRemediations(remediationsList, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Downloads a zip file containing selected Remediations, RBAC permission {remediations:remediation:read}
         * @summary Download Remediations
         * @param {Array<string>} [selectedRemediations] Selected Remediations for download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadPlaybooks(selectedRemediations?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).downloadPlaybooks(selectedRemediations, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get details on execution of the remediation
         * @summary Get details on execution of the remediation
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaybookRunDetails(id: string, playbookRunId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybookRunExecutorDetails>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).getPlaybookRunDetails(id, playbookRunId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get details and updated log of system being executed on in specific playbook run
         * @summary Get details and updated log of system being executed on in specific playbook run
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaybookRunSystemDetails(id: string, playbookRunId: string, system: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybookRunSystemDetails>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).getPlaybookRunSystemDetails(id, playbookRunId, system, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get details on systems being executed on in specific playbook run
         * @summary Get details on systems being executed on in specific playbook run
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {string} [executor] Playbook run executor identifier (UUID)
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [ansibleHost] System Name (STRING)
         * @param {'system_name' | '-system_name'} [sort] Playbook run systems sort order by ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaybookRunSystems(id: string, playbookRunId: string, executor?: string, limit?: number, offset?: number, ansibleHost?: string, sort?: 'system_name' | '-system_name', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybookRunSystemList>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).getPlaybookRunSystems(id, playbookRunId, executor, limit, offset, ansibleHost, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides information about the given Remediation, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemediation(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationDetails>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).getRemediation(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get satellite connection status for a given host, RBAC permission {remediations:remediation:execute}
         * @summary Pre-flight check
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemediationConnectionStatus(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationConnectionStatus>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).getRemediationConnectionStatus(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a paginated list of systems from a given issue, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation Issue Systems
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {'display_name' | '-display_name'} [sort] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemediationIssueSystems(id: string, issue: string, limit?: number, offset?: number, sort?: 'display_name' | '-display_name', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationIssueSystemList>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).getRemediationIssueSystems(id, issue, limit, offset, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides Ansible Playbook, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation Playbook
         * @param {string} id Remediation identifier
         * @param {Array<string>} [hosts] Selected hosts to be included in playbook
         * @param {string} [satOrg] Organization ID passed by satellite
         * @param {boolean} [localhost] Flag for localhost playbook generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemediationPlaybook(id: string, hosts?: Array<string>, satOrg?: string, localhost?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).getRemediationPlaybook(id, hosts, satOrg, localhost, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides information about Remediations, RBAC permission {remediations:remediation:read}
         * @summary List Remediations
         * @param {'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count'} [sort] Sort order
         * @param {string} [filter] Remediation name filter. If specified only remediations whose name matches the given string will be returned.
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [system] System identifier. If specified only remediations that involve the given system will be returned.
         * @param {boolean} [hideArchived] Hide archived playbooks
         * @param {Array<'playbook_runs'>} [fieldsData] Add playbook run data to the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemediations(sort?: 'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count', filter?: string, limit?: number, offset?: number, system?: string, hideArchived?: boolean, fieldsData?: Array<'playbook_runs'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemediationList>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).getRemediations(sort, filter, limit, offset, system, hideArchived, fieldsData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of executions of this remediation
         * @summary List of executions of this remediation
         * @param {string} id Remediation identifier
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {'updated_at' | '-updated_at'} [sort] Sort Order for Playbook Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlaybookRuns(id: string, limit?: number, offset?: number, sort?: 'updated_at' | '-updated_at', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybookRunsList>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).listPlaybookRuns(id, limit, offset, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Execute remediation, RBAC permission {remediations:remediation:execute}
         * @summary Execute remediation
         * @param {string} id Remediation identifier
         * @param {PlaybookRunsInput} [playbookRunsInput]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runRemediation(id: string, playbookRunsInput?: PlaybookRunsInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteRemediation>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).runRemediation(id, playbookRunsInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the given Remediation, RBAC permission {remediations:remediation:write}
         * @summary Update Remediation
         * @param {string} id Remediation identifier
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRemediation(id: string, remediationInput: RemediationInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).updateRemediation(id, remediationInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the given Remediation Issue, RBAC permission {remediations:remediation:write}
         * @summary Update Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {RemediationIssueIn} remediationIssueIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRemediationIssue(id: string, issue: string, remediationIssueIn: RemediationIssueIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemediationsApiAxiosParamCreator(configuration).updateRemediationIssue(id, issue, remediationIssueIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RemediationsApi - factory interface
 * @export
 */
export const RemediationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Cancel execution of the remediation
         * @summary Cancel execution of the remediation
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPlaybookRuns(id: string, playbookRunId: string, options?: any): AxiosPromise<object> {
            return RemediationsApiFp(configuration).cancelPlaybookRuns(id, playbookRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks remediation for the existence of smart_managment flaged systems
         * @summary Check smart_managment systems
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkExecutable(id: string, options?: any): AxiosPromise<void> {
            return RemediationsApiFp(configuration).checkExecutable(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Remediation based on given information, RBAC permission {remediations:remediation:write}
         * @summary Create Remediation
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRemediation(remediationInput: RemediationInput, options?: any): AxiosPromise<RemediationCreated> {
            return RemediationsApiFp(configuration).createRemediation(remediationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the given Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediation(id: string, options?: any): AxiosPromise<void> {
            return RemediationsApiFp(configuration).deleteRemediation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the given Issue from the Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssue(id: string, issue: string, options?: any): AxiosPromise<void> {
            return RemediationsApiFp(configuration).deleteRemediationIssue(id, issue, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the given System from the Issue Remediation, RBAC permission {remediations:remediation:write}
         * @summary Remove Remediation Issue System
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediationIssueSystem(id: string, issue: string, system: string, options?: any): AxiosPromise<void> {
            return RemediationsApiFp(configuration).deleteRemediationIssueSystem(id, issue, system, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the given list of Remediations.  Requests containing malformed remediation IDs are rejected.  Duplicate or missing IDs are ignored. RBAC permission {remediations:remediation:write}
         * @summary Bulk Delete Remediations
         * @param {RemediationsList} remediationsList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRemediations(remediationsList: RemediationsList, options?: any): AxiosPromise<MultipleDelete> {
            return RemediationsApiFp(configuration).deleteRemediations(remediationsList, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a zip file containing selected Remediations, RBAC permission {remediations:remediation:read}
         * @summary Download Remediations
         * @param {Array<string>} [selectedRemediations] Selected Remediations for download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadPlaybooks(selectedRemediations?: Array<string>, options?: any): AxiosPromise<any> {
            return RemediationsApiFp(configuration).downloadPlaybooks(selectedRemediations, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details on execution of the remediation
         * @summary Get details on execution of the remediation
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybookRunDetails(id: string, playbookRunId: string, options?: any): AxiosPromise<PlaybookRunExecutorDetails> {
            return RemediationsApiFp(configuration).getPlaybookRunDetails(id, playbookRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details and updated log of system being executed on in specific playbook run
         * @summary Get details and updated log of system being executed on in specific playbook run
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {string} system System identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybookRunSystemDetails(id: string, playbookRunId: string, system: string, options?: any): AxiosPromise<PlaybookRunSystemDetails> {
            return RemediationsApiFp(configuration).getPlaybookRunSystemDetails(id, playbookRunId, system, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details on systems being executed on in specific playbook run
         * @summary Get details on systems being executed on in specific playbook run
         * @param {string} id Remediation identifier
         * @param {string} playbookRunId Playbook run identifier (UUID)
         * @param {string} [executor] Playbook run executor identifier (UUID)
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [ansibleHost] System Name (STRING)
         * @param {'system_name' | '-system_name'} [sort] Playbook run systems sort order by ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybookRunSystems(id: string, playbookRunId: string, executor?: string, limit?: number, offset?: number, ansibleHost?: string, sort?: 'system_name' | '-system_name', options?: any): AxiosPromise<PlaybookRunSystemList> {
            return RemediationsApiFp(configuration).getPlaybookRunSystems(id, playbookRunId, executor, limit, offset, ansibleHost, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides information about the given Remediation, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediation(id: string, options?: any): AxiosPromise<RemediationDetails> {
            return RemediationsApiFp(configuration).getRemediation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get satellite connection status for a given host, RBAC permission {remediations:remediation:execute}
         * @summary Pre-flight check
         * @param {string} id Remediation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationConnectionStatus(id: string, options?: any): AxiosPromise<RemediationConnectionStatus> {
            return RemediationsApiFp(configuration).getRemediationConnectionStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of systems from a given issue, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation Issue Systems
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {'display_name' | '-display_name'} [sort] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationIssueSystems(id: string, issue: string, limit?: number, offset?: number, sort?: 'display_name' | '-display_name', options?: any): AxiosPromise<RemediationIssueSystemList> {
            return RemediationsApiFp(configuration).getRemediationIssueSystems(id, issue, limit, offset, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides Ansible Playbook, RBAC permission {remediations:remediation:read}
         * @summary Get Remediation Playbook
         * @param {string} id Remediation identifier
         * @param {Array<string>} [hosts] Selected hosts to be included in playbook
         * @param {string} [satOrg] Organization ID passed by satellite
         * @param {boolean} [localhost] Flag for localhost playbook generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediationPlaybook(id: string, hosts?: Array<string>, satOrg?: string, localhost?: boolean, options?: any): AxiosPromise<string> {
            return RemediationsApiFp(configuration).getRemediationPlaybook(id, hosts, satOrg, localhost, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides information about Remediations, RBAC permission {remediations:remediation:read}
         * @summary List Remediations
         * @param {'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count'} [sort] Sort order
         * @param {string} [filter] Remediation name filter. If specified only remediations whose name matches the given string will be returned.
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {string} [system] System identifier. If specified only remediations that involve the given system will be returned.
         * @param {boolean} [hideArchived] Hide archived playbooks
         * @param {Array<'playbook_runs'>} [fieldsData] Add playbook run data to the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemediations(sort?: 'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count', filter?: string, limit?: number, offset?: number, system?: string, hideArchived?: boolean, fieldsData?: Array<'playbook_runs'>, options?: any): AxiosPromise<RemediationList> {
            return RemediationsApiFp(configuration).getRemediations(sort, filter, limit, offset, system, hideArchived, fieldsData, options).then((request) => request(axios, basePath));
        },
        /**
         * List of executions of this remediation
         * @summary List of executions of this remediation
         * @param {string} id Remediation identifier
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
         * @param {'updated_at' | '-updated_at'} [sort] Sort Order for Playbook Run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaybookRuns(id: string, limit?: number, offset?: number, sort?: 'updated_at' | '-updated_at', options?: any): AxiosPromise<PlaybookRunsList> {
            return RemediationsApiFp(configuration).listPlaybookRuns(id, limit, offset, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute remediation, RBAC permission {remediations:remediation:execute}
         * @summary Execute remediation
         * @param {string} id Remediation identifier
         * @param {PlaybookRunsInput} [playbookRunsInput]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runRemediation(id: string, playbookRunsInput?: PlaybookRunsInput, options?: any): AxiosPromise<ExecuteRemediation> {
            return RemediationsApiFp(configuration).runRemediation(id, playbookRunsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given Remediation, RBAC permission {remediations:remediation:write}
         * @summary Update Remediation
         * @param {string} id Remediation identifier
         * @param {RemediationInput} remediationInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediation(id: string, remediationInput: RemediationInput, options?: any): AxiosPromise<void> {
            return RemediationsApiFp(configuration).updateRemediation(id, remediationInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given Remediation Issue, RBAC permission {remediations:remediation:write}
         * @summary Update Remediation Issue
         * @param {string} id Remediation identifier
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {RemediationIssueIn} remediationIssueIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRemediationIssue(id: string, issue: string, remediationIssueIn: RemediationIssueIn, options?: any): AxiosPromise<void> {
            return RemediationsApiFp(configuration).updateRemediationIssue(id, issue, remediationIssueIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemediationsApi - object-oriented interface
 * @export
 * @class RemediationsApi
 * @extends {BaseAPI}
 */
export class RemediationsApi extends BaseAPI {
    /**
     * Cancel execution of the remediation
     * @summary Cancel execution of the remediation
     * @param {string} id Remediation identifier
     * @param {string} playbookRunId Playbook run identifier (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public cancelPlaybookRuns(id: string, playbookRunId: string, options?: any) {
        return RemediationsApiFp(this.configuration).cancelPlaybookRuns(id, playbookRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks remediation for the existence of smart_managment flaged systems
     * @summary Check smart_managment systems
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public checkExecutable(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).checkExecutable(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Remediation based on given information, RBAC permission {remediations:remediation:write}
     * @summary Create Remediation
     * @param {RemediationInput} remediationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public createRemediation(remediationInput: RemediationInput, options?: any) {
        return RemediationsApiFp(this.configuration).createRemediation(remediationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the given Remediation, RBAC permission {remediations:remediation:write}
     * @summary Remove Remediation
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public deleteRemediation(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).deleteRemediation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the given Issue from the Remediation, RBAC permission {remediations:remediation:write}
     * @summary Remove Remediation Issue
     * @param {string} id Remediation identifier
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public deleteRemediationIssue(id: string, issue: string, options?: any) {
        return RemediationsApiFp(this.configuration).deleteRemediationIssue(id, issue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the given System from the Issue Remediation, RBAC permission {remediations:remediation:write}
     * @summary Remove Remediation Issue System
     * @param {string} id Remediation identifier
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {string} system System identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public deleteRemediationIssueSystem(id: string, issue: string, system: string, options?: any) {
        return RemediationsApiFp(this.configuration).deleteRemediationIssueSystem(id, issue, system, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the given list of Remediations.  Requests containing malformed remediation IDs are rejected.  Duplicate or missing IDs are ignored. RBAC permission {remediations:remediation:write}
     * @summary Bulk Delete Remediations
     * @param {RemediationsList} remediationsList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public deleteRemediations(remediationsList: RemediationsList, options?: any) {
        return RemediationsApiFp(this.configuration).deleteRemediations(remediationsList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads a zip file containing selected Remediations, RBAC permission {remediations:remediation:read}
     * @summary Download Remediations
     * @param {Array<string>} [selectedRemediations] Selected Remediations for download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public downloadPlaybooks(selectedRemediations?: Array<string>, options?: any) {
        return RemediationsApiFp(this.configuration).downloadPlaybooks(selectedRemediations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details on execution of the remediation
     * @summary Get details on execution of the remediation
     * @param {string} id Remediation identifier
     * @param {string} playbookRunId Playbook run identifier (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getPlaybookRunDetails(id: string, playbookRunId: string, options?: any) {
        return RemediationsApiFp(this.configuration).getPlaybookRunDetails(id, playbookRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details and updated log of system being executed on in specific playbook run
     * @summary Get details and updated log of system being executed on in specific playbook run
     * @param {string} id Remediation identifier
     * @param {string} playbookRunId Playbook run identifier (UUID)
     * @param {string} system System identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getPlaybookRunSystemDetails(id: string, playbookRunId: string, system: string, options?: any) {
        return RemediationsApiFp(this.configuration).getPlaybookRunSystemDetails(id, playbookRunId, system, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details on systems being executed on in specific playbook run
     * @summary Get details on systems being executed on in specific playbook run
     * @param {string} id Remediation identifier
     * @param {string} playbookRunId Playbook run identifier (UUID)
     * @param {string} [executor] Playbook run executor identifier (UUID)
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
     * @param {string} [ansibleHost] System Name (STRING)
     * @param {'system_name' | '-system_name'} [sort] Playbook run systems sort order by ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getPlaybookRunSystems(id: string, playbookRunId: string, executor?: string, limit?: number, offset?: number, ansibleHost?: string, sort?: 'system_name' | '-system_name', options?: any) {
        return RemediationsApiFp(this.configuration).getPlaybookRunSystems(id, playbookRunId, executor, limit, offset, ansibleHost, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides information about the given Remediation, RBAC permission {remediations:remediation:read}
     * @summary Get Remediation
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediation(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).getRemediation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get satellite connection status for a given host, RBAC permission {remediations:remediation:execute}
     * @summary Pre-flight check
     * @param {string} id Remediation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediationConnectionStatus(id: string, options?: any) {
        return RemediationsApiFp(this.configuration).getRemediationConnectionStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of systems from a given issue, RBAC permission {remediations:remediation:read}
     * @summary Get Remediation Issue Systems
     * @param {string} id Remediation identifier
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
     * @param {'display_name' | '-display_name'} [sort] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediationIssueSystems(id: string, issue: string, limit?: number, offset?: number, sort?: 'display_name' | '-display_name', options?: any) {
        return RemediationsApiFp(this.configuration).getRemediationIssueSystems(id, issue, limit, offset, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides Ansible Playbook, RBAC permission {remediations:remediation:read}
     * @summary Get Remediation Playbook
     * @param {string} id Remediation identifier
     * @param {Array<string>} [hosts] Selected hosts to be included in playbook
     * @param {string} [satOrg] Organization ID passed by satellite
     * @param {boolean} [localhost] Flag for localhost playbook generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediationPlaybook(id: string, hosts?: Array<string>, satOrg?: string, localhost?: boolean, options?: any) {
        return RemediationsApiFp(this.configuration).getRemediationPlaybook(id, hosts, satOrg, localhost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides information about Remediations, RBAC permission {remediations:remediation:read}
     * @summary List Remediations
     * @param {'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count'} [sort] Sort order
     * @param {string} [filter] Remediation name filter. If specified only remediations whose name matches the given string will be returned.
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
     * @param {string} [system] System identifier. If specified only remediations that involve the given system will be returned.
     * @param {boolean} [hideArchived] Hide archived playbooks
     * @param {Array<'playbook_runs'>} [fieldsData] Add playbook run data to the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public getRemediations(sort?: 'updated_at' | '-updated_at' | 'name' | '-name' | 'system_count' | '-system_count' | 'issue_count' | '-issue_count', filter?: string, limit?: number, offset?: number, system?: string, hideArchived?: boolean, fieldsData?: Array<'playbook_runs'>, options?: any) {
        return RemediationsApiFp(this.configuration).getRemediations(sort, filter, limit, offset, system, hideArchived, fieldsData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of executions of this remediation
     * @summary List of executions of this remediation
     * @param {string} id Remediation identifier
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Indicates the starting position of the query relative to the complete set of items that match the query
     * @param {'updated_at' | '-updated_at'} [sort] Sort Order for Playbook Run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public listPlaybookRuns(id: string, limit?: number, offset?: number, sort?: 'updated_at' | '-updated_at', options?: any) {
        return RemediationsApiFp(this.configuration).listPlaybookRuns(id, limit, offset, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute remediation, RBAC permission {remediations:remediation:execute}
     * @summary Execute remediation
     * @param {string} id Remediation identifier
     * @param {PlaybookRunsInput} [playbookRunsInput]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public runRemediation(id: string, playbookRunsInput?: PlaybookRunsInput, options?: any) {
        return RemediationsApiFp(this.configuration).runRemediation(id, playbookRunsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given Remediation, RBAC permission {remediations:remediation:write}
     * @summary Update Remediation
     * @param {string} id Remediation identifier
     * @param {RemediationInput} remediationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public updateRemediation(id: string, remediationInput: RemediationInput, options?: any) {
        return RemediationsApiFp(this.configuration).updateRemediation(id, remediationInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given Remediation Issue, RBAC permission {remediations:remediation:write}
     * @summary Update Remediation Issue
     * @param {string} id Remediation identifier
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {RemediationIssueIn} remediationIssueIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemediationsApi
     */
    public updateRemediationIssue(id: string, issue: string, remediationIssueIn: RemediationIssueIn, options?: any) {
        return RemediationsApiFp(this.configuration).updateRemediationIssue(id, issue, remediationIssueIn, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ResolutionsApi - axios parameter creator
 * @export
 */
export const ResolutionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides information about resolutions available for the given issue
         * @summary Resolution metadata
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssue: async (issue: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'issue' is not null or undefined
            if (issue === null || issue === undefined) {
                throw new RequiredError('issue','Required parameter issue was null or undefined when calling getResolutionsForIssue.');
            }
            const localVarPath = `/resolutions/{issue}`
                .replace(`{${"issue"}}`, encodeURIComponent(String(issue)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides information about resolutions available for the given issues
         * @summary Resolution metadata (batch)
         * @param {ResolutionsBatchInput} resolutionsBatchInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssues: async (resolutionsBatchInput: ResolutionsBatchInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resolutionsBatchInput' is not null or undefined
            if (resolutionsBatchInput === null || resolutionsBatchInput === undefined) {
                throw new RequiredError('resolutionsBatchInput','Required parameter resolutionsBatchInput was null or undefined when calling getResolutionsForIssues.');
            }
            const localVarPath = `/resolutions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resolutionsBatchInput !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resolutionsBatchInput !== undefined ? resolutionsBatchInput : {}) : (resolutionsBatchInput || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResolutionsApi - functional programming interface
 * @export
 */
export const ResolutionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides information about resolutions available for the given issue
         * @summary Resolution metadata
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResolutionsForIssue(issue: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resolutions>> {
            const localVarAxiosArgs = await ResolutionsApiAxiosParamCreator(configuration).getResolutionsForIssue(issue, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Provides information about resolutions available for the given issues
         * @summary Resolution metadata (batch)
         * @param {ResolutionsBatchInput} resolutionsBatchInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResolutionsForIssues(resolutionsBatchInput: ResolutionsBatchInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Resolutions | boolean; }>> {
            const localVarAxiosArgs = await ResolutionsApiAxiosParamCreator(configuration).getResolutionsForIssues(resolutionsBatchInput, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ResolutionsApi - factory interface
 * @export
 */
export const ResolutionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Provides information about resolutions available for the given issue
         * @summary Resolution metadata
         * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssue(issue: string, options?: any): AxiosPromise<Resolutions> {
            return ResolutionsApiFp(configuration).getResolutionsForIssue(issue, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides information about resolutions available for the given issues
         * @summary Resolution metadata (batch)
         * @param {ResolutionsBatchInput} resolutionsBatchInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolutionsForIssues(resolutionsBatchInput: ResolutionsBatchInput, options?: any): AxiosPromise<{ [key: string]: Resolutions | boolean; }> {
            return ResolutionsApiFp(configuration).getResolutionsForIssues(resolutionsBatchInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResolutionsApi - object-oriented interface
 * @export
 * @class ResolutionsApi
 * @extends {BaseAPI}
 */
export class ResolutionsApi extends BaseAPI {
    /**
     * Provides information about resolutions available for the given issue
     * @summary Resolution metadata
     * @param {string} issue Issue identifier (e.g. &#x60;advisor:CVE_2017_6074_kernel|KERNEL_CVE_2017_6074&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionsApi
     */
    public getResolutionsForIssue(issue: string, options?: any) {
        return ResolutionsApiFp(this.configuration).getResolutionsForIssue(issue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides information about resolutions available for the given issues
     * @summary Resolution metadata (batch)
     * @param {ResolutionsBatchInput} resolutionsBatchInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolutionsApi
     */
    public getResolutionsForIssues(resolutionsBatchInput: ResolutionsBatchInput, options?: any) {
        return ResolutionsApiFp(this.configuration).getResolutionsForIssues(resolutionsBatchInput, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides information about the version of the service
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Provides information about the version of the service
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await VersionApiAxiosParamCreator(configuration).getVersion(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Provides information about the version of the service
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<InlineResponse200> {
            return VersionApiFp(configuration).getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * Provides information about the version of the service
     * @summary Get service version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getVersion(options?: any) {
        return VersionApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

}


