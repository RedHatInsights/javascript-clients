// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Insights Service Approval APIs
 * APIs to query approval service
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cloud.redhat.com//api/approval/v1.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface Action
 */
export interface Action {
    /**
     *
     * @type {string}
     * @memberof Action
     */
    id?: string;
    /**
     * Timestamp of creation
     * @type {Date}
     * @memberof Action
     */
    createdAt?: Date;
    /**
     * Timestamp of update
     * @type {Date}
     * @memberof Action
     */
    updatedAt?: Date;
    /**
     * Associated request id
     * @type {string}
     * @memberof Action
     */
    requestId?: string;
    /**
     * The person who performs the action
     * @type {string}
     * @memberof Action
     */
    processedBy?: string;
    /**
     * Types of action, may be one of the value (approve, cancel, deny, notify, memo, or skip). The request will be updated according to the operation.
     * @type {string}
     * @memberof Action
     */
    operation?: Action.OperationEnum;
    /**
     * Comments for action
     * @type {string}
     * @memberof Action
     */
    comments?: string;
}

/**
 * @export
 * @namespace Action
 */
export namespace Action {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Approve = 'approve',
        Cancel = 'cancel',
        Deny = 'deny',
        Notify = 'notify',
        Memo = 'memo',
        Skip = 'skip'
    }
}

/**
 *
 * @export
 * @interface ActionCollection
 */
export interface ActionCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ActionCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ActionCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Action>}
     * @memberof ActionCollection
     */
    data?: Array<Action>;
}

/**
 *
 * @export
 * @interface CollectionLinks
 */
export interface CollectionLinks {
    /**
     * The link to fetch the first group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    first?: string;
    /**
     * The link to fetch the last group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    last?: string;
    /**
     * The link to fetch the previous group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    prev?: string;
    /**
     * The link to fetch the next group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    next?: string;
}

/**
 *
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     * This is the total number of items in the result set, of which only a subset is returned defined by the QueryLimit parameter
     * @type {number}
     * @memberof CollectionMetadata
     */
    count?: number;
    /**
     * This is the number of items each page can display
     * @type {number}
     * @memberof CollectionMetadata
     */
    limit?: number;
    /**
     * This is the offset from beginning of the result set
     * @type {number}
     * @memberof CollectionMetadata
     */
    offset?: number;
}

/**
 *
 * @export
 * @interface GraphqlIn
 */
export interface GraphqlIn {
    /**
     * The GraphQL query
     * @type {string}
     * @memberof GraphqlIn
     */
    query: string;
    /**
     * If the Query contains several named operations, the operationName controls which one should be executed
     * @type {string}
     * @memberof GraphqlIn
     */
    operationName?: string;
    /**
     * Optional Query variables
     * @type {any}
     * @memberof GraphqlIn
     */
    variables?: any | null;
}

/**
 *
 * @export
 * @interface GraphqlOut
 */
export interface GraphqlOut {
    /**
     * Results from the GraphQL query
     * @type {any}
     * @memberof GraphqlOut
     */
    data?: any;
    /**
     * Errors resulting from the GraphQL query
     * @type {Array<any>}
     * @memberof GraphqlOut
     */
    errors?: Array<any>;
}

/**
 * Approval request. It may have child requests. Only a leaf node request can have workflow_id and actions
 * @export
 * @interface Request
 */
export interface Request {
    /**
     *
     * @type {string}
     * @memberof Request
     */
    id?: string;
    /**
     * The state of the request. Possible value: canceled, pending, skipped, notified, or finished
     * @type {string}
     * @memberof Request
     */
    state?: Request.StateEnum;
    /**
     * Approval decision. Possible value: undecided, approved, canceled, or denied
     * @type {string}
     * @memberof Request
     */
    decision?: Request.DecisionEnum;
    /**
     * Reason for the decision. Optional. Present normally when the decision is denied
     * @type {string}
     * @memberof Request
     */
    reason?: string;
    /**
     * Associate workflow id. Available only if the request is a leaf node
     * @type {string}
     * @memberof Request
     */
    workflowId?: string;
    /**
     * Timestamp of creation
     * @type {Date}
     * @memberof Request
     */
    createdAt?: Date;
    /**
     * Timestamp of last update
     * @type {Date}
     * @memberof Request
     */
    updatedAt?: Date;
    /**
     * Number of child requests
     * @type {number}
     * @memberof Request
     */
    numberOfChildren?: number;
    /**
     * Number of finished child requests
     * @type {number}
     * @memberof Request
     */
    numberOfFinishedChildren?: number;
    /**
     * Requester's id
     * @type {string}
     * @memberof Request
     */
    owner?: string;
    /**
     * Requester's full name
     * @type {string}
     * @memberof Request
     */
    requesterName?: string;
    /**
     * Request name
     * @type {string}
     * @memberof Request
     */
    name?: string;
    /**
     * Request description
     * @type {string}
     * @memberof Request
     */
    description?: string;
}

/**
 * @export
 * @namespace Request
 */
export namespace Request {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Canceled = 'canceled',
        Pending = 'pending',
        Skipped = 'skipped',
        Notified = 'notified',
        Finished = 'finished'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DecisionEnum {
        Undecided = 'undecided',
        Approved = 'approved',
        Canceled = 'canceled',
        Denied = 'denied'
    }
}

/**
 *
 * @export
 * @interface RequestCollection
 */
export interface RequestCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof RequestCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof RequestCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Request>}
     * @memberof RequestCollection
     */
    data?: Array<Request>;
}

/**
 * Input parameters for approval request object.
 * @export
 * @interface RequestIn
 */
export interface RequestIn {
    /**
     * Request name
     * @type {string}
     * @memberof RequestIn
     */
    name: string;
    /**
     * Request description
     * @type {string}
     * @memberof RequestIn
     */
    description?: string;
    /**
     * JSON object with request content
     * @type {any}
     * @memberof RequestIn
     */
    content: any;
    /**
     * collection of resources having tags that determine the workflows for the request
     * @type {Array<TagResource>}
     * @memberof RequestIn
     */
    tagResources: Array<TagResource>;
}

/**
 * Resource object definition
 * @export
 * @interface ResourceObject
 */
export interface ResourceObject {
    /**
     * Object type
     * @type {string}
     * @memberof ResourceObject
     */
    objectType: string;
    /**
     * Application name the object belongs to
     * @type {string}
     * @memberof ResourceObject
     */
    appName: string;
    /**
     * Id of the object
     * @type {string}
     * @memberof ResourceObject
     */
    objectId: string;
}

/**
 * tag details
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    namespace: string;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Tag
     */
    value?: string;
}

/**
 * Resource with tags
 * @export
 * @interface TagResource
 */
export interface TagResource {
    /**
     *
     * @type {string}
     * @memberof TagResource
     */
    appName: string;
    /**
     *
     * @type {string}
     * @memberof TagResource
     */
    objectType: string;
    /**
     *
     * @type {Array<Tag>}
     * @memberof TagResource
     */
    tags: Array<Tag>;
}

/**
 * The template to categorize workflows.
 * @export
 * @interface Template
 */
export interface Template {
    /**
     *
     * @type {string}
     * @memberof Template
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Template
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof Template
     */
    description?: string;
}

/**
 *
 * @export
 * @interface TemplateCollection
 */
export interface TemplateCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TemplateCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TemplateCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Template>}
     * @memberof TemplateCollection
     */
    data?: Array<Template>;
}

/**
 * The workflow to process approval requests. Each workflow is linked to multiple groups of approvals.
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     *
     * @type {string}
     * @memberof Workflow
     */
    id?: string;
    /**
     * Associated template id
     * @type {string}
     * @memberof Workflow
     */
    templateId?: string;
    /**
     *
     * @type {string}
     * @memberof Workflow
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Workflow
     */
    description?: string | null;
    /**
     * an indicator of the execution order for selected workflows
     * @type {number}
     * @memberof Workflow
     */
    sequence?: number;
    /**
     * Group reference ids associated with workflow
     * @type {Array<string>}
     * @memberof Workflow
     */
    groupRefs?: Array<string>;
}

/**
 *
 * @export
 * @interface WorkflowCollection
 */
export interface WorkflowCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof WorkflowCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof WorkflowCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Workflow>}
     * @memberof WorkflowCollection
     */
    data?: Array<Workflow>;
}


/**
 * ActionApi - axios parameter creator
 * @export
 */
export const ActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an action to a given request, available for admin/approver/requester
         * @summary Add an action to a given request
         * @param {string} requestId Id of request
         * @param {Action} action Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(requestId: string, action: Action, options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling createAction.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling createAction.');
            }
            const localVarPath = `/requests/{request_id}/actions`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Action" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(action || {}) : (action || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return actions in a given request, available for admin/approver
         * @summary List all actions of a request
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByRequest(requestId: string, options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling listActionsByRequest.');
            }
            const localVarPath = `/requests/{request_id}/actions`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an user action by id, available to all
         * @summary Return an user action by id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showAction.');
            }
            const localVarPath = `/actions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionApi - functional programming interface
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add an action to a given request, available for admin/approver/requester
         * @summary Add an action to a given request
         * @param {string} requestId Id of request
         * @param {Action} action Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(requestId: string, action: Action, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Action> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).createAction(requestId, action, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return actions in a given request, available for admin/approver
         * @summary List all actions of a request
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByRequest(requestId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionCollection> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).listActionsByRequest(requestId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an user action by id, available to all
         * @summary Return an user action by id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Action> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).showAction(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionApi - factory interface
 * @export
 */
export const ActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add an action to a given request, available for admin/approver/requester
         * @summary Add an action to a given request
         * @param {string} requestId Id of request
         * @param {Action} action Action object that will be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(requestId: string, action: Action, options?: any) {
            return ActionApiFp(configuration).createAction(requestId, action, options)(axios, basePath);
        },
        /**
         * Return actions in a given request, available for admin/approver
         * @summary List all actions of a request
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByRequest(requestId: string, options?: any) {
            return ActionApiFp(configuration).listActionsByRequest(requestId, options)(axios, basePath);
        },
        /**
         * Return an user action by id, available to all
         * @summary Return an user action by id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options?: any) {
            return ActionApiFp(configuration).showAction(id, options)(axios, basePath);
        },
    };
};

/**
 * ActionApi - object-oriented interface
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * Add an action to a given request, available for admin/approver/requester
     * @summary Add an action to a given request
     * @param {string} requestId Id of request
     * @param {Action} action Action object that will be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public createAction(requestId: string, action: Action, options?: any) {
        return ActionApiFp(this.configuration).createAction(requestId, action, options)(this.axios, this.basePath);
    }

    /**
     * Return actions in a given request, available for admin/approver
     * @summary List all actions of a request
     * @param {string} requestId Id of request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public listActionsByRequest(requestId: string, options?: any) {
        return ActionApiFp(this.configuration).listActionsByRequest(requestId, options)(this.axios, this.basePath);
    }

    /**
     * Return an user action by id, available to all
     * @summary Return an user action by id
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public showAction(id: string, options?: any) {
        return ActionApiFp(this.configuration).showAction(id, options)(this.axios, this.basePath);
    }

}

/**
 * GraphqlApi - axios parameter creator
 * @export
 */
export const GraphqlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphqlIn} graphqlIn GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphql(graphqlIn: GraphqlIn, options: any = {}): RequestArgs {
            // verify required parameter 'graphqlIn' is not null or undefined
            if (graphqlIn === null || graphqlIn === undefined) {
                throw new RequiredError('graphqlIn','Required parameter graphqlIn was null or undefined when calling postGraphql.');
            }
            const localVarPath = `/graphql`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GraphqlIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(graphqlIn || {}) : (graphqlIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphqlApi - functional programming interface
 * @export
 */
export const GraphqlApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphqlIn} graphqlIn GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphql(graphqlIn: GraphqlIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphqlOut> {
            const localVarAxiosArgs = GraphqlApiAxiosParamCreator(configuration).postGraphql(graphqlIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GraphqlApi - factory interface
 * @export
 */
export const GraphqlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Performs a GraphQL Query
         * @summary Perform a GraphQL Query
         * @param {GraphqlIn} graphqlIn GraphQL Query Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphql(graphqlIn: GraphqlIn, options?: any) {
            return GraphqlApiFp(configuration).postGraphql(graphqlIn, options)(axios, basePath);
        },
    };
};

/**
 * GraphqlApi - object-oriented interface
 * @export
 * @class GraphqlApi
 * @extends {BaseAPI}
 */
export class GraphqlApi extends BaseAPI {
    /**
     * Performs a GraphQL Query
     * @summary Perform a GraphQL Query
     * @param {GraphqlIn} graphqlIn GraphQL Query Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphqlApi
     */
    public postGraphql(graphqlIn: GraphqlIn, options?: any) {
        return GraphqlApiFp(this.configuration).postGraphql(graphqlIn, options)(this.axios, this.basePath);
    }

}

/**
 * RequestApi - axios parameter creator
 * @export
 */
export const RequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an approval request by given parameters, available to anyone
         * @summary Add an approval request by given parameters
         * @param {RequestIn} requestIn Parameters need to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(requestIn: RequestIn, options: any = {}): RequestArgs {
            // verify required parameter 'requestIn' is not null or undefined
            if (requestIn === null || requestIn === undefined) {
                throw new RequiredError('requestIn','Required parameter requestIn was null or undefined when calling createRequest.');
            }
            const localVarPath = `/requests`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequestIn" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestIn || {}) : (requestIn || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an array of requests. The result depends on the x-rh-persona header
         * @summary Return an array of approval requests, available to anyone
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Current login user&#39;s persona
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/requests`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRhPersona !== undefined && xRhPersona !== null) {
                localVarHeaderParameter['x-rh-persona'] = String(xRhPersona);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an array of child request by given request id, available for admin/requester
         * @summary Return an array of request children by given request id
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByRequest(requestId: string, options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling listRequestsByRequest.');
            }
            const localVarPath = `/requests/{request_id}/requests`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an approval request by given id, available to anyone who can access the request
         * @summary Return an approval request by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showRequest.');
            }
            const localVarPath = `/requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestApi - functional programming interface
 * @export
 */
export const RequestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add an approval request by given parameters, available to anyone
         * @summary Add an approval request by given parameters
         * @param {RequestIn} requestIn Parameters need to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(requestIn: RequestIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Request> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).createRequest(requestIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an array of requests. The result depends on the x-rh-persona header
         * @summary Return an array of approval requests, available to anyone
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Current login user&#39;s persona
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestCollection> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).listRequests(xRhPersona, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an array of child request by given request id, available for admin/requester
         * @summary Return an array of request children by given request id
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByRequest(requestId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestCollection> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).listRequestsByRequest(requestId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an approval request by given id, available to anyone who can access the request
         * @summary Return an approval request by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Request> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).showRequest(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RequestApi - factory interface
 * @export
 */
export const RequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add an approval request by given parameters, available to anyone
         * @summary Add an approval request by given parameters
         * @param {RequestIn} requestIn Parameters need to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(requestIn: RequestIn, options?: any) {
            return RequestApiFp(configuration).createRequest(requestIn, options)(axios, basePath);
        },
        /**
         * Return an array of requests. The result depends on the x-rh-persona header
         * @summary Return an array of approval requests, available to anyone
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Current login user&#39;s persona
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', limit?: number, offset?: number, filter?: any, options?: any) {
            return RequestApiFp(configuration).listRequests(xRhPersona, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Return an array of child request by given request id, available for admin/requester
         * @summary Return an array of request children by given request id
         * @param {string} requestId Id of request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByRequest(requestId: string, options?: any) {
            return RequestApiFp(configuration).listRequestsByRequest(requestId, options)(axios, basePath);
        },
        /**
         * Return an approval request by given id, available to anyone who can access the request
         * @summary Return an approval request by given id
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options?: any) {
            return RequestApiFp(configuration).showRequest(id, options)(axios, basePath);
        },
    };
};

/**
 * RequestApi - object-oriented interface
 * @export
 * @class RequestApi
 * @extends {BaseAPI}
 */
export class RequestApi extends BaseAPI {
    /**
     * Add an approval request by given parameters, available to anyone
     * @summary Add an approval request by given parameters
     * @param {RequestIn} requestIn Parameters need to create a request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public createRequest(requestIn: RequestIn, options?: any) {
        return RequestApiFp(this.configuration).createRequest(requestIn, options)(this.axios, this.basePath);
    }

    /**
     * Return an array of requests. The result depends on the x-rh-persona header
     * @summary Return an array of approval requests, available to anyone
     * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Current login user&#39;s persona
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public listRequests(xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', limit?: number, offset?: number, filter?: any, options?: any) {
        return RequestApiFp(this.configuration).listRequests(xRhPersona, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Return an array of child request by given request id, available for admin/requester
     * @summary Return an array of request children by given request id
     * @param {string} requestId Id of request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public listRequestsByRequest(requestId: string, options?: any) {
        return RequestApiFp(this.configuration).listRequestsByRequest(requestId, options)(this.axios, this.basePath);
    }

    /**
     * Return an approval request by given id, available to anyone who can access the request
     * @summary Return an approval request by given id
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public showRequest(id: string, options?: any) {
        return RequestApiFp(this.configuration).showRequest(id, options)(this.axios, this.basePath);
    }

}

/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return all templates
         * @summary Return all templates, only available for admin
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a template by given id
         * @summary Return a template by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showTemplate.');
            }
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return all templates
         * @summary Return all templates, only available for admin
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateCollection> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).listTemplates(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return a template by given id
         * @summary Return a template by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).showTemplate(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return all templates
         * @summary Return all templates, only available for admin
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: any, options?: any) {
            return TemplateApiFp(configuration).listTemplates(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Return a template by given id
         * @summary Return a template by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options?: any) {
            return TemplateApiFp(configuration).showTemplate(id, options)(axios, basePath);
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     * Return all templates
     * @summary Return all templates, only available for admin
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public listTemplates(limit?: number, offset?: number, filter?: any, options?: any) {
        return TemplateApiFp(this.configuration).listTemplates(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Return a template by given id
     * @summary Return a template by given id, only available for admin
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public showTemplate(id: string, options?: any) {
        return TemplateApiFp(this.configuration).showTemplate(id, options)(this.axios, this.basePath);
    }

}

/**
 * WorkflowApi - axios parameter creator
 * @export
 */
export const WorkflowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a workflow by given template id
         * @summary Add a workflow by given template id, only available for admin
         * @param {string} templateId Id of template
         * @param {Workflow} workflow Parameters need to create workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflow: Workflow, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling addWorkflowToTemplate.');
            }
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling addWorkflowToTemplate.');
            }
            const localVarPath = `/templates/{template_id}/workflows`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Workflow" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete approval workflow by given id
         * @summary Delete approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a resource object to a given workflow
         * @summary Create a resource link to a given workflow
         * @param {string} id Query by id
         * @param {ResourceObject} resourceObject Parameters needed to create a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkflow(id: string, resourceObject: ResourceObject, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling linkWorkflow.');
            }
            // verify required parameter 'resourceObject' is not null or undefined
            if (resourceObject === null || resourceObject === undefined) {
                throw new RequiredError('resourceObject','Required parameter resourceObject was null or undefined when calling linkWorkflow.');
            }
            const localVarPath = `/workflows/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourceObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resourceObject || {}) : (resourceObject || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all approval workflows in ascending sequence order
         * @summary Return all approval workflows, only available for admin
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            const localVarPath = `/workflows`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an array of workflows by given template id
         * @summary Return an array of workflows by given template id, only available for admin
         * @param {string} templateId Id of template
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: any, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling listWorkflowsByTemplate.');
            }
            const localVarPath = `/templates/{template_id}/workflows`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all workflows linked to a resource object.
         * @summary Get all workflows linked to a resource object.
         * @param {ResourceObject} resourceObject Resource object used to resolve workflows.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveWorkflows(resourceObject: ResourceObject, options: any = {}): RequestArgs {
            // verify required parameter 'resourceObject' is not null or undefined
            if (resourceObject === null || resourceObject === undefined) {
                throw new RequiredError('resourceObject','Required parameter resourceObject was null or undefined when calling resolveWorkflows.');
            }
            const localVarPath = `/workflows/resolve`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourceObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resourceObject || {}) : (resourceObject || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an approval workflow by given id
         * @summary Return an approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Break all links between a resource object and its assigned workflows
         * @summary Break all links between a resource object and its assigned workflows
         * @param {ResourceObject} resourceObject Parameters needed to remove a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAll(resourceObject: ResourceObject, options: any = {}): RequestArgs {
            // verify required parameter 'resourceObject' is not null or undefined
            if (resourceObject === null || resourceObject === undefined) {
                throw new RequiredError('resourceObject','Required parameter resourceObject was null or undefined when calling unlinkAll.');
            }
            const localVarPath = `/workflows/unlink`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourceObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resourceObject || {}) : (resourceObject || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Break the link between a resource object and selected workflow
         * @summary Break the link between a resource object and selected workflow
         * @param {string} id Query by id
         * @param {ResourceObject} resourceObject Parameters needed to remove a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkflow(id: string, resourceObject: ResourceObject, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlinkWorkflow.');
            }
            // verify required parameter 'resourceObject' is not null or undefined
            if (resourceObject === null || resourceObject === undefined) {
                throw new RequiredError('resourceObject','Required parameter resourceObject was null or undefined when calling unlinkWorkflow.');
            }
            const localVarPath = `/workflows/{id}/unlink`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourceObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resourceObject || {}) : (resourceObject || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an approval workflow by given id
         * @summary Update an approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {Workflow} workflow Parameters need to update approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflow: Workflow, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateWorkflow.');
            }
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling updateWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic_auth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Workflow" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowApi - functional programming interface
 * @export
 */
export const WorkflowApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a workflow by given template id
         * @summary Add a workflow by given template id, only available for admin
         * @param {string} templateId Id of template
         * @param {Workflow} workflow Parameters need to create workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflow: Workflow, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).addWorkflowToTemplate(templateId, workflow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete approval workflow by given id
         * @summary Delete approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).destroyWorkflow(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Link a resource object to a given workflow
         * @summary Create a resource link to a given workflow
         * @param {string} id Query by id
         * @param {ResourceObject} resourceObject Parameters needed to create a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkflow(id: string, resourceObject: ResourceObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).linkWorkflow(id, resourceObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return all approval workflows in ascending sequence order
         * @summary Return all approval workflows, only available for admin
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowCollection> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).listWorkflows(limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an array of workflows by given template id
         * @summary Return an array of workflows by given template id, only available for admin
         * @param {string} templateId Id of template
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowCollection> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all workflows linked to a resource object.
         * @summary Get all workflows linked to a resource object.
         * @param {ResourceObject} resourceObject Resource object used to resolve workflows.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveWorkflows(resourceObject: ResourceObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).resolveWorkflows(resourceObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an approval workflow by given id
         * @summary Return an approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).showWorkflow(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Break all links between a resource object and its assigned workflows
         * @summary Break all links between a resource object and its assigned workflows
         * @param {ResourceObject} resourceObject Parameters needed to remove a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAll(resourceObject: ResourceObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).unlinkAll(resourceObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Break the link between a resource object and selected workflow
         * @summary Break the link between a resource object and selected workflow
         * @param {string} id Query by id
         * @param {ResourceObject} resourceObject Parameters needed to remove a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkflow(id: string, resourceObject: ResourceObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).unlinkWorkflow(id, resourceObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an approval workflow by given id
         * @summary Update an approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {Workflow} workflow Parameters need to update approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflow: Workflow, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).updateWorkflow(id, workflow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowApi - factory interface
 * @export
 */
export const WorkflowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add a workflow by given template id
         * @summary Add a workflow by given template id, only available for admin
         * @param {string} templateId Id of template
         * @param {Workflow} workflow Parameters need to create workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflow: Workflow, options?: any) {
            return WorkflowApiFp(configuration).addWorkflowToTemplate(templateId, workflow, options)(axios, basePath);
        },
        /**
         * Delete approval workflow by given id
         * @summary Delete approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options?: any) {
            return WorkflowApiFp(configuration).destroyWorkflow(id, options)(axios, basePath);
        },
        /**
         * Link a resource object to a given workflow
         * @summary Create a resource link to a given workflow
         * @param {string} id Query by id
         * @param {ResourceObject} resourceObject Parameters needed to create a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkflow(id: string, resourceObject: ResourceObject, options?: any) {
            return WorkflowApiFp(configuration).linkWorkflow(id, resourceObject, options)(axios, basePath);
        },
        /**
         * Return all approval workflows in ascending sequence order
         * @summary Return all approval workflows, only available for admin
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(limit?: number, offset?: number, filter?: any, options?: any) {
            return WorkflowApiFp(configuration).listWorkflows(limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Return an array of workflows by given template id
         * @summary Return an array of workflows by given template id, only available for admin
         * @param {string} templateId Id of template
         * @param {number} [limit] How many items to return at one time (max 1000)
         * @param {number} [offset] Starting Offset
         * @param {any} [filter] Filter for querying collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: any, options?: any) {
            return WorkflowApiFp(configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, options)(axios, basePath);
        },
        /**
         * Get all workflows linked to a resource object.
         * @summary Get all workflows linked to a resource object.
         * @param {ResourceObject} resourceObject Resource object used to resolve workflows.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveWorkflows(resourceObject: ResourceObject, options?: any) {
            return WorkflowApiFp(configuration).resolveWorkflows(resourceObject, options)(axios, basePath);
        },
        /**
         * Return an approval workflow by given id
         * @summary Return an approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options?: any) {
            return WorkflowApiFp(configuration).showWorkflow(id, options)(axios, basePath);
        },
        /**
         * Break all links between a resource object and its assigned workflows
         * @summary Break all links between a resource object and its assigned workflows
         * @param {ResourceObject} resourceObject Parameters needed to remove a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAll(resourceObject: ResourceObject, options?: any) {
            return WorkflowApiFp(configuration).unlinkAll(resourceObject, options)(axios, basePath);
        },
        /**
         * Break the link between a resource object and selected workflow
         * @summary Break the link between a resource object and selected workflow
         * @param {string} id Query by id
         * @param {ResourceObject} resourceObject Parameters needed to remove a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkflow(id: string, resourceObject: ResourceObject, options?: any) {
            return WorkflowApiFp(configuration).unlinkWorkflow(id, resourceObject, options)(axios, basePath);
        },
        /**
         * Update an approval workflow by given id
         * @summary Update an approval workflow by given id, only available for admin
         * @param {string} id Query by id
         * @param {Workflow} workflow Parameters need to update approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflow: Workflow, options?: any) {
            return WorkflowApiFp(configuration).updateWorkflow(id, workflow, options)(axios, basePath);
        },
    };
};

/**
 * WorkflowApi - object-oriented interface
 * @export
 * @class WorkflowApi
 * @extends {BaseAPI}
 */
export class WorkflowApi extends BaseAPI {
    /**
     * Add a workflow by given template id
     * @summary Add a workflow by given template id, only available for admin
     * @param {string} templateId Id of template
     * @param {Workflow} workflow Parameters need to create workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public addWorkflowToTemplate(templateId: string, workflow: Workflow, options?: any) {
        return WorkflowApiFp(this.configuration).addWorkflowToTemplate(templateId, workflow, options)(this.axios, this.basePath);
    }

    /**
     * Delete approval workflow by given id
     * @summary Delete approval workflow by given id, only available for admin
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public destroyWorkflow(id: string, options?: any) {
        return WorkflowApiFp(this.configuration).destroyWorkflow(id, options)(this.axios, this.basePath);
    }

    /**
     * Link a resource object to a given workflow
     * @summary Create a resource link to a given workflow
     * @param {string} id Query by id
     * @param {ResourceObject} resourceObject Parameters needed to create a link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public linkWorkflow(id: string, resourceObject: ResourceObject, options?: any) {
        return WorkflowApiFp(this.configuration).linkWorkflow(id, resourceObject, options)(this.axios, this.basePath);
    }

    /**
     * Return all approval workflows in ascending sequence order
     * @summary Return all approval workflows, only available for admin
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public listWorkflows(limit?: number, offset?: number, filter?: any, options?: any) {
        return WorkflowApiFp(this.configuration).listWorkflows(limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Return an array of workflows by given template id
     * @summary Return an array of workflows by given template id, only available for admin
     * @param {string} templateId Id of template
     * @param {number} [limit] How many items to return at one time (max 1000)
     * @param {number} [offset] Starting Offset
     * @param {any} [filter] Filter for querying collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: any, options?: any) {
        return WorkflowApiFp(this.configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, options)(this.axios, this.basePath);
    }

    /**
     * Get all workflows linked to a resource object.
     * @summary Get all workflows linked to a resource object.
     * @param {ResourceObject} resourceObject Resource object used to resolve workflows.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public resolveWorkflows(resourceObject: ResourceObject, options?: any) {
        return WorkflowApiFp(this.configuration).resolveWorkflows(resourceObject, options)(this.axios, this.basePath);
    }

    /**
     * Return an approval workflow by given id
     * @summary Return an approval workflow by given id, only available for admin
     * @param {string} id Query by id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public showWorkflow(id: string, options?: any) {
        return WorkflowApiFp(this.configuration).showWorkflow(id, options)(this.axios, this.basePath);
    }

    /**
     * Break all links between a resource object and its assigned workflows
     * @summary Break all links between a resource object and its assigned workflows
     * @param {ResourceObject} resourceObject Parameters needed to remove a link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public unlinkAll(resourceObject: ResourceObject, options?: any) {
        return WorkflowApiFp(this.configuration).unlinkAll(resourceObject, options)(this.axios, this.basePath);
    }

    /**
     * Break the link between a resource object and selected workflow
     * @summary Break the link between a resource object and selected workflow
     * @param {string} id Query by id
     * @param {ResourceObject} resourceObject Parameters needed to remove a link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public unlinkWorkflow(id: string, resourceObject: ResourceObject, options?: any) {
        return WorkflowApiFp(this.configuration).unlinkWorkflow(id, resourceObject, options)(this.axios, this.basePath);
    }

    /**
     * Update an approval workflow by given id
     * @summary Update an approval workflow by given id, only available for admin
     * @param {string} id Query by id
     * @param {Workflow} workflow Parameters need to update approval workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public updateWorkflow(id: string, workflow: Workflow, options?: any) {
        return WorkflowApiFp(this.configuration).updateWorkflow(id, workflow, options)(this.axios, this.basePath);
    }

}

