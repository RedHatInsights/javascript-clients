// tslint:disable
/**
 * Insights Approval Service API
 * The API to create and query approval requests
 *
 * The version of the OpenAPI document: 1.2.2
 * Contact: support@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An action that changes the state of a request
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * ID of the action
     * @type {string}
     * @memberof Action
     */
    id?: string;
    /**
     * Time when the action was created
     * @type {string}
     * @memberof Action
     */
    created_at?: string;
    /**
     * ID of the request that the action belongs to
     * @type {string}
     * @memberof Action
     */
    request_id?: string;
    /**
     * The person who performs the action
     * @type {string}
     * @memberof Action
     */
    processed_by?: string;
    /**
     * Action type, must be one of the predefined values. The request state will be updated according to the operation.
     * @type {string}
     * @memberof Action
     */
    operation?: ActionOperationEnum;
    /**
     * Comments for action
     * @type {string}
     * @memberof Action
     */
    comments?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ActionOperationEnum {
    Approve = 'approve',
    Cancel = 'cancel',
    Deny = 'deny',
    Error = 'error',
    Notify = 'notify',
    Memo = 'memo',
    Skip = 'skip',
    Start = 'start'
}

/**
 *
 * @export
 * @interface ActionCollection
 */
export interface ActionCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof ActionCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof ActionCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Action>}
     * @memberof ActionCollection
     */
    data?: Array<Action>;
}
/**
 *
 * @export
 * @interface CollectionLinks
 */
export interface CollectionLinks {
    /**
     * The link to fetch the first group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    first?: string;
    /**
     * The link to fetch the last group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    last?: string;
    /**
     * The link to fetch the previous group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    prev?: string;
    /**
     * The link to fetch the next group of items in the result set
     * @type {string}
     * @memberof CollectionLinks
     */
    next?: string;
}
/**
 *
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     * Total number of items in the result set, of which only a subset is returned defined by the QueryLimit parameter
     * @type {number}
     * @memberof CollectionMetadata
     */
    count?: number;
    /**
     * The number of items each page can display
     * @type {number}
     * @memberof CollectionMetadata
     */
    limit?: number;
    /**
     * Offset from beginning of the result set
     * @type {number}
     * @memberof CollectionMetadata
     */
    offset?: number;
}
/**
 *
 * @export
 * @interface GraphqlIn
 */
export interface GraphqlIn {
    /**
     * The GraphQL query
     * @type {string}
     * @memberof GraphqlIn
     */
    query: string;
    /**
     * If the query contains several named operations, the operationName controls which one should be executed
     * @type {string}
     * @memberof GraphqlIn
     */
    operationName?: string;
    /**
     * Optional query variables
     * @type {object}
     * @memberof GraphqlIn
     */
    variables?: object | null;
}
/**
 *
 * @export
 * @interface GraphqlOut
 */
export interface GraphqlOut {
    /**
     * Results from the GraphQL query
     * @type {object}
     * @memberof GraphqlOut
     */
    data?: object;
    /**
     * Errors resulting from the GraphQL query
     * @type {Array<object>}
     * @memberof GraphqlOut
     */
    errors?: Array<object>;
}
/**
 * Group reference describing a RBAC group name and ID
 * @export
 * @interface GroupRef
 */
export interface GroupRef {
    /**
     * Name of the RBAC group
     * @type {string}
     * @memberof GroupRef
     */
    name?: string;
    /**
     * RBAC ID of the group
     * @type {string}
     * @memberof GroupRef
     */
    uuid: string;
}
/**
 * API Error
 * @export
 * @interface HttpApiError
 */
export interface HttpApiError {
    /**
     * HTTP status code
     * @type {string}
     * @memberof HttpApiError
     */
    status?: string;
    /**
     * Error details
     * @type {string}
     * @memberof HttpApiError
     */
    details?: string;
}
/**
 * API Error collection
 * @export
 * @interface HttpApiErrorCollection
 */
export interface HttpApiErrorCollection {
    /**
     * Error list from the API query
     * @type {Array<HttpApiError>}
     * @memberof HttpApiErrorCollection
     */
    errors?: Array<HttpApiError>;
}
/**
 * The desired increment relative to its current position, or placement to top or bottom of the list.
 * @export
 * @interface Reposition
 */
export interface Reposition {
    /**
     * Move the record up (negative) or down (positive) in the list. Do not set it if placement is used
     * @type {number}
     * @memberof Reposition
     */
    increment?: number | null;
    /**
     * Place the record to the top or bottom of the list. Do not set it if increment is used
     * @type {string}
     * @memberof Reposition
     */
    placement?: RepositionPlacementEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RepositionPlacementEnum {
    Bottom = 'bottom',
    Top = 'top'
}

/**
 * Approval request. It may have child requests. Only a leaf node request can have workflow_id
 * @export
 * @interface Request
 */
export interface Request {
    /**
     * ID of the request
     * @type {string}
     * @memberof Request
     */
    id?: string;
    /**
     * The state of the request, must be one of the predefined values
     * @type {string}
     * @memberof Request
     */
    state?: RequestStateEnum;
    /**
     * Approval decision, must be one of the predefined values
     * @type {string}
     * @memberof Request
     */
    decision?: RequestDecisionEnum;
    /**
     * Optional reason for the decision, present normally when the decision is denied
     * @type {string}
     * @memberof Request
     */
    reason?: string | null;
    /**
     * ID of the workflow that the request belongs to. Present only if the request is a leaf node
     * @type {string}
     * @memberof Request
     */
    workflow_id?: string | null;
    /**
     * Time when the request was created
     * @type {string}
     * @memberof Request
     */
    created_at?: string;
    /**
     * Time when a notification was sent to approvers
     * @type {string}
     * @memberof Request
     */
    notified_at?: string | null;
    /**
     * Time when the request was finished (skipped, canceled, or completed)
     * @type {string}
     * @memberof Request
     */
    finished_at?: string | null;
    /**
     * Number of child requests
     * @type {number}
     * @memberof Request
     */
    number_of_children?: number;
    /**
     * Number of finished child requests
     * @type {number}
     * @memberof Request
     */
    number_of_finished_children?: number;
    /**
     * Identification of whom made the request
     * @type {string}
     * @memberof Request
     */
    owner?: string;
    /**
     * Full name of the requester
     * @type {string}
     * @memberof Request
     */
    requester_name?: string;
    /**
     * Name of the request to be created
     * @type {string}
     * @memberof Request
     */
    name?: string;
    /**
     * Describe the request in more details
     * @type {string}
     * @memberof Request
     */
    description?: string;
    /**
     * Name of approver group(s) assigned to approve this request
     * @type {string}
     * @memberof Request
     */
    group_name?: string;
    /**
     * ID of the parent group if present
     * @type {string}
     * @memberof Request
     */
    parent_id?: string;
    /**
     * JSON metadata about the request
     * @type {object}
     * @memberof Request
     */
    metadata?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum RequestStateEnum {
    Canceled = 'canceled',
    Completed = 'completed',
    Failed = 'failed',
    Notified = 'notified',
    Pending = 'pending',
    Skipped = 'skipped',
    Started = 'started'
}
/**
    * @export
    * @enum {string}
    */
export enum RequestDecisionEnum {
    Undecided = 'undecided',
    Approved = 'approved',
    Canceled = 'canceled',
    Denied = 'denied',
    Error = 'error'
}

/**
 *
 * @export
 * @interface RequestCollection
 */
export interface RequestCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof RequestCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof RequestCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Request>}
     * @memberof RequestCollection
     */
    data?: Array<Request>;
}
/**
 * Input parameters for approval request object
 * @export
 * @interface RequestIn
 */
export interface RequestIn {
    /**
     * Name of the the request to be created
     * @type {string}
     * @memberof RequestIn
     */
    name: string;
    /**
     * Describe the request in more details
     * @type {string}
     * @memberof RequestIn
     */
    description?: string;
    /**
     * Content of the request in JSON format
     * @type {object}
     * @memberof RequestIn
     */
    content: object;
    /**
     * An array of resource tags that determine the workflows for the request
     * @type {Array<TagResource>}
     * @memberof RequestIn
     */
    tag_resources: Array<TagResource>;
}
/**
 * Resource object definition
 * @export
 * @interface ResourceObject
 */
export interface ResourceObject {
    /**
     * Object type
     * @type {string}
     * @memberof ResourceObject
     */
    object_type: string;
    /**
     * Name of the application that the object belongs to
     * @type {string}
     * @memberof ResourceObject
     */
    app_name: string;
    /**
     * ID of the object
     * @type {string}
     * @memberof ResourceObject
     */
    object_id: string;
}
/**
 * tag details
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * The string representation of the tag
     * @type {string}
     * @memberof Tag
     */
    tag?: string;
}
/**
 * Resource with tags
 * @export
 * @interface TagResource
 */
export interface TagResource {
    /**
     * Name of the app that the resource belongs to
     * @type {string}
     * @memberof TagResource
     */
    app_name: string;
    /**
     * The type of the resource
     * @type {string}
     * @memberof TagResource
     */
    object_type: string;
    /**
     * An array of tags that the resource is tagged with
     * @type {Array<Tag>}
     * @memberof TagResource
     */
    tags: Array<Tag>;
}
/**
 * The template to categorize workflows
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * ID of the template
     * @type {string}
     * @memberof Template
     */
    id?: string;
    /**
     * Name of the template
     * @type {string}
     * @memberof Template
     */
    title?: string;
    /**
     * Describe the template with more details
     * @type {string}
     * @memberof Template
     */
    description?: string;
    /**
     * JSON metadata about the template
     * @type {object}
     * @memberof Template
     */
    metadata?: object;
}
/**
 *
 * @export
 * @interface TemplateCollection
 */
export interface TemplateCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof TemplateCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof TemplateCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Template>}
     * @memberof TemplateCollection
     */
    data?: Array<Template>;
}
/**
 * The workflow to process approval requests. Each workflow is linked to multiple groups of approvals.
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * ID of the workflow
     * @type {string}
     * @memberof Workflow
     */
    id?: string;
    /**
     * ID of the template that the workflow belongs to
     * @type {string}
     * @memberof Workflow
     */
    template_id?: string;
    /**
     * Name of the workflow
     * @type {string}
     * @memberof Workflow
     */
    name?: string;
    /**
     * Describe the workflow in more details
     * @type {string}
     * @memberof Workflow
     */
    description?: string | null;
    /**
     * an indicator of the execution order for selected workflows
     * @type {number}
     * @memberof Workflow
     */
    sequence?: number;
    /**
     * Array of RBAC groups associated with workflow. The groups need to have approval permission
     * @type {Array<GroupRef>}
     * @memberof Workflow
     */
    group_refs?: Array<GroupRef> | null;
    /**
     * JSON metadata about the workflow
     * @type {object}
     * @memberof Workflow
     */
    metadata?: object;
}
/**
 *
 * @export
 * @interface WorkflowCollection
 */
export interface WorkflowCollection {
    /**
     *
     * @type {CollectionMetadata}
     * @memberof WorkflowCollection
     */
    meta?: CollectionMetadata;
    /**
     *
     * @type {CollectionLinks}
     * @memberof WorkflowCollection
     */
    links?: CollectionLinks;
    /**
     *
     * @type {Array<Workflow>}
     * @memberof WorkflowCollection
     */
    data?: Array<Workflow>;
}

/**
 * ActionApi - axios parameter creator
 * @export
 */
export const ActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an action under a request identified by its id. Admin can create approve, deny, memo, and cancel operations; approver can create approve, deny, and memo operations; while requester can create only cancel operation.
         * @summary Create an action under the request
         * @param {string} requestId ID of a request
         * @param {Action} action Action object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(requestId: string, action: Action, options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling createAction.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling createAction.');
            }
            const localVarPath = `/requests/{request_id}/actions`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof action !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(action !== undefined ? action : {}) : (action || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find actions of a request identified by its id, available to everyone
         * @summary List all actions of a request
         * @param {string} requestId ID of a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByRequest(requestId: string, options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling listActionsByRequest.');
            }
            const localVarPath = `/requests/{request_id}/actions`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find an action by its id, available to everyone
         * @summary Return an action
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showAction.');
            }
            const localVarPath = `/actions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionApi - functional programming interface
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create an action under a request identified by its id. Admin can create approve, deny, memo, and cancel operations; approver can create approve, deny, and memo operations; while requester can create only cancel operation.
         * @summary Create an action under the request
         * @param {string} requestId ID of a request
         * @param {Action} action Action object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(requestId: string, action: Action, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Action> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).createAction(requestId, action, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find actions of a request identified by its id, available to everyone
         * @summary List all actions of a request
         * @param {string} requestId ID of a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByRequest(requestId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionCollection> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).listActionsByRequest(requestId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find an action by its id, available to everyone
         * @summary Return an action
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Action> {
            const localVarAxiosArgs = ActionApiAxiosParamCreator(configuration).showAction(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActionApi - factory interface
 * @export
 */
export const ActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create an action under a request identified by its id. Admin can create approve, deny, memo, and cancel operations; approver can create approve, deny, and memo operations; while requester can create only cancel operation.
         * @summary Create an action under the request
         * @param {string} requestId ID of a request
         * @param {Action} action Action object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAction(requestId: string, action: Action, options?: any): AxiosPromise<Action> {
            return ActionApiFp(configuration).createAction(requestId, action, options)(axios, basePath);
        },
        /**
         * Find actions of a request identified by its id, available to everyone
         * @summary List all actions of a request
         * @param {string} requestId ID of a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActionsByRequest(requestId: string, options?: any): AxiosPromise<ActionCollection> {
            return ActionApiFp(configuration).listActionsByRequest(requestId, options)(axios, basePath);
        },
        /**
         * Find an action by its id, available to everyone
         * @summary Return an action
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showAction(id: string, options?: any): AxiosPromise<Action> {
            return ActionApiFp(configuration).showAction(id, options)(axios, basePath);
        },
    };
};

/**
 * ActionApi - object-oriented interface
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * Create an action under a request identified by its id. Admin can create approve, deny, memo, and cancel operations; approver can create approve, deny, and memo operations; while requester can create only cancel operation.
     * @summary Create an action under the request
     * @param {string} requestId ID of a request
     * @param {Action} action Action object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public createAction(requestId: string, action: Action, options?: any) {
        return ActionApiFp(this.configuration).createAction(requestId, action, options)(this.axios, this.basePath);
    }

    /**
     * Find actions of a request identified by its id, available to everyone
     * @summary List all actions of a request
     * @param {string} requestId ID of a request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public listActionsByRequest(requestId: string, options?: any) {
        return ActionApiFp(this.configuration).listActionsByRequest(requestId, options)(this.axios, this.basePath);
    }

    /**
     * Find an action by its id, available to everyone
     * @summary Return an action
     * @param {string} id ID used to select a resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public showAction(id: string, options?: any) {
        return ActionApiFp(this.configuration).showAction(id, options)(this.axios, this.basePath);
    }

}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options: any = {}): RequestArgs {
            const localVarPath = `/openapi.json`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getDocumentation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         *
         * @summary Return this API document in JSON format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentation(options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).getDocumentation(options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     *
     * @summary Return this API document in JSON format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDocumentation(options?: any) {
        return DefaultApiFp(this.configuration).getDocumentation(options)(this.axios, this.basePath);
    }

}


/**
 * GraphqlApi - axios parameter creator
 * @export
 */
export const GraphqlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Perform a GraphQL query
         * @summary Perform a GraphQL query
         * @param {GraphqlIn} graphqlIn GraphQL query request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphql(graphqlIn: GraphqlIn, options: any = {}): RequestArgs {
            // verify required parameter 'graphqlIn' is not null or undefined
            if (graphqlIn === null || graphqlIn === undefined) {
                throw new RequiredError('graphqlIn','Required parameter graphqlIn was null or undefined when calling postGraphql.');
            }
            const localVarPath = `/graphql`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof graphqlIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(graphqlIn !== undefined ? graphqlIn : {}) : (graphqlIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphqlApi - functional programming interface
 * @export
 */
export const GraphqlApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Perform a GraphQL query
         * @summary Perform a GraphQL query
         * @param {GraphqlIn} graphqlIn GraphQL query request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphql(graphqlIn: GraphqlIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GraphqlOut> {
            const localVarAxiosArgs = GraphqlApiAxiosParamCreator(configuration).postGraphql(graphqlIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GraphqlApi - factory interface
 * @export
 */
export const GraphqlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Perform a GraphQL query
         * @summary Perform a GraphQL query
         * @param {GraphqlIn} graphqlIn GraphQL query request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphql(graphqlIn: GraphqlIn, options?: any): AxiosPromise<GraphqlOut> {
            return GraphqlApiFp(configuration).postGraphql(graphqlIn, options)(axios, basePath);
        },
    };
};

/**
 * GraphqlApi - object-oriented interface
 * @export
 * @class GraphqlApi
 * @extends {BaseAPI}
 */
export class GraphqlApi extends BaseAPI {
    /**
     * Perform a GraphQL query
     * @summary Perform a GraphQL query
     * @param {GraphqlIn} graphqlIn GraphQL query request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphqlApi
     */
    public postGraphql(graphqlIn: GraphqlIn, options?: any) {
        return GraphqlApiFp(this.configuration).postGraphql(graphqlIn, options)(this.axios, this.basePath);
    }

}


/**
 * RequestApi - axios parameter creator
 * @export
 */
export const RequestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an approval request using given parameters, available to everyone
         * @summary Create a new approval request
         * @param {RequestIn} requestIn Parameters needed to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(requestIn: RequestIn, options: any = {}): RequestArgs {
            // verify required parameter 'requestIn' is not null or undefined
            if (requestIn === null || requestIn === undefined) {
                throw new RequiredError('requestIn','Required parameter requestIn was null or undefined when calling createRequest.');
            }
            const localVarPath = `/requests`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof requestIn !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(requestIn !== undefined ? requestIn : {}) : (requestIn || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The result depends on the x-rh-persona header (approval/admin, approval/requseter, or approval/approver). Program generated child requests are not included.
         * @summary List filtered requests, available to everyone
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Desired persona of the current login user
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): RequestArgs {
            const localVarPath = `/requests`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (xRhPersona !== undefined && xRhPersona !== null) {
                localVarHeaderParameter['x-rh-persona'] = String(xRhPersona);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find child requests based on the parent request id. The result depends on the x-rh-persona header (approval/admin, approval/requseter, or approval/approver).
         * @summary List filtered child requests of a request
         * @param {string} requestId ID of a request
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Desired persona of the current login user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByRequest(requestId: string, xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling listRequestsByRequest.');
            }
            const localVarPath = `/requests/{request_id}/requests`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRhPersona !== undefined && xRhPersona !== null) {
                localVarHeaderParameter['x-rh-persona'] = String(xRhPersona);
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find an approval request by its id, available to anyone who can access the request
         * @summary Return an approval request
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showRequest.');
            }
            const localVarPath = `/requests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the request content based on a request id, available to everyone
         * @summary Return the request content of a request
         * @param {string} requestId ID of a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequestContent(requestId: string, options: any = {}): RequestArgs {
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling showRequestContent.');
            }
            const localVarPath = `/requests/{request_id}/content`
                .replace(`{${"request_id"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestApi - functional programming interface
 * @export
 */
export const RequestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create an approval request using given parameters, available to everyone
         * @summary Create a new approval request
         * @param {RequestIn} requestIn Parameters needed to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(requestIn: RequestIn, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Request> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).createRequest(requestIn, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The result depends on the x-rh-persona header (approval/admin, approval/requseter, or approval/approver). Program generated child requests are not included.
         * @summary List filtered requests, available to everyone
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Desired persona of the current login user
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestCollection> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).listRequests(xRhPersona, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find child requests based on the parent request id. The result depends on the x-rh-persona header (approval/admin, approval/requseter, or approval/approver).
         * @summary List filtered child requests of a request
         * @param {string} requestId ID of a request
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Desired persona of the current login user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByRequest(requestId: string, xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestCollection> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).listRequestsByRequest(requestId, xRhPersona, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find an approval request by its id, available to anyone who can access the request
         * @summary Return an approval request
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Request> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).showRequest(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find the request content based on a request id, available to everyone
         * @summary Return the request content of a request
         * @param {string} requestId ID of a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequestContent(requestId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = RequestApiAxiosParamCreator(configuration).showRequestContent(requestId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RequestApi - factory interface
 * @export
 */
export const RequestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create an approval request using given parameters, available to everyone
         * @summary Create a new approval request
         * @param {RequestIn} requestIn Parameters needed to create a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRequest(requestIn: RequestIn, options?: any): AxiosPromise<Request> {
            return RequestApiFp(configuration).createRequest(requestIn, options)(axios, basePath);
        },
        /**
         * The result depends on the x-rh-persona header (approval/admin, approval/requseter, or approval/approver). Program generated child requests are not included.
         * @summary List filtered requests, available to everyone
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Desired persona of the current login user
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequests(xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<RequestCollection> {
            return RequestApiFp(configuration).listRequests(xRhPersona, limit, offset, filter, sortBy, options)(axios, basePath);
        },
        /**
         * Find child requests based on the parent request id. The result depends on the x-rh-persona header (approval/admin, approval/requseter, or approval/approver).
         * @summary List filtered child requests of a request
         * @param {string} requestId ID of a request
         * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Desired persona of the current login user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRequestsByRequest(requestId: string, xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', options?: any): AxiosPromise<RequestCollection> {
            return RequestApiFp(configuration).listRequestsByRequest(requestId, xRhPersona, options)(axios, basePath);
        },
        /**
         * Find an approval request by its id, available to anyone who can access the request
         * @summary Return an approval request
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequest(id: string, options?: any): AxiosPromise<Request> {
            return RequestApiFp(configuration).showRequest(id, options)(axios, basePath);
        },
        /**
         * Find the request content based on a request id, available to everyone
         * @summary Return the request content of a request
         * @param {string} requestId ID of a request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRequestContent(requestId: string, options?: any): AxiosPromise<object> {
            return RequestApiFp(configuration).showRequestContent(requestId, options)(axios, basePath);
        },
    };
};

/**
 * RequestApi - object-oriented interface
 * @export
 * @class RequestApi
 * @extends {BaseAPI}
 */
export class RequestApi extends BaseAPI {
    /**
     * Create an approval request using given parameters, available to everyone
     * @summary Create a new approval request
     * @param {RequestIn} requestIn Parameters needed to create a request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public createRequest(requestIn: RequestIn, options?: any) {
        return RequestApiFp(this.configuration).createRequest(requestIn, options)(this.axios, this.basePath);
    }

    /**
     * The result depends on the x-rh-persona header (approval/admin, approval/requseter, or approval/approver). Program generated child requests are not included.
     * @summary List filtered requests, available to everyone
     * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Desired persona of the current login user
     * @param {number} [limit] Maximum number of items per page. Used by pagination
     * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
     * @param {object} [filter] Filter for querying collections
     * @param {string} [sortBy] Attribute used to sort a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public listRequests(xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return RequestApiFp(this.configuration).listRequests(xRhPersona, limit, offset, filter, sortBy, options)(this.axios, this.basePath);
    }

    /**
     * Find child requests based on the parent request id. The result depends on the x-rh-persona header (approval/admin, approval/requseter, or approval/approver).
     * @summary List filtered child requests of a request
     * @param {string} requestId ID of a request
     * @param {'approval/admin' | 'approval/approver' | 'approval/requester'} [xRhPersona] Desired persona of the current login user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public listRequestsByRequest(requestId: string, xRhPersona?: 'approval/admin' | 'approval/approver' | 'approval/requester', options?: any) {
        return RequestApiFp(this.configuration).listRequestsByRequest(requestId, xRhPersona, options)(this.axios, this.basePath);
    }

    /**
     * Find an approval request by its id, available to anyone who can access the request
     * @summary Return an approval request
     * @param {string} id ID used to select a resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public showRequest(id: string, options?: any) {
        return RequestApiFp(this.configuration).showRequest(id, options)(this.axios, this.basePath);
    }

    /**
     * Find the request content based on a request id, available to everyone
     * @summary Return the request content of a request
     * @param {string} requestId ID of a request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestApi
     */
    public showRequestContent(requestId: string, options?: any) {
        return RequestApiFp(this.configuration).showRequestContent(requestId, options)(this.axios, this.basePath);
    }

}


/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find all templates, available to admin only
         * @summary List templates
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): RequestArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a template by its id, available to admin only
         * @summary Return a template
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showTemplate.');
            }
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find all templates, available to admin only
         * @summary List templates
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateCollection> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).listTemplates(limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find a template by its id, available to admin only
         * @summary Return a template
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template> {
            const localVarAxiosArgs = TemplateApiAxiosParamCreator(configuration).showTemplate(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Find all templates, available to admin only
         * @summary List templates
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTemplates(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<TemplateCollection> {
            return TemplateApiFp(configuration).listTemplates(limit, offset, filter, sortBy, options)(axios, basePath);
        },
        /**
         * Find a template by its id, available to admin only
         * @summary Return a template
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showTemplate(id: string, options?: any): AxiosPromise<Template> {
            return TemplateApiFp(configuration).showTemplate(id, options)(axios, basePath);
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     * Find all templates, available to admin only
     * @summary List templates
     * @param {number} [limit] Maximum number of items per page. Used by pagination
     * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
     * @param {object} [filter] Filter for querying collections
     * @param {string} [sortBy] Attribute used to sort a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public listTemplates(limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return TemplateApiFp(this.configuration).listTemplates(limit, offset, filter, sortBy, options)(this.axios, this.basePath);
    }

    /**
     * Find a template by its id, available to admin only
     * @summary Return a template
     * @param {string} id ID used to select a resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public showTemplate(id: string, options?: any) {
        return TemplateApiFp(this.configuration).showTemplate(id, options)(this.axios, this.basePath);
    }

}


/**
 * WorkflowApi - axios parameter creator
 * @export
 */
export const WorkflowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a workflow from a template identified by its id, available to admin only
         * @summary Create a workflow from a template
         * @param {string} templateId ID of a template
         * @param {Workflow} workflow Parameters needed to create a workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflow: Workflow, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling addWorkflowToTemplate.');
            }
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling addWorkflowToTemplate.');
            }
            const localVarPath = `/templates/{template_id}/workflows`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflow !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflow !== undefined ? workflow : {}) : (workflow || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an approval workflow by its id, available to admin only
         * @summary Delete an approval workflow
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling destroyWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a resource object to a workflow identified by its id, available to admin only
         * @summary Create a resource link to a workflow
         * @param {string} id ID used to select a resource
         * @param {ResourceObject} resourceObject Parameters needed to create a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkflow(id: string, resourceObject: ResourceObject, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling linkWorkflow.');
            }
            // verify required parameter 'resourceObject' is not null or undefined
            if (resourceObject === null || resourceObject === undefined) {
                throw new RequiredError('resourceObject','Required parameter resourceObject was null or undefined when calling linkWorkflow.');
            }
            const localVarPath = `/workflows/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resourceObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resourceObject !== undefined ? resourceObject : {}) : (resourceObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find approval workflows matching search parameters, available to admin only. Optionally select workflows linked to a resource object whose app_name, object_type and object_id are specified by query parameters. Default sorting is by sequence number in ascending order.
         * @summary List approval workflows
         * @param {string} [appName] Name of the application
         * @param {string} [objectId] ID of a resource object
         * @param {string} [objectType] Type of a resource object
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(appName?: string, objectId?: string, objectType?: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): RequestArgs {
            const localVarPath = `/workflows`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appName !== undefined) {
                localVarQueryParameter['app_name'] = appName;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find workflows based on the template id, available to admin only
         * @summary List all workflows belonging to a template
         * @param {string} templateId ID of a template
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options: any = {}): RequestArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling listWorkflowsByTemplate.');
            }
            const localVarPath = `/templates/{template_id}/workflows`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adjust the position of a workflow related to others by an offset number
         * @summary Adjust the position of a workflow
         * @param {string} id ID used to select a resource
         * @param {Reposition} reposition How many levels should the sequence be brought up or down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reposition(id: string, reposition: Reposition, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling reposition.');
            }
            // verify required parameter 'reposition' is not null or undefined
            if (reposition === null || reposition === undefined) {
                throw new RequiredError('reposition','Required parameter reposition was null or undefined when calling reposition.');
            }
            const localVarPath = `/workflows/{id}/reposition`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof reposition !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(reposition !== undefined ? reposition : {}) : (reposition || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find an approval workflow by its id, available to admin only
         * @summary Return an approval workflow
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling showWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Break the link between a resource object selected by the body and a workflow by its id, available to admin only
         * @summary Break the link between a resource object and a workflow
         * @param {string} id ID used to select a resource
         * @param {ResourceObject} resourceObject Parameters needed to select a resource object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkflow(id: string, resourceObject: ResourceObject, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlinkWorkflow.');
            }
            // verify required parameter 'resourceObject' is not null or undefined
            if (resourceObject === null || resourceObject === undefined) {
                throw new RequiredError('resourceObject','Required parameter resourceObject was null or undefined when calling unlinkWorkflow.');
            }
            const localVarPath = `/workflows/{id}/unlink`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resourceObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resourceObject !== undefined ? resourceObject : {}) : (resourceObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find an approval workflow by its id and update its content, available to admin only
         * @summary Update an approval workflow
         * @param {string} id ID used to select a resource
         * @param {Workflow} workflow Parameters needed to update an approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflow: Workflow, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateWorkflow.');
            }
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow','Required parameter workflow was null or undefined when calling updateWorkflow.');
            }
            const localVarPath = `/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof workflow !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(workflow !== undefined ? workflow : {}) : (workflow || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowApi - functional programming interface
 * @export
 */
export const WorkflowApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a workflow from a template identified by its id, available to admin only
         * @summary Create a workflow from a template
         * @param {string} templateId ID of a template
         * @param {Workflow} workflow Parameters needed to create a workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflow: Workflow, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).addWorkflowToTemplate(templateId, workflow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an approval workflow by its id, available to admin only
         * @summary Delete an approval workflow
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).destroyWorkflow(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Link a resource object to a workflow identified by its id, available to admin only
         * @summary Create a resource link to a workflow
         * @param {string} id ID used to select a resource
         * @param {ResourceObject} resourceObject Parameters needed to create a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkflow(id: string, resourceObject: ResourceObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).linkWorkflow(id, resourceObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find approval workflows matching search parameters, available to admin only. Optionally select workflows linked to a resource object whose app_name, object_type and object_id are specified by query parameters. Default sorting is by sequence number in ascending order.
         * @summary List approval workflows
         * @param {string} [appName] Name of the application
         * @param {string} [objectId] ID of a resource object
         * @param {string} [objectType] Type of a resource object
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(appName?: string, objectId?: string, objectType?: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowCollection> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).listWorkflows(appName, objectId, objectType, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find workflows based on the template id, available to admin only
         * @summary List all workflows belonging to a template
         * @param {string} templateId ID of a template
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowCollection> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adjust the position of a workflow related to others by an offset number
         * @summary Adjust the position of a workflow
         * @param {string} id ID used to select a resource
         * @param {Reposition} reposition How many levels should the sequence be brought up or down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reposition(id: string, reposition: Reposition, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).reposition(id, reposition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find an approval workflow by its id, available to admin only
         * @summary Return an approval workflow
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).showWorkflow(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Break the link between a resource object selected by the body and a workflow by its id, available to admin only
         * @summary Break the link between a resource object and a workflow
         * @param {string} id ID used to select a resource
         * @param {ResourceObject} resourceObject Parameters needed to select a resource object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkflow(id: string, resourceObject: ResourceObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).unlinkWorkflow(id, resourceObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find an approval workflow by its id and update its content, available to admin only
         * @summary Update an approval workflow
         * @param {string} id ID used to select a resource
         * @param {Workflow} workflow Parameters needed to update an approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflow: Workflow, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workflow> {
            const localVarAxiosArgs = WorkflowApiAxiosParamCreator(configuration).updateWorkflow(id, workflow, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkflowApi - factory interface
 * @export
 */
export const WorkflowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a workflow from a template identified by its id, available to admin only
         * @summary Create a workflow from a template
         * @param {string} templateId ID of a template
         * @param {Workflow} workflow Parameters needed to create a workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkflowToTemplate(templateId: string, workflow: Workflow, options?: any): AxiosPromise<Workflow> {
            return WorkflowApiFp(configuration).addWorkflowToTemplate(templateId, workflow, options)(axios, basePath);
        },
        /**
         * Delete an approval workflow by its id, available to admin only
         * @summary Delete an approval workflow
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyWorkflow(id: string, options?: any): AxiosPromise<void> {
            return WorkflowApiFp(configuration).destroyWorkflow(id, options)(axios, basePath);
        },
        /**
         * Link a resource object to a workflow identified by its id, available to admin only
         * @summary Create a resource link to a workflow
         * @param {string} id ID used to select a resource
         * @param {ResourceObject} resourceObject Parameters needed to create a link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkflow(id: string, resourceObject: ResourceObject, options?: any): AxiosPromise<void> {
            return WorkflowApiFp(configuration).linkWorkflow(id, resourceObject, options)(axios, basePath);
        },
        /**
         * Find approval workflows matching search parameters, available to admin only. Optionally select workflows linked to a resource object whose app_name, object_type and object_id are specified by query parameters. Default sorting is by sequence number in ascending order.
         * @summary List approval workflows
         * @param {string} [appName] Name of the application
         * @param {string} [objectId] ID of a resource object
         * @param {string} [objectType] Type of a resource object
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(appName?: string, objectId?: string, objectType?: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<WorkflowCollection> {
            return WorkflowApiFp(configuration).listWorkflows(appName, objectId, objectType, limit, offset, filter, sortBy, options)(axios, basePath);
        },
        /**
         * Find workflows based on the template id, available to admin only
         * @summary List all workflows belonging to a template
         * @param {string} templateId ID of a template
         * @param {number} [limit] Maximum number of items per page. Used by pagination
         * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
         * @param {object} [filter] Filter for querying collections
         * @param {string} [sortBy] Attribute used to sort a collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any): AxiosPromise<WorkflowCollection> {
            return WorkflowApiFp(configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, sortBy, options)(axios, basePath);
        },
        /**
         * Adjust the position of a workflow related to others by an offset number
         * @summary Adjust the position of a workflow
         * @param {string} id ID used to select a resource
         * @param {Reposition} reposition How many levels should the sequence be brought up or down
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reposition(id: string, reposition: Reposition, options?: any): AxiosPromise<void> {
            return WorkflowApiFp(configuration).reposition(id, reposition, options)(axios, basePath);
        },
        /**
         * Find an approval workflow by its id, available to admin only
         * @summary Return an approval workflow
         * @param {string} id ID used to select a resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWorkflow(id: string, options?: any): AxiosPromise<Workflow> {
            return WorkflowApiFp(configuration).showWorkflow(id, options)(axios, basePath);
        },
        /**
         * Break the link between a resource object selected by the body and a workflow by its id, available to admin only
         * @summary Break the link between a resource object and a workflow
         * @param {string} id ID used to select a resource
         * @param {ResourceObject} resourceObject Parameters needed to select a resource object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkflow(id: string, resourceObject: ResourceObject, options?: any): AxiosPromise<void> {
            return WorkflowApiFp(configuration).unlinkWorkflow(id, resourceObject, options)(axios, basePath);
        },
        /**
         * Find an approval workflow by its id and update its content, available to admin only
         * @summary Update an approval workflow
         * @param {string} id ID used to select a resource
         * @param {Workflow} workflow Parameters needed to update an approval workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(id: string, workflow: Workflow, options?: any): AxiosPromise<Workflow> {
            return WorkflowApiFp(configuration).updateWorkflow(id, workflow, options)(axios, basePath);
        },
    };
};

/**
 * WorkflowApi - object-oriented interface
 * @export
 * @class WorkflowApi
 * @extends {BaseAPI}
 */
export class WorkflowApi extends BaseAPI {
    /**
     * Create a workflow from a template identified by its id, available to admin only
     * @summary Create a workflow from a template
     * @param {string} templateId ID of a template
     * @param {Workflow} workflow Parameters needed to create a workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public addWorkflowToTemplate(templateId: string, workflow: Workflow, options?: any) {
        return WorkflowApiFp(this.configuration).addWorkflowToTemplate(templateId, workflow, options)(this.axios, this.basePath);
    }

    /**
     * Delete an approval workflow by its id, available to admin only
     * @summary Delete an approval workflow
     * @param {string} id ID used to select a resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public destroyWorkflow(id: string, options?: any) {
        return WorkflowApiFp(this.configuration).destroyWorkflow(id, options)(this.axios, this.basePath);
    }

    /**
     * Link a resource object to a workflow identified by its id, available to admin only
     * @summary Create a resource link to a workflow
     * @param {string} id ID used to select a resource
     * @param {ResourceObject} resourceObject Parameters needed to create a link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public linkWorkflow(id: string, resourceObject: ResourceObject, options?: any) {
        return WorkflowApiFp(this.configuration).linkWorkflow(id, resourceObject, options)(this.axios, this.basePath);
    }

    /**
     * Find approval workflows matching search parameters, available to admin only. Optionally select workflows linked to a resource object whose app_name, object_type and object_id are specified by query parameters. Default sorting is by sequence number in ascending order.
     * @summary List approval workflows
     * @param {string} [appName] Name of the application
     * @param {string} [objectId] ID of a resource object
     * @param {string} [objectType] Type of a resource object
     * @param {number} [limit] Maximum number of items per page. Used by pagination
     * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
     * @param {object} [filter] Filter for querying collections
     * @param {string} [sortBy] Attribute used to sort a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public listWorkflows(appName?: string, objectId?: string, objectType?: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return WorkflowApiFp(this.configuration).listWorkflows(appName, objectId, objectType, limit, offset, filter, sortBy, options)(this.axios, this.basePath);
    }

    /**
     * Find workflows based on the template id, available to admin only
     * @summary List all workflows belonging to a template
     * @param {string} templateId ID of a template
     * @param {number} [limit] Maximum number of items per page. Used by pagination
     * @param {number} [offset] Number of items to skip before starting to collect the result set. Used by pagination
     * @param {object} [filter] Filter for querying collections
     * @param {string} [sortBy] Attribute used to sort a collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public listWorkflowsByTemplate(templateId: string, limit?: number, offset?: number, filter?: object, sortBy?: string, options?: any) {
        return WorkflowApiFp(this.configuration).listWorkflowsByTemplate(templateId, limit, offset, filter, sortBy, options)(this.axios, this.basePath);
    }

    /**
     * Adjust the position of a workflow related to others by an offset number
     * @summary Adjust the position of a workflow
     * @param {string} id ID used to select a resource
     * @param {Reposition} reposition How many levels should the sequence be brought up or down
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public reposition(id: string, reposition: Reposition, options?: any) {
        return WorkflowApiFp(this.configuration).reposition(id, reposition, options)(this.axios, this.basePath);
    }

    /**
     * Find an approval workflow by its id, available to admin only
     * @summary Return an approval workflow
     * @param {string} id ID used to select a resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public showWorkflow(id: string, options?: any) {
        return WorkflowApiFp(this.configuration).showWorkflow(id, options)(this.axios, this.basePath);
    }

    /**
     * Break the link between a resource object selected by the body and a workflow by its id, available to admin only
     * @summary Break the link between a resource object and a workflow
     * @param {string} id ID used to select a resource
     * @param {ResourceObject} resourceObject Parameters needed to select a resource object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public unlinkWorkflow(id: string, resourceObject: ResourceObject, options?: any) {
        return WorkflowApiFp(this.configuration).unlinkWorkflow(id, resourceObject, options)(this.axios, this.basePath);
    }

    /**
     * Find an approval workflow by its id and update its content, available to admin only
     * @summary Update an approval workflow
     * @param {string} id ID used to select a resource
     * @param {Workflow} workflow Parameters needed to update an approval workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowApi
     */
    public updateWorkflow(id: string, workflow: Workflow, options?: any) {
        return WorkflowApiFp(this.configuration).updateWorkflow(id, workflow, options)(this.axios, this.basePath);
    }

}


